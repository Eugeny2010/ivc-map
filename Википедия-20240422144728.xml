<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="ru">
  <siteinfo>
    <sitename>Википедия</sitename>
    <dbname>ruwiki</dbname>
    <base>https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0</base>
    <generator>MediaWiki 1.43.0-wmf.1</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Медиа</namespace>
      <namespace key="-1" case="first-letter">Служебная</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Обсуждение</namespace>
      <namespace key="2" case="first-letter">Участник</namespace>
      <namespace key="3" case="first-letter">Обсуждение участника</namespace>
      <namespace key="4" case="first-letter">Википедия</namespace>
      <namespace key="5" case="first-letter">Обсуждение Википедии</namespace>
      <namespace key="6" case="first-letter">Файл</namespace>
      <namespace key="7" case="first-letter">Обсуждение файла</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">Обсуждение MediaWiki</namespace>
      <namespace key="10" case="first-letter">Шаблон</namespace>
      <namespace key="11" case="first-letter">Обсуждение шаблона</namespace>
      <namespace key="12" case="first-letter">Справка</namespace>
      <namespace key="13" case="first-letter">Обсуждение справки</namespace>
      <namespace key="14" case="first-letter">Категория</namespace>
      <namespace key="15" case="first-letter">Обсуждение категории</namespace>
      <namespace key="100" case="first-letter">Портал</namespace>
      <namespace key="101" case="first-letter">Обсуждение портала</namespace>
      <namespace key="102" case="first-letter">Инкубатор</namespace>
      <namespace key="103" case="first-letter">Обсуждение Инкубатора</namespace>
      <namespace key="104" case="first-letter">Проект</namespace>
      <namespace key="105" case="first-letter">Обсуждение проекта</namespace>
      <namespace key="106" case="first-letter">Арбитраж</namespace>
      <namespace key="107" case="first-letter">Обсуждение арбитража</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Модуль</namespace>
      <namespace key="829" case="first-letter">Обсуждение модуля</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Шаблон:Государство</title>
    <ns>10</ns>
    <id>48579</id>
    <revision>
      <id>131785843</id>
      <parentid>129659747</parentid>
      <timestamp>2023-07-18T14:45:13Z</timestamp>
      <contributor>
        <username>Krestenti</username>
        <id>3389208</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="18418" xml:space="preserve">{{Карточка
|имя              = Государство
|автозаголовки    = да
|from             = {{{from|}}}

|вверху0          = {{#switch: {{{Статус|}}}
  | виртуальное         = [[Виртуальное государство]]
  | особый        = {{#if: {{{Спорный статус|}}} | {{{Особый спорный статус|}}} }}
  | Непризнанное
  | непризнанное        = {{#if: {{{Спорный статус|}}} | [[Непризнанные и частично признанные государства|Непризнанное государство]] }}
  | Частично признанное
  | частично признанное = {{#if: {{{Спорный статус|}}} | [[Непризнанные и частично признанные государства|Частично признанное государство]] }}
  }}
|вверху           = {{карточка/название|{{{Русское название|}}}|from={{{from|}}}}}
|вверху2          = {{карточка/оригинал названия|{{карточка/официальное название|{{{Оригинальное название|}}}|from={{{from|}}}}}|from={{{from|}}}}}

|изображение      = {{Карточка/флаг и герб
   | флаг         = {{{Флаг|}}}
   | флаг ширина  = {{{Размер флага|}}}{{{размер флага|}}}
   | флаг подпись = [[{{#if: {{{Ссылка на флаг|}}} | {{{Ссылка на флаг}}} | Флаг {{{Родительный падеж}}} }}|Флаг]]
   | герб         = {{{Герб|}}}
   | герб ширина  = {{{Размер герба|}}}{{{размер герба|}}}
   | герб подпись = {{#if: {{{Отображаемая подпись герба|}}} | {{{Отображаемая подпись герба}}} | {{#if: {{{Вместо герба|}}} | [[{{{Вместо герба}}} {{{Родительный падеж}}}|{{{Вместо герба}}}]] | [[Герб {{{Родительный падеж}}}|Герб]] }} }}
  |from={{{from|}}}}}

|текст1           = {{br separated entries
  | {{#if: {{{Девиз|}}} | [[Девиз]]: ''«{{{Девиз}}}»'' }}
  | {{#if: {{{Перевод девиза|}}} | ''«{{{Перевод девиза}}}»'' }}
  }}

|текст2           = {{#if: {{{Без гимна|}}} || {{#if: {{{Название гимна|}}} | {{br separated entries  | [[Государственный гимн|Гимн]]: [[Гимн {{{Родительный падеж}}}|''«{{{Название гимна}}}»'']]  | {{#if: {{{Перевод названия гимна|}}} | ''«{{{Перевод названия гимна}}}»'' }} }} | [[Гимн {{{Родительный падеж&lt;noinclude&gt;|&lt;/noinclude&gt;}}}|Государственный гимн {{{Родительный падеж&lt;noinclude&gt;|&lt;/noinclude&gt;}}}]] }}{{#if: {{{Аудио|}}} | {{#if: {{{Аудио|}}} | [[Файл:{{{Аудио|}}}|center]] }} }} }}

|текст3           = {{#if: {{wikidata|p242|{{{На карте|}}}|plain=true|from={{{from|}}}}} | {{wikidata|p242|{{{На карте|}}}|size={{#if: {{{Размер карты|}}}{{{размер карты|}}} | {{{Размер карты|}}}{{{размер карты|}}} | 300x300px }}|caption={{{Подпись к карте|}}}{{{подпись к карте|}}}|from={{{from|}}}}}&lt;!--
--&gt;{{#if: {{{На карте2|}}} | &lt;br&gt;[[Файл:{{{На карте2}}}|{{{Размер карты2|{{{размер карты2|300x300px}}}}}}]]{{#if:{{{Подпись к карте 2|}}}{{{подпись к карте 2|}}}|&lt;br&gt;{{{Подпись к карте 2|{{{подпись к карте 2|}}}}}} }} }} }}

|заголовок4       = {{#if: {{{sovereignty_type|}}} | {{{sovereignty_type}}} | [[История {{{Родительный падеж}}}|История]] }}
|стиль_заголовка4 = padding-bottom:0; border-bottom:0; text-align:left;

|блок5            =
  {{Карточка/блок с маркерами
  |метка1 = {{nobr|{{{Дата1}}}}}
  |текст1 = {{{Этап1|}}}
  |метка2 = {{nobr|{{{Дата2}}}}}
  |текст2 = {{{Этап2|}}}
  |метка3 = {{nobr|{{{Дата3}}}}}
  |текст3 = {{{Этап3|}}}
  |метка4 = {{nobr|{{{Дата4}}}}}
  |текст4 = {{{Этап4|}}}
  |метка5 = {{nobr|{{{Дата5}}}}}
  |текст5 = {{{Этап5|}}}
  |метка6 = {{nobr|{{{Дата6}}}}}
  |текст6 = {{{Этап6|}}}
  |метка7 = {{nobr|{{{Дата7}}}}}
  |текст7 = {{{Этап7|}}}
  |метка8 = {{nobr|{{{Дата8}}}}}
  |текст8 = {{{Этап8|}}}
  |метка9 = {{nobr|{{{Дата9}}}}}
  |текст9 = {{{Этап9|}}}
  |метка10 = {{nobr|{{{Дата10}}}}}
  |текст10 = {{{Этап10|}}}
  |метка11 = {{nobr|{{{Дата11}}}}}
  |текст11 = {{{Этап11|}}}
  |метка12 = {{nobr|{{{Дата12}}}}}
  |текст12 = {{{Этап12|}}}
  |from={{{from|}}}}}

|заголовок6       = -

|метка7           = [[Основание государства|{{#if: {{{Основана|}}} | Основана | Основано }}]]
|текст7           = {{{Основана|}}}{{{Основано|}}}
|викиданные7      =

&lt;!-- СПОРНЫЙ СТАТУС --&gt;
&lt;!-- Спорный статус заполнен --&gt;
|метка8           = [[Основание государства|Дата образования]]
|текст8           = {{#if: {{{Спорный статус|}}} | {{{Дата образования|}}} }}
|викиданные8      = 

|метка9           = Провозглашение независимости
|текст9           = {{#if: {{{Спорный статус|}}} | {{#if: {{{Провозглашение независимости|}}} | {{{Провозглашение независимости}}} {{#if: {{{Независимость от|}}} | (от&amp;nbsp;{{{Независимость от}}}) }} }} }}
|викиданные9      = 

|метка10          = [[Международно-правовое признание|Дипломатическое признание]]
|текст10          = {{#if: {{{Спорный статус|}}} | {{{Дипломатическое признание|}}} }}
|викиданные10     =

&lt;!-- Спорный статус не заполнен --&gt;
|метка11          = {{#if: {{{Отображаемый тип независимости|}}} | {{{Отображаемый тип независимости}}} | [[Суверенитет|{{#if: {{{Даты независимости|}}} | Даты | Дата }} независимости]] }}
|текст11          = {{#if: {{{Спорный статус|}}} || {{#if: {{{Дата независимости|}}}{{{Даты независимости|}}} | {{{Дата независимости|{{{Даты независимости|}}}}}} {{#if: {{{Независимость от|}}} | (от&amp;nbsp;{{{Независимость от}}}) }} }} }}
|викиданные11     =
&lt;!-- / СПОРНЫЙ СТАТУС --&gt;

|метка12          = [[Официальный язык|{{#if: {{{Язык|}}} | Официальный язык | Официальные языки }}]]
|текст12          = {{{Язык|{{{Языки|}}}}}}
|викиданные12     = p37

|метка13          = [[Столица]]
|текст13          = {{{Столица|}}}
|викиданные13     = p36

|метка14          = {{#if: {{{Крупнейший город|}}} | Крупнейший город | Крупнейшие города }}
|текст14          = {{{Крупнейший город|}}}{{{Крупнейшие города|}}}
|викиданные14     = 

|метка15          = [[Форма государственного правления|Форма правления]]
|текст15          = {{{Форма правления|}}}
|викиданные15     = 

|метка16          = [[Форма государственного устройства|Государственный строй]]
|текст16          = {{{Государственный строй|}}}

|метка17          = {{{Должность руководителя 1|{{{Должности руководителей}}}}}}
|текст17          = {{{Руководитель 1|{{{Руководители|}}}}}}

|метка18          = {{{Должность руководителя 2}}}
|текст18          = {{{Руководитель 2|}}}

|метка19          = {{{Должность руководителя 3}}}
|текст19          = {{{Руководитель 3|}}}

|метка20          = {{{Должность руководителя 4}}}
|текст20          = {{{Руководитель 4|}}}

|метка21          = {{{Должность руководителя 5}}}
|текст21          = {{{Руководитель 5|}}}

|метка22          = {{{Должность руководителя 6}}}
|текст22          = {{{Руководитель 6|}}}

|метка23          = [[Государственная религия|Гос. религия]]
|текст23          = {{{Государственная религия|}}}
|викиданные23     = 

|блок24           =
  {{Карточка/блок с маркерами
  |подзаголовок = [[Территория государства|Территория]]

  |метка1 = Всего
  |текст1 = {{br separated entries
    | {{число|{{{Территория|}}}|км²}}{{#if: {{{Место по территории|}}} | &amp;nbsp;{{nobr|([[Список государств и зависимых территорий по площади|{{{Место по территории}}}-я в мире]])}} }}
    | {{число|{{{Территория2|}}}|км²}}
    }}

  |метка2 = % водной поверхности
  |текст2 = {{#ifeq: {{{Процент воды|}}} | - || {{{Процент воды|}}} }}
  |from={{{from|}}}}}

|блок25           =
  {{Карточка/блок с маркерами
  |подзаголовок = [[{{Население государства|{{PAGENAME}}}}]]

  |метка1 = Оценка {{#if: {{{Год оценки|}}} | ({{{Год оценки}}}) }}
  |текст1 = {{br separated entries
    | {{число|{{{Население|}}}|чел.}}{{#if: {{{Место по населению|}}} | &amp;nbsp;([[Список стран по населению|{{{Место по населению}}}-е]]) }}
    | {{число|{{{Население2|}}}|чел.}}
    }}

  |метка2 = Перепись {{#if: {{{Год переписи|}}} | ({{{Год переписи}}}) }}
  |текст2 = {{число|{{{Население по переписи|}}}|чел.}}

  |метка3 = [[Плотность населения|Плотность]]
  |текст3 = {{число|{{{Плотность населения|}}}|чел./км²}}{{#if: {{{Место по плотности|}}} | &amp;nbsp;([[Список стран по плотности населения|{{{Место по плотности}}}-я]]) }}
  |from={{{from|}}}}}

|блок26           =
  {{Карточка/блок с маркерами
  |подзаголовок = [[Валовой внутренний продукт|ВВП]]

  |метка1 = Итого {{#if: {{{Год расчёта ВВП|}}} | ({{{Год расчёта ВВП}}}) }}
  |текст1 = {{число|{{{ВВП|}}}|[[Доллар США|долл.]]}}{{#if: {{{Место по ВВП|}}} | &amp;nbsp;([[Список стран по ВВП (ППС)|{{{Место по ВВП}}}-й]]) }}

  |метка2 = На душу населения
  |текст2 = {{число|{{{ВВП на душу населения|}}}|[[Доллар США|долл.]]}}{{#if: {{{Место по ВВП на душу населения|}}} | &amp;nbsp;([[Список стран по ВВП (ППС) на душу населения|{{{Место по ВВП на душу населения}}}-й]]) }}
  |from={{{from|}}}}}

|блок27           =
  {{Карточка/блок с маркерами
  |подзаголовок = [[Валовой внутренний продукт|ВВП]] &lt;span style="font-weight:normal;"&gt;([[Паритет покупательной способности|ППС]])&lt;/span&gt;

  |метка1 = Итого {{#if: {{{Год расчёта ВВП (ППС)|}}} | ({{{Год расчёта ВВП (ППС)}}}) }}
  |текст1 = {{число|{{{ВВП (ППС)|}}}|[[Доллар США|долл.]]}}{{#if: {{{Место по ВВП (ППС)|}}} | &amp;nbsp;([[Список стран по ВВП (ППС)|{{{Место по ВВП (ППС)}}}-й]]) }}

  |метка2 = На душу населения
  |текст2 = {{число|{{{ВВП (ППС) на душу населения|}}}|[[Доллар США|долл.]]}}{{#if: {{{Место по ВВП (ППС) на душу населения|}}} | &amp;nbsp;([[Список стран по ВВП (ППС) на душу населения|{{{Место по ВВП (ППС) на душу населения}}}-й]]) }}
  |from={{{from|}}}}}

|блок28           =
  {{Карточка/блок с маркерами
  |подзаголовок = [[Валовой внутренний продукт|ВВП]] &lt;span style="font-weight:normal;"&gt;(номинал)&lt;/span&gt;

  |метка1 = Итого {{#if: {{{Год расчёта ВВП (номинал)|}}} | ({{{Год расчёта ВВП (номинал)}}}) }}
  |текст1 = {{число|{{{ВВП (номинал)|}}}|[[Доллар США|долл.]]}}{{#if: {{{Место по ВВП (номинал)|}}} | &amp;nbsp;([[Список стран по ВВП (номинал)|{{{Место по ВВП (номинал)}}}-й]]) }}

  |метка2 = На душу населения
  |текст2 = {{число|{{{ВВП (номинал) на душу населения|}}}|[[Доллар США|долл.]]}}{{#if: {{{Место по ВВП (номинал) на душу населения|}}} | &amp;nbsp;([[Список стран по ВВП (номинал) на душу населения|{{{Место по ВВП (номинал) на душу населения}}}-й]]) }}
  |from={{{from|}}}}}

|метка29          = [[Индекс человеческого развития|ИЧР]] {{#if: {{{Год расчёта ИРЧП|}}} | &lt;span style="font-weight:normal;"&gt;({{{Год расчёта ИРЧП}}})&lt;/span&gt; }}
|текст29          = {{{ИРЧП|}}}{{#if: {{{Уровень ИРЧП|}}} | &amp;nbsp;({{{Уровень ИРЧП}}}{{#if: {{{Место по ИРЧП|}}} | &amp;#059; [[Список стран по индексу человеческого развития|{{{Место по ИРЧП}}}-е&amp;nbsp;место]] }}) }}
|викиданные29     = 

|метка30          = [[Названия жителей]]
|текст30          = {{{Этнохороним|}}}
|викиданные30     = 

|метка31          = [[Валюта]]
|текст31          = {{{Валюта|}}}
|викиданные31     = P38

|метка32          = [[Домен верхнего уровня|{{wikidata number switch|P78|{{{Домен|}}}|{{{Домены|}}}|Интернет-домен|Интернет-домены}}]]
|текст32          = {{{Домен|}}}{{{Домены|}}}
|викиданные32     = P78

|метка33          = [[ISO 3166-1|Код ISO]]
|текст33          = 
|викиданные33     = P297

|метка34          = [[Список кодов МОК|Код МОК]]
|текст34          = 
|викиданные34     = P984

|метка35          = [[Список телефонных кодов стран|Телефонный код]]
|текст35          = {{#if: {{{Телефонный код|}}} | {{#ifeq: {{{Телефонный код|}}} | - | - | +{{{Телефонный код}}} }} }}
|викиданные35     = P474

|метка36          = [[Часовой пояс|{{wikidata number switch|P421|{{{Часовой пояс|}}}|{{{Часовые пояса|}}}|Часовой пояс|Часовые пояса}}]]
|текст36          = {{{Часовой пояс|}}}{{{Часовые пояса|}}}
|викиданные36     = P421

|метка37          = Автомобильное движение
|текст37          = {{{Автомобильное движение|}}}
|викиданные37     = P1622

|текст38          = {{{Примечания|}}}
|стиль_текста38   = border-top:1px solid #a2a9b1; color:#54595d; padding-top:0.5em; text-align:left;

|внизу            = {{карточка/Викисклад|from={{{from|}}}}}
}}{{#if: {{{nocat|}}}{{NAMESPACE}} || &lt;!--
--&gt;{{#if: {{{lat_deg|}}}
  | {{coord|1={{{lat_deg|}}}|2={{{lat_min|0}}}|3={{{lat_sec|0}}}|4={{#if: {{{lat_dir|}}} | {{{lat_dir}}} | N }}|5={{{lon_deg|}}}|6={{{lon_min|0}}}|7={{{lon_sec|0}}}|8={{#if: {{{lon_dir|}}} | {{{lon_dir}}} | E }}|type=country|region={{{region|}}}|scale={{{CoordScale|}}}|format=dms|display=title}}
  | {{#if: {{#property: p625}} | {{wikidata|p625|type=country|region={{{region|}}}|scale={{{CoordScale|}}}|from={{{from|}}}}} | [[Категория:Государства без указанных географических координат]] }}
  }}&lt;!--
--&gt;{{#switch: {{{Статус|}}}
  | Виртуальное
  | виртуальное         = [[Категория:Виртуальные государства]]
  | Непризнанное
  | непризнанное        = [[Категория:Непризнанные государства]]
  | Частично признанное
  | частично признанное = [[Категория:Частично признанные государства]]
  | особый = {{#if: {{{Спорный статус|}}} | {{#if: {{{Особая категория|}}}|[[Категория:{{{Особая категория|}}}]]|[[Категория:Государства по алфавиту]]}} }}
  | [[Категория:Государства по алфавиту]]
  }}&lt;!--
--&gt;{{Государство/Викиданные}}
}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>ox2nswqi2ud59l1pbxo1e34030srvm7</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Langi</title>
    <ns>10</ns>
    <id>46411</id>
    <revision>
      <id>88306449</id>
      <parentid>9355144</parentid>
      <timestamp>2017-10-14T07:25:47Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <minor/>
      <comment>→ [[/doc]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="111" xml:space="preserve">&lt;span lang="{{{1}}}" xml:lang="{{{1}}}" style="font-style:italic;"&gt;{{{2}}}&lt;/span&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>egalx0g0ntd9f02qcdsw9lvcr8etkcr</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Arguments</title>
    <ns>828</ns>
    <id>5039915</id>
    <revision>
      <id>90250356</id>
      <parentid>79068058</parentid>
      <timestamp>2018-01-12T21:01:04Z</timestamp>
      <contributor>
        <username>Grain of sand</username>
        <id>1731654</id>
      </contributor>
      <comment>sandbox → песочница</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="10065" xml:space="preserve">-- This module provides easy processing of arguments passed to Scribunto from
-- #invoke. It is intended for use by other Lua modules, and should not be
-- called from #invoke directly.

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType

local arguments = {}

-- Generate four different tidyVal functions, so that we don't have to check the
-- options every time we call it.

local function tidyValDefault(key, val)
	if type(val) == 'string' then
		val = val:match('^%s*(.-)%s*$')
		if val == '' then
			return nil
		else
			return val
		end
	else
		return val
	end
end

local function tidyValTrimOnly(key, val)
	if type(val) == 'string' then
		return val:match('^%s*(.-)%s*$')
	else
		return val
	end
end

local function tidyValRemoveBlanksOnly(key, val)
	if type(val) == 'string' then
		if val:find('%S') then
			return val
		else
			return nil
		end
	else
		return val
	end
end

local function tidyValNoChange(key, val)
	return val
end

local function matchesTitle(given, title)
	local tp = type( given )
	return (tp == 'string' or tp == 'number') and mw.title.new( given ).prefixedText == title
end

local translate_mt = { __index = function(t, k) return k end }

function arguments.getArgs(frame, options)
	checkType('getArgs', 1, frame, 'table', true)
	checkType('getArgs', 2, options, 'table', true)
	frame = frame or {}
	options = options or {}

	--[[
	-- Set up argument translation.
	--]]
	options.translate = options.translate or {}
	if getmetatable(options.translate) == nil then
		setmetatable(options.translate, translate_mt)
	end
	if options.backtranslate == nil then
		options.backtranslate = {}
		for k,v in pairs(options.translate) do
			options.backtranslate[v] = k
		end
	end
	if options.backtranslate and getmetatable(options.backtranslate) == nil then
		setmetatable(options.backtranslate, {
			__index = function(t, k)
				if options.translate[k] ~= k then
					return nil
				else
					return k
				end
			end
		})
	end

	--[[
	-- Get the argument tables. If we were passed a valid frame object, get the
	-- frame arguments (fargs) and the parent frame arguments (pargs), depending
	-- on the options set and on the parent frame's availability. If we weren't
	-- passed a valid frame object, we are being called from another Lua module
	-- or from the debug console, so assume that we were passed a table of args
	-- directly, and assign it to a new variable (luaArgs).
	--]]
	local fargs, pargs, luaArgs
	if type(frame.args) == 'table' and type(frame.getParent) == 'function' then
		if options.wrappers then
			--[[
			-- The wrappers option makes Module:Arguments look up arguments in
			-- either the frame argument table or the parent argument table, but
			-- not both. This means that users can use either the #invoke syntax
			-- or a wrapper template without the loss of performance associated
			-- with looking arguments up in both the frame and the parent frame.
			-- Module:Arguments will look up arguments in the parent frame
			-- if it finds the parent frame's title in options.wrapper;
			-- otherwise it will look up arguments in the frame object passed
			-- to getArgs.
			--]]
			local parent = frame:getParent()
			if not parent then
				fargs = frame.args
			else
				local title = parent:getTitle():gsub('/песочница$', '')
				local found = false
				if matchesTitle(options.wrappers, title) then
					found = true
				elseif type(options.wrappers) == 'table' then
					for _,v in pairs(options.wrappers) do
						if matchesTitle(v, title) then
							found = true
							break
						end
					end
				end

				-- We test for false specifically here so that nil (the default) acts like true.
				if found or options.frameOnly == false then
					pargs = parent.args
				end
				if not found or options.parentOnly == false then
					fargs = frame.args
				end
			end
		else
			-- options.wrapper isn't set, so check the other options.
			if not options.parentOnly then
				fargs = frame.args
			end
			if not options.frameOnly then
				local parent = frame:getParent()
				pargs = parent and parent.args or nil
			end
		end
		if options.parentFirst then
			fargs, pargs = pargs, fargs
		end
	else
		luaArgs = frame
	end

	-- Set the order of precedence of the argument tables. If the variables are
	-- nil, nothing will be added to the table, which is how we avoid clashes
	-- between the frame/parent args and the Lua args.
	local argTables = {fargs}
	argTables[#argTables + 1] = pargs
	argTables[#argTables + 1] = luaArgs

	--[[
	-- Generate the tidyVal function. If it has been specified by the user, we
	-- use that; if not, we choose one of four functions depending on the
	-- options chosen. This is so that we don't have to call the options table
	-- every time the function is called.
	--]]
	local tidyVal = options.valueFunc
	if tidyVal then
		if type(tidyVal) ~= 'function' then
			error(
				"bad value assigned to option 'valueFunc'"
					.. '(function expected, got '
					.. type(tidyVal)
					.. ')',
				2
			)
		end
	elseif options.trim ~= false then
		if options.removeBlanks ~= false then
			tidyVal = tidyValDefault
		else
			tidyVal = tidyValTrimOnly
		end
	else
		if options.removeBlanks ~= false then
			tidyVal = tidyValRemoveBlanksOnly
		else
			tidyVal = tidyValNoChange
		end
	end

	--[[
	-- Set up the args, metaArgs and nilArgs tables. args will be the one
	-- accessed from functions, and metaArgs will hold the actual arguments. Nil
	-- arguments are memoized in nilArgs, and the metatable connects all of them
	-- together.
	--]]
	local args, metaArgs, nilArgs, metatable = {}, {}, {}, {}
	setmetatable(args, metatable)

	local function mergeArgs(tables)
		--[[
		-- Accepts multiple tables as input and merges their keys and values
		-- into one table. If a value is already present it is not overwritten;
		-- tables listed earlier have precedence. We are also memoizing nil
		-- values, which can be overwritten if they are 's' (soft).
		--]]
		for _, t in ipairs(tables) do
			for key, val in pairs(t) do
				if metaArgs[key] == nil and nilArgs[key] ~= 'h' then
					local tidiedVal = tidyVal(key, val)
					if tidiedVal == nil then
						nilArgs[key] = 's'
					else
						metaArgs[key] = tidiedVal
					end
				end
			end
		end
	end

	--[[
	-- Define metatable behaviour. Arguments are memoized in the metaArgs table,
	-- and are only fetched from the argument tables once. Fetching arguments
	-- from the argument tables is the most resource-intensive step in this
	-- module, so we try and avoid it where possible. For this reason, nil
	-- arguments are also memoized, in the nilArgs table. Also, we keep a record
	-- in the metatable of when pairs and ipairs have been called, so we do not
	-- run pairs and ipairs on the argument tables more than once. We also do
	-- not run ipairs on fargs and pargs if pairs has already been run, as all
	-- the arguments will already have been copied over.
	--]]

	metatable.__index = function (t, key)
		--[[
		-- Fetches an argument when the args table is indexed. First we check
		-- to see if the value is memoized, and if not we try and fetch it from
		-- the argument tables. When we check memoization, we need to check
		-- metaArgs before nilArgs, as both can be non-nil at the same time.
		-- If the argument is not present in metaArgs, we also check whether
		-- pairs has been run yet. If pairs has already been run, we return nil.
		-- This is because all the arguments will have already been copied into
		-- metaArgs by the mergeArgs function, meaning that any other arguments
		-- must be nil.
		--]]
		if type(key) == 'string' then
			key = options.translate[key]
		end
		local val = metaArgs[key]
		if val ~= nil then
			return val
		elseif metatable.donePairs or nilArgs[key] then
			return nil
		end
		for _, argTable in ipairs(argTables) do
			local argTableVal = tidyVal(key, argTable[key])
			if argTableVal ~= nil then
				metaArgs[key] = argTableVal
				return argTableVal
			end
		end
		nilArgs[key] = 'h'
		return nil
	end

	metatable.__newindex = function (t, key, val)
		-- This function is called when a module tries to add a new value to the
		-- args table, or tries to change an existing value.
		if type(key) == 'string' then
			key = options.translate[key]
		end
		if options.readOnly then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; the table is read-only',
				2
			)
		elseif options.noOverwrite and args[key] ~= nil then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; overwriting existing arguments is not permitted',
				2
			)
		elseif val == nil then
			--[[
			-- If the argument is to be overwritten with nil, we need to erase
			-- the value in metaArgs, so that __index, __pairs and __ipairs do
			-- not use a previous existing value, if present; and we also need
			-- to memoize the nil in nilArgs, so that the value isn't looked
			-- up in the argument tables if it is accessed again.
			--]]
			metaArgs[key] = nil
			nilArgs[key] = 'h'
		else
			metaArgs[key] = val
		end
	end

	local function translatenext(invariant)
		local k, v = next(invariant.t, invariant.k)
		invariant.k = k
		if k == nil then
			return nil
		elseif type(k) ~= 'string' or not options.backtranslate then
			return k, v
		else
			local backtranslate = options.backtranslate[k]
			if backtranslate == nil then
				-- Skip this one. This is a tail call, so this won't cause stack overflow
				return translatenext(invariant)
			else
				return backtranslate, v
			end
		end
	end

	metatable.__pairs = function ()
		-- Called when pairs is run on the args table.
		if not metatable.donePairs then
			mergeArgs(argTables)
			metatable.donePairs = true
		end
		return translatenext, { t = metaArgs }
	end

	local function inext(t, i)
		-- This uses our __index metamethod
		local v = t[i + 1]
		if v ~= nil then
			return i + 1, v
		end
	end

	metatable.__ipairs = function (t)
		-- Called when ipairs is run on the args table.
		return inext, t, 0
	end

	return args
end

return arguments</text>
      <sha1>qybr673mo3a9b9pszgtux0o6trjd2bd</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:TableTools</title>
    <ns>828</ns>
    <id>5831451</id>
    <revision>
      <id>101809430</id>
      <parentid>71760039</parentid>
      <timestamp>2019-08-26T06:20:31Z</timestamp>
      <contributor>
        <username>Serhio Magpie</username>
        <id>144541</id>
      </contributor>
      <comment>Обновлено с https://en.wikipedia.org/w/index.php?title=Module:TableTools&amp;oldid=887403551</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12326" xml:space="preserve">--[[
------------------------------------------------------------------------------------
--                               TableTools                                       --
--                                                                                --
-- This module includes a number of functions for dealing with Lua tables.        --
-- It is a meta-module, meant to be called from other Lua modules, and should     --
-- not be called directly from #invoke.                                           --
------------------------------------------------------------------------------------
--]]

local libraryUtil = require('libraryUtil')

local p = {}

-- Define often-used variables and functions.
local floor = math.floor
local infinity = math.huge
local checkType = libraryUtil.checkType
local checkTypeMulti = libraryUtil.checkTypeMulti

--[[
------------------------------------------------------------------------------------
-- isPositiveInteger
--
-- This function returns true if the given value is a positive integer, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a given table key is in the array part or the
-- hash part of a table.
------------------------------------------------------------------------------------
--]]
function p.isPositiveInteger(v)
	if type(v) == 'number' and v &gt;= 1 and floor(v) == v and v &lt; infinity then
		return true
	else
		return false
	end
end

--[[
------------------------------------------------------------------------------------
-- isNan
--
-- This function returns true if the given number is a NaN value, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a value can be a valid table key. Lua will
-- generate an error if a NaN is used as a table key.
------------------------------------------------------------------------------------
--]]
function p.isNan(v)
	if type(v) == 'number' and tostring(v) == '-nan' then
		return true
	else
		return false
	end
end

--[[
------------------------------------------------------------------------------------
-- shallowClone
--
-- This returns a clone of a table. The value returned is a new table, but all
-- subtables and functions are shared. Metamethods are respected, but the returned
-- table will have no metatable of its own.
------------------------------------------------------------------------------------
--]]
function p.shallowClone(t)
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- removeDuplicates
--
-- This removes duplicate values from an array. Non-positive-integer keys are
-- ignored. The earliest value is kept, and all subsequent duplicate values are
-- removed, but otherwise the array order is unchanged.
------------------------------------------------------------------------------------
--]]
function p.removeDuplicates(t)
	checkType('removeDuplicates', 1, t, 'table')
	local isNan = p.isNan
	local ret, exists = {}, {}
	for i, v in ipairs(t) do
		if isNan(v) then
			-- NaNs can't be table keys, and they are also unique, so we don't need to check existence.
			ret[#ret + 1] = v
		else
			if not exists[v] then
				ret[#ret + 1] = v
				exists[v] = true
			end
		end	
	end
	return ret
end			

--[[
------------------------------------------------------------------------------------
-- numKeys
--
-- This takes a table and returns an array containing the numbers of any numerical
-- keys that have non-nil values, sorted in numerical order.
------------------------------------------------------------------------------------
--]]
function p.numKeys(t)
	checkType('numKeys', 1, t, 'table')
	local isPositiveInteger = p.isPositiveInteger
	local nums = {}
	for k, v in pairs(t) do
		if isPositiveInteger(k) then
			nums[#nums + 1] = k
		end
	end
	table.sort(nums)
	return nums
end

--[[
------------------------------------------------------------------------------------
-- affixNums
--
-- This takes a table and returns an array containing the numbers of keys with the
-- specified prefix and suffix. For example, for the table
-- {a1 = 'foo', a3 = 'bar', a6 = 'baz'} and the prefix "a", affixNums will
-- return {1, 3, 6}.
------------------------------------------------------------------------------------
--]]
function p.affixNums(t, prefix, suffix)
	checkType('affixNums', 1, t, 'table')
	checkType('affixNums', 2, prefix, 'string', true)
	checkType('affixNums', 3, suffix, 'string', true)

	local function cleanPattern(s)
		-- Cleans a pattern so that the magic characters ()%.[]*+-?^$ are interpreted literally.
		s = s:gsub('([%(%)%%%.%[%]%*%+%-%?%^%$])', '%%%1')
		return s
	end

	prefix = prefix or ''
	suffix = suffix or ''
	prefix = cleanPattern(prefix)
	suffix = cleanPattern(suffix)
	local pattern = '^' .. prefix .. '([1-9]%d*)' .. suffix .. '$'

	local nums = {}
	for k, v in pairs(t) do
		if type(k) == 'string' then			
			local num = mw.ustring.match(k, pattern)
			if num then
				nums[#nums + 1] = tonumber(num)
			end
		end
	end
	table.sort(nums)
	return nums
end

--[[
------------------------------------------------------------------------------------
-- numData
--
-- Given a table with keys like ("foo1", "bar1", "foo2", "baz2"), returns a table
-- of subtables in the format 
-- { [1] = {foo = 'text', bar = 'text'}, [2] = {foo = 'text', baz = 'text'} }
-- Keys that don't end with an integer are stored in a subtable named "other".
-- The compress option compresses the table so that it can be iterated over with
-- ipairs.
------------------------------------------------------------------------------------
--]]
function p.numData(t, compress)
	checkType('numData', 1, t, 'table')
	checkType('numData', 2, compress, 'boolean', true)
	local ret = {}
	for k, v in pairs(t) do
		local prefix, num = mw.ustring.match(tostring(k), '^([^0-9]*)([1-9][0-9]*)$')
		if num then
			num = tonumber(num)
			local subtable = ret[num] or {}
			if prefix == '' then
				-- Positional parameters match the blank string; put them at the start of the subtable instead.
				prefix = 1
			end
			subtable[prefix] = v
			ret[num] = subtable
		else
			local subtable = ret.other or {}
			subtable[k] = v
			ret.other = subtable
		end
	end
	if compress then
		local other = ret.other
		ret = p.compressSparseArray(ret)
		ret.other = other
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- compressSparseArray
--
-- This takes an array with one or more nil values, and removes the nil values
-- while preserving the order, so that the array can be safely traversed with
-- ipairs.
------------------------------------------------------------------------------------
--]]
function p.compressSparseArray(t)
	checkType('compressSparseArray', 1, t, 'table')
	local ret = {}
	local nums = p.numKeys(t)
	for _, num in ipairs(nums) do
		ret[#ret + 1] = t[num]
	end
	return ret
end

--[[
------------------------------------------------------------------------------------
-- sparseIpairs
--
-- This is an iterator for sparse arrays. It can be used like ipairs, but can
-- handle nil values.
------------------------------------------------------------------------------------
--]]
function p.sparseIpairs(t)
	checkType('sparseIpairs', 1, t, 'table')
	local nums = p.numKeys(t)
	local i = 0
	local lim = #nums
	return function ()
		i = i + 1
		if i &lt;= lim then
			local key = nums[i]
			return key, t[key]
		else
			return nil, nil
		end
	end
end

--[[
------------------------------------------------------------------------------------
-- size
--
-- This returns the size of a key/value pair table. It will also work on arrays,
-- but for arrays it is more efficient to use the # operator.
------------------------------------------------------------------------------------
--]]

function p.size(t)
	checkType('size', 1, t, 'table')
	local i = 0
	for k in pairs(t) do
		i = i + 1
	end
	return i
end


local function defaultKeySort(item1, item2)
	-- "number" &lt; "string", so numbers will be sorted before strings.
	local type1, type2 = type(item1), type(item2)
	if type1 ~= type2 then
		return type1 &lt; type2
	else -- This will fail with table, boolean, function.
		return item1 &lt; item2
	end
end

--[[
	Returns a list of the keys in a table, sorted using either a default
	comparison function or a custom keySort function.
]]
function p.keysToList(t, keySort, checked)
	if not checked then
		checkType('keysToList', 1, t, 'table')
		checkTypeMulti('keysToList', 2, keySort, { 'function', 'boolean', 'nil' })
	end
	
	local list = {}
	local index = 1
	for key, value in pairs(t) do
		list[index] = key
		index = index + 1
	end
	
	if keySort ~= false then
		keySort = type(keySort) == 'function' and keySort or defaultKeySort
		
		table.sort(list, keySort)
	end
	
	return list
end

--[[
	Iterates through a table, with the keys sorted using the keysToList function.
	If there are only numerical keys, sparseIpairs is probably more efficient.
]]
function p.sortedPairs(t, keySort)
	checkType('sortedPairs', 1, t, 'table')
	checkType('sortedPairs', 2, keySort, 'function', true)
	
	local list = p.keysToList(t, keySort, true)
	
	local i = 0
	return function()
		i = i + 1
		local key = list[i]
		if key ~= nil then
			return key, t[key]
		else
			return nil, nil
		end
	end
end

--[[
	Returns true if all keys in the table are consecutive integers starting at 1.
--]]
function p.isArray(t)
	checkType("isArray", 1, t, "table")
	
	local i = 0
	for k, v in pairs(t) do
		i = i + 1
		if t[i] == nil then
			return false
		end
	end
	return true
end

-- { "a", "b", "c" } -&gt; { a = 1, b = 2, c = 3 }
function p.invert(array)
	checkType("invert", 1, array, "table")
	
	local map = {}
	for i, v in ipairs(array) do
		map[v] = i
	end
	
	return map
end

--[[
	{ "a", "b", "c" } -&gt; { ["a"] = true, ["b"] = true, ["c"] = true }
--]]
function p.listToSet(t)
	checkType("listToSet", 1, t, "table")
	
	local set = {}
	for _, item in ipairs(t) do
		set[item] = true
	end
	
	return set
end

--[[
	Recursive deep copy function.
	Preserves identities of subtables.
	
]]
local function _deepCopy(orig, includeMetatable, already_seen)
	-- Stores copies of tables indexed by the original table.
	already_seen = already_seen or {}
	
	local copy = already_seen[orig]
	if copy ~= nil then
		return copy
	end
	
	if type(orig) == 'table' then
		copy = {}
		for orig_key, orig_value in pairs(orig) do
			copy[deepcopy(orig_key, includeMetatable, already_seen)] = deepcopy(orig_value, includeMetatable, already_seen)
		end
		already_seen[orig] = copy
		
		if includeMetatable then
			local mt = getmetatable(orig)
			if mt ~= nil then
				local mt_copy = deepcopy(mt, includeMetatable, already_seen)
				setmetatable(copy, mt_copy)
				already_seen[mt] = mt_copy
			end
		end
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

function p.deepCopy(orig, noMetatable, already_seen)
	checkType("deepCopy", 3, already_seen, "table", true)
	
	return _deepCopy(orig, not noMetatable, already_seen)
end

--[[
	Concatenates all values in the table that are indexed by a number, in order.
	sparseConcat{ a, nil, c, d }  =&gt;  "acd"
	sparseConcat{ nil, b, c, d }  =&gt;  "bcd"
]]
function p.sparseConcat(t, sep, i, j)
	local list = {}
	
	local list_i = 0
	for _, v in p.sparseIpairs(t) do
		list_i = list_i + 1
		list[list_i] = v
	end
	
	return table.concat(list, sep, i, j)
end

--[[
-- This returns the length of a table, or the first integer key n counting from
-- 1 such that t[n + 1] is nil. It is similar to the operator #, but may return
-- a different value when there are gaps in the array portion of the table.
-- Intended to be used on data loaded with mw.loadData. For other tables, use #.
-- Note: #frame.args in frame object always be set to 0, regardless of 
-- the number of unnamed template parameters, so use this function for
-- frame.args.
--]]
function p.length(t)
	local i = 1
	while t[i] ~= nil do
		i = i + 1
	end
	return i - 1
end

function p.inArray(arr, valueToFind)
	checkType("inArray", 1, arr, "table")
	
	-- if valueToFind is nil, error?
	
	for _, v in ipairs(arr) do
		if v == valueToFind then
			return true
		end
	end
	
	return false
end

return p</text>
      <sha1>tqif0qe0lu98pj8cuq70kgi6evye5t3</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Template call code</title>
    <ns>828</ns>
    <id>7551793</id>
    <revision>
      <id>117466277</id>
      <parentid>117462282</parentid>
      <timestamp>2021-10-26T19:03:06Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <comment>-избыточный код</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="10261" xml:space="preserve">local getArgs = require('Module:Arguments').getArgs
local ru = mw.language.new('ru')

local p = {}

-- Используется для того, чтобы можно было удалять элементы из таблицы
local function copy(other)
	local res = {}
	for k, v in pairs(other) do
		res[k] = v
	end
	return res
end

local function makeInvokeFunc(funcName, flags)
	return function (frame)
		local args = copy(getArgs(frame, {
			trim = false,
			removeBlanks = false
		}))
		return p[funcName](args, flags)
	end
end

--предотвращает обработку вики-текста в отображении образца
local function processText(str, nowiki)
	local res = str
	if nowiki then
		str = mw.text.unstripNoWiki(str)
		str = string.gsub(str, '%[', '&amp;#91;')
		str = string.gsub(str, '%]', '&amp;#93;')
		str = string.gsub(str, '&lt;', '&amp;lt;')
		str = string.gsub(str, '&gt;', '&amp;gt;')
		str = string.gsub(str, '{', '&amp;#123;')
		str = string.gsub(str, '|', '&amp;#124;')
		str = string.gsub(str, '}', '&amp;#125;')
		str = string.gsub(str, '\'', '&amp;#39;')
		str = string.gsub(str, '"', '&amp;quot;')
		str = string.gsub(str, '(://)', '&lt;span&gt;%1&lt;/span&gt;')
	end
	return str
end

local function addParams(args, params)
	local text, equals_pos, param, value = '', 0, '', ''
	
	local function addPipe()
		if params.spaced then
			text = text .. ' '
		end
		text = text .. '&lt;span class="'
		if not params.spaced then
			text = text .. ' ts-templateCallCode-pipe'
		end
		if not params.black then
			text = text .. ' ts-templateCallCode-weak'
		end
		
		-- &amp;#124;, чтобы не трактовалось как разделитель ячеек в таблицах
		text = text .. '"&gt;&amp;#124;&lt;/span&gt;'
	end
	
	local beforeParam = '&lt;span class="ts-templateCallCode-param"&gt;'
	local afterParam = '&lt;/span&gt;'
	
	for k, v in pairs(args) do
		if type(k) == 'number' then  -- Неименованные параметры
			if k &gt;= params.from then
				equals_pos = v:find('=')
				if equals_pos and v:find('{{=}}') == equals_pos - 2 then
					equals_pos = nil
				end
				if equals_pos then  -- Содержащие «=» преобразуем в именованные
					param = v:sub(1, equals_pos - 1)
					value = v:sub(equals_pos + 1)
					addPipe()
					text = text .. beforeParam .. processText(param, params.nowiki) .. '=' .. processText(value, params.nowiki) .. afterParam
				else  -- Истинно неименованные
					addPipe()
					local paramValue = processText(v, params.nowiki)
					if #paramValue ~= 0 then
						text = text .. beforeParam .. paramValue .. afterParam
					end
				end
			end
		elseif not k:find('^_') then  -- Именованные параметры, исключая модификаторы внешнего вида
			addPipe()
			text = text .. beforeParam .. processText(k, params.nowiki) .. '=' .. processText(v, params.nowiki) .. afterParam
		end
	end
	
	return text
end

function p._main(args, flags)
	local name = args[1]
	table.remove(args, 1)
	
	-- Вещи типа «=» в первом параметре
	if not name then
		for k, v in pairs(args) do
			if not k:find('^_') then
				name = k .. '=' .. v
				args[k] = nil
				break
			end
		end
	end
	
	local optpText
	if not flags.withoutParams then
		if name then
			local spanOffset = mw.ustring.find(name, '&lt;span')  -- След использования шаблона optp
			if spanOffset then
				optpText = mw.ustring.sub(name, spanOffset)
				name = mw.ustring.sub(name, 1, spanOffset - 1)
			end
		end
	end
	
	local yesno = require('Module:Yesno')
	
	local nolink, subst, podst, global, nav, noRedirect, ucFirst, black, nobr
	local tag, style, comment, lang, sister, global, textInPlaceOfName, 
		namePrefix, prefix, postfix, nowiki
	local spaced, from
	
	if flags.withoutParams then
		for i, v in ipairs(args) do
			if v == 'nl' or v == 'nolink' then
				noLink = true
			elseif v == 's' then
				subst = true
			elseif v == 'п' then
				podst = true
			elseif v == 'g' then
				global = true
			elseif v == 'nav' then
				nav = true
			elseif v == 'noredir' then
				noRedirect = true
			elseif v == 'u' then
				ucFirst = true
			elseif v == 'b' then
				black = true
			elseif v == 'nobr' then
				nobr = true
			end
		end

		tag = args.tag or 'span'
		style = args.style
		comment = args.comment
		lang = args.lang
		sister = args.sister
		textInPlaceOfName = args.text
		namePrefix = args.nameprefix
		prefix = args.prefix
		postfix = args.postfix
		nowiki = args.nowiki
	else
		noLink = yesno(args._nolink or args._nl, false) or not yesno(args._link, false)
		subst = yesno(args._s, false)
		podst = yesno(args['_п'], false)
		global = yesno(args._g, false)
		nav = yesno(args._nav, false)
		noRedirect = yesno(args._noredir, false)
		ucFirst = yesno(args._u, false)
		black = yesno(args._b, false)
		nobr = yesno(args._nobr, false)
		
		tag = args._tag or 'span'
		style = args._style
		comment = args._comment
		lang = args._lang
		sister = args._sister
		textInPlaceOfName = args._text
		namePrefix = args._nameprefix
		prefix = args._prefix
		postfix = args._postfix
		nowiki = args._nowiki
		
		spaced = yesno(args._spaced, false)
		from = (tonumber(args._from) or 2) - 1

	end
	
	global = global or name and mw.ustring.sub(name, 1, 1) == ':'
	black = black or tag ~= 'span'
	
	if textInPlaceOfName == '' then
		textInPlaceOfName = nil
	end
	if comment == '' then
		comment = nil
	end
	if lang == '' then
		lang = nil
	end
	if sister == '' then
		sister = nil
	end
	if namePrefix == '' then
		namePrefix = nil
	end
	
	if name then
		local trimmedName = mw.text.trim(name)
		if ru:lc(mw.ustring.sub(trimmedName, 1, 6)) == 'subst:' then
			subst = true
			name = mw.ustring.sub(trimmedName, 7)
		end
		if ru:lc(mw.ustring.sub(trimmedName, 1, 6)) == 'подст:' then
			podst = true
			name = mw.ustring.sub(trimmedName, 7)
		end
	end
	
	if subst then
		namePrefix = 'subst:'
	elseif podst then
		namePrefix = 'подст:'
	end
	
	local currentTitle = mw.title.getCurrentTitle()
	-- При опущенном первом параметре берём имя шаблона из названия страницы
	if name == '' or not name then
		local currentTitleRoot = currentTitle.rootText
		if not ucFirst and
			(
				(
					ru:uc(currentTitleRoot) ~= currentTitleRoot and
					-- Книга:Литературное наследство, TranslateDate
					not mw.ustring.match(currentTitleRoot, '^[А-Яа-яA-Za-z]+:?[А-ЯA-Z]')
				) or
				#currentTitleRoot == 1
			)
		then
			name = ru:lcfirst(currentTitleRoot)
		else
			name = currentTitleRoot
		end
	end
	
	-- Начинаем собирать код
	local linkBody, titleObject, linkBegin, linkDivider, linkEnd
	
	local prefixes = {}
	if lang then
		table.insert(prefixes, lang)
	end
	if sister then
		table.insert(prefixes, sister)
	end
	linkBody = table.concat(prefixes, ':')
	
	if #linkBody ~= 0 then
		linkBody = ':' .. linkBody
	end
	if mw.ustring.sub(name, 1, 1) ~= ':' then
		linkBody = linkBody .. ':'
	end
	if not global then
		linkBody = linkBody .. 'Template:'
	end
	linkBody = linkBody .. name
	titleObject = mw.title.new(linkBody)
	
	local noLink = noLink or currentTitle == titleObject

	if not noLink then
		if not noRedirect or (
			noRedirect and
			not lang and
			not sister and
			not titleObject.exists
		) then
			linkBegin = '[['
			linkEnd = ']]'
			linkDivider = '|'
		else
			linkBegin = '['
			linkEnd = ']'
			linkDivider = ' '
			linkBody = titleObject:fullUrl('redirect=no')
		end
	end
	
	local text = ''
	if tag then
		text = text .. '&lt;' .. tag .. ' class="ts-templateCallCode'
		if nobr then
			text = text .. ' nowrap'
		end
		text = text .. '"'
		if style then
			text = text .. ' style="' .. style .. '"'
		end
		text = text .. '&gt;'
	end
	if prefix then
		text = text .. processText(prefix, nowiki)
	end
	
	text = text .. '&lt;span class="'
	if not spaced then
		text = text .. ' ts-templateCallCode-opening'
	end
	if not black then
		text = text .. ' ts-templateCallCode-weak'
	end
	text = text .. '"&gt;{{'
	if namePrefix then
		text = text .. namePrefix
	end
	text = text .. '&lt;/span&gt;'
	
	if nav and currentTitle == titleObject then
		text = text .. '\'\'\''
	end
	
 	text = text .. '&lt;span class="ts-templateCallCode-templateName" data-navboxnavigation-link="0"&gt;'
	
	local commentedLabel
	if comment then
		-- https://phabricator.wikimedia.org/T200704
		-- commentedLabel = mw.getCurrentFrame():expandTemplate({title = 'comment', args = {(textInPlaceOfName or name), comment}})
		commentedLabel = '&lt;span class="commentedText" title="' .. comment .. '" style="border-bottom: 1px dotted; cursor: help;"&gt;' ..
			(textInPlaceOfName or name) ..
			'&lt;/span&gt;'
	end
	local label = (commentedLabel or textInPlaceOfName or name)
	if not noLink then
		if noRedirect then
			text = text .. '&lt;span class="plainlinks"&gt;'
		end
		text = text .. linkBegin .. linkBody .. linkDivider .. label .. linkEnd
		if noRedirect then
			text = text .. '&lt;/span&gt;'
		end
	else
		text = text .. label
	end
	
	text = text .. '&lt;/span&gt;'
	
	if nav and currentTitle == titleObject then
		text = text .. '\'\'\''
	end
	
	if not flags.withoutParams then
		if optpText then
			text = text .. optpText
		end
		
		text = text .. addParams(args, {
			spaced = spaced,
			black = black,
			nowiki = nowiki,
			from = from
		})
		
		if spaced then
			text = text .. ' '
		end
	end
	
	text = text .. '&lt;span class="'
	if not spaced then
		text = text .. ' ts-templateCallCode-closing'
	end
	if not black then
		text = text .. ' ts-templateCallCode-weak'
	end
	text = text .. '"&gt;}}&lt;/span&gt;'
	
	if postfix then
		text = text .. processText(postfix, nowiki)
	end
	if tag then
		text = text .. '&lt;/' .. tag .. '&gt;'
	end
	
	local ts = mw.getCurrentFrame():extensionTag{ name = 'templatestyles', args = { src = 'Модуль:Template call code/styles.css' } }
	
	return ts .. text
end

function p._onlyParams(args)
	local yesno = require('Module:Yesno')
	
	return addParams(args, {
		spaced = yesno(args._spaced, false),
		black = true,
		nowiki = yesno(args._nowiki, false),
		from = 1
	})
end

p.withoutParams = makeInvokeFunc('_main', {withoutParams = true})
p.withParams = makeInvokeFunc('_main', {withoutParams = false})
p.onlyParams = makeInvokeFunc('_onlyParams')

return p</text>
      <sha1>mzlnushgv0vlvcfdbpmn0n87m19aglz</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Yesno</title>
    <ns>828</ns>
    <id>5831388</id>
    <revision>
      <id>136979910</id>
      <parentid>93357260</parentid>
      <timestamp>2024-03-30T22:30:54Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>кириллическая у из-за невозможности различить от латинской</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="863" xml:space="preserve">-- Function allowing for consistent treatment of boolean-like wikitext input.
-- It works similarly to the template {{yesno}}.

return function (val, default)
	-- If your wiki uses non-ascii characters for any of "yes", "no", etc., you
	-- should replace "val:lower()" with "mw.ustring.lower(val)" in the
	-- following line.
	val = type(val) == 'string' and val:lower() or val
	if val == nil then
		return nil
	elseif val == true 
		or val == 'yes'
		or val == 'y'
		or val == 'true'
		or val == 't'
		or val == 'да'
		or val == 'д'
		-- кириллица
		or val == 'у'
        or val == '+'
		or tonumber(val) == 1
	then
		return true
	elseif val == false
		or val == 'no'
		or val == 'n'
		or val == 'false'
		or val == 'f'
		or val == 'нет'
		or val == 'н'
		or val == '-'
		or tonumber(val) == 0
	then
		return false
	else
		return default
	end
end</text>
      <sha1>ke5f8y45e4typ74tz80qpciwyipnzvc</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Template call code/styles.css</title>
    <ns>828</ns>
    <id>9037153</id>
    <revision>
      <id>117895138</id>
      <parentid>117466831</parentid>
      <timestamp>2021-11-15T10:35:51Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <comment>поддержка [[t:optp]] (например, на [[Модуль:Unsubst/doc]])</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="772" xml:space="preserve">.ts-templateCallCode-weak {
	color: #72777d;
}

.ts-templateCallCode-pipe {
	margin: 0 2px;
}

.ts-templateCallCode-pipe + .ts-templateCallCode-pipe,
/* Template:Optp */
.ts-templateCallCode-pipe + .ts-templateCallCode-param &gt; .ts-templateCallCode-weak:first-child &gt; .ts-templateCallCode-pipe:first-child {
	margin-left: 0;
}

.ts-templateCallCode-param + .ts-templateCallCode-closing {
	margin-left: 2px;
}

span.ts-templateCallCode &gt; .ts-templateCallCode-templateName a {
	/* Решение из https://ru.wikipedia.org/wiki/Шаблон:Фиттс */
	padding: 0 0.5em !important; /* Перезаписываем стиль для .plainlinks a.external */
	position: relative;
	margin: -0.5em;
}

/* [[Категория:Шаблоны:Подстраницы CSS]] */</text>
      <sha1>l0mispqb89hpjd3g7hgnqt7a6j323ud</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка</title>
    <ns>10</ns>
    <id>1045151</id>
    <revision>
      <id>121176047</id>
      <parentid>121175993</parentid>
      <timestamp>2022-04-03T23:49:38Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>пробуем красить каждую карточку на странице отдельно, без перекрытия стилей; надеюсь, комбинация имя+вверху0+вверху+вверху2 достаточно уникальна и не вызовет ошибок</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7477" xml:space="preserve">{{#if:{{{имя|}}}|{{#ifeq:{{{имя|}}}|-||{{#if:{{{цвет|}}}|{{#tag:templatestyles|
|wrapper=.infobox-{{#invoke:Hash|main|{{{имя}}} {{{вверху0|}}} {{{вверху|}}} {{{вверху2|}}}}}
|src=Шаблон:Цвет/{{{цвет|}}}.css
}}}}}}}}&lt;table class="infobox infobox-{{#invoke:Hash|main|{{{имя}}} {{{вверху0|}}} {{{вверху|}}} {{{вверху2|}}}}} {{{класс_тела|}}}" style="{{{стиль_тела|}}}" {{#if:{{{имя|}}}|{{#ifeq:{{{имя|}}}|-||data-name="{{{имя}}}"}}}} {{#if:{{{from|}}}|{{#ifeq:{{{from|}}}|-||data-from="{{{from}}}"}}}}&gt;&lt;!--
 Вверху0
--&gt;{{#if:{{{вверху0|}}}|&lt;tr&gt;&lt;td colspan="2" class="{{{класс_вверху0|}}}" style="text-align:center; {{{стиль_вверху0|}}}"&gt;{{{вверху0}}}&lt;/td&gt;&lt;/tr&gt;}}&lt;!--
 Вверху
--&gt;{{#if:{{{вверху|}}}|&lt;tr&gt;&lt;th colspan="2" scope="colgroup" class="infobox-above {{{класс_вверху|}}}" style="{{{стиль_вверху|}}}"&gt;{{{вверху}}}&lt;/th&gt;&lt;/tr&gt;}}&lt;!--
 Вверху2
--&gt;{{#if:{{{вверху2|}}}|&lt;tr&gt;&lt;td colspan="2" class="{{{класс_вверху2|}}}" style="text-align:center; {{{стиль_вверху2|}}}"&gt;{{{вверху2}}}&lt;/td&gt;&lt;/tr&gt;}}&lt;!--
 Вверху3
--&gt;{{#if:{{{вверху3|}}}|&lt;tr&gt;&lt;td colspan="2" class="{{{класс_вверху3|}}}" style="text-align:center; {{{стиль_вверху3|}}}"&gt;{{{вверху3}}}&lt;/td&gt;&lt;/tr&gt;}}&lt;!--
 Изображение
--&gt;{{#if:{{{изображение|}}}|&lt;tr&gt;&lt;td colspan="2" class="infobox-image {{{класс_изображения|}}}" style="{{{стиль_изображения|}}}"&gt; {{{изображение}}} {{#if:{{{подпись|}}}|
&lt;div class="media-caption" style="{{{стиль_подписи|}}}"&gt;{{{подпись}}}&lt;/div&gt;}}&lt;/td&gt;&lt;/tr&gt;}}&lt;!--
 Изображение2
--&gt;{{#if:{{{изображение2|}}}|&lt;tr&gt;&lt;td colspan="2" class="infobox-image {{{класс_изображения2|}}}" style="{{{стиль_изображения2|}}}"&gt; {{{изображение2}}} {{#if:{{{подпись2|}}}|
&lt;div class="media-caption" style="{{{стиль_подписи2|}}}"&gt;{{{подпись2}}}&lt;/div&gt;}}&lt;/td&gt;&lt;/tr&gt;}}&lt;!--
 Изображение3
--&gt;{{#if:{{{изображение3|}}}|&lt;tr&gt;&lt;td colspan="2" class="infobox-image {{{класс_изображения3|}}}" style="{{{стиль_изображения3|}}}"&gt; {{{изображение3}}} {{#if:{{{подпись3|}}}|
&lt;div class="media-caption" style="{{{стиль_подписи3|}}}"&gt;{{{подпись3}}}&lt;/div&gt;}}&lt;/td&gt;&lt;/tr&gt;}}&lt;!-- 
 Строки
--&gt;{{#invoke:Infobox|renderLines}}&lt;!--
 Внизу
--&gt;{{Карточка/внизу|
стиль_внизу_общий={{{стиль_внизу|}}}|
класс_внизу={{{класс_внизу|}}}|
внизу={{{внизу|}}}}}&lt;!--
 Внизу N
--&gt;{{#invoke:Transclude|npc|Карточка/внизу|
стиль_внизу_общий={{{стиль_внизу|}}}|
стиль_внизу=|
класс_внизу=|
внизу=}}
&lt;/table&gt;&lt;includeonly&gt;&lt;!--
  статьи
--&gt;{{#if:{{NAMESPACE}}||&lt;!--
--&gt;{{#if:{{{имя|}}}||[[Категория:Статьи с шаблонами-карточками без имени]]}}&lt;!--
--&gt;{{#ifeq:{{{имя|}}}|{{subst:PAGENAME}}|[[Категория:Статьи с шаблонами-карточками без имени]]}}&lt;!--
--&gt;}}&lt;!--
  шаблоны
--&gt;{{#ifeq:{{NAMESPACENUMBER}}|10|&lt;!--
--&gt;{{#if:{{{имя|}}}||[[Категория:Шаблоны-карточки без имени]]}}&lt;!--
--&gt;{{#ifeq:{{{имя|}}}|{{subst:PAGENAME}}|[[Категория:Шаблоны-карточки без имени]]}}&lt;!--
--&gt;{{#if:{{{название|}}}{{{стиль_названия|}}}|[[Категория:Шаблоны с использованием параметра «название» в шаблоне «Карточка»]]}}&lt;!--
--&gt;{{#if:{{{подпись|}}}{{{стиль_подписи|}}}{{{подпись2|}}}{{{стиль_подписи2|}}}{{{подпись3|}}}{{{стиль_подписи3|}}}|[[Категория:Шаблоны с использованием параметра «подпись» в шаблоне «Карточка»]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_тела|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_названия|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_вверху|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_вверху2|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_вверху3|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_подписи|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_подписи2|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_подписи3|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_заголовков|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_меток|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_текста|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifexpr:{{#invoke:Color_contrast|styleratio|{{{стиль_внизу|}}}}} &lt; 4.5|[[Категория:Потенциально нечитаемые карточки]]}}&lt;!--
--&gt;{{#ifeq:{{{имя|}}}|{{PAGENAME}}|&lt;!--
  --&gt;[[Категория:Шаблоны-карточки по алфавиту|{{ucfirst:{{без начала|{{PAGENAME}}|Карточка }}}}]]&lt;!--
  --&gt;{{#if:{{{стиль_тела|}}}{{{стиль_вверху|}}}{{{стиль_заголовков|}}}{{{стиль_внизу|}}}|[[Категория:Википедия:Шаблоны-карточки с явным указанием стилей]]}}&lt;!--
--&gt;}}&lt;!--
--&gt;}}&lt;!--
  любое пространство имён
--&gt;{{#if:{{{название|}}}{{{стиль_названия|}}}|[[Категория:Википедия:Страницы с использованием параметра «название» в шаблоне «Карточка»]]}}&lt;!--
--&gt;{{#if:{{{подпись|}}}{{{стиль_подписи|}}}{{{подпись2|}}}{{{стиль_подписи2|}}}{{{подпись3|}}}{{{стиль_подписи3|}}}|[[Категория:Википедия:Страницы с использованием параметра «подпись» в шаблоне «Карточка»]]}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>aq3pllw0q9yjw331a9u7sok94vru6iu</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/название</title>
    <ns>10</ns>
    <id>6688227</id>
    <revision>
      <id>86856487</id>
      <parentid>82243315</parentid>
      <timestamp>2017-08-01T19:26:37Z</timestamp>
      <contributor>
        <username>Q-bit array</username>
        <id>1413071</id>
      </contributor>
      <minor/>
      <comment>Защитил «[[Шаблон:Карточка/название]]»: критический шаблон ([Редактирование=только администраторы] (бессрочно) [Переименование=только адм…</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="99" xml:space="preserve">{{#if:{{{1|}}}|{{{1}}}|{{без уточнения|{{PAGENAME}}}}}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>1zqddimm404itxmtrf1jxp5xpip8w5m</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Yesno</title>
    <ns>10</ns>
    <id>6638786</id>
    <revision>
      <id>86856572</id>
      <parentid>84347380</parentid>
      <timestamp>2017-08-01T19:30:50Z</timestamp>
      <contributor>
        <username>Q-bit array</username>
        <id>1413071</id>
      </contributor>
      <minor/>
      <comment>Защитил «[[Шаблон:Yesno]]»: критический шаблон ([Редактирование=только администраторы] (бессрочно) [Переименование=только администраторы] (бе…</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="371" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#switch: {{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;lc: {{{1|¬}}} }}
 |no
 |n
 |нет
 |false
 |0        = {{{no|&lt;!-- null --&gt;}}}
 |         = {{{blank|{{{no|&lt;!-- null --&gt;}}}}}}
 |¬        = {{{¬|}}}
 |yes
 |y
 |да
 |true
 |1        = {{{yes|yes}}}
 |#default = {{{def|{{{yes|yes}}}}}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>94l57a9asxh7lz5rcijsziv1t7ipccz</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Без уточнения</title>
    <ns>10</ns>
    <id>4776229</id>
    <revision>
      <id>84228049</id>
      <parentid>68916608</parentid>
      <timestamp>2017-03-12T19:54:44Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <comment>бoлee кoppeктный пaттepн; нaпpимep, в «Haзвaниe (нeyтoчнeниe) (yтoчнeниe)» yтoчнeниeм дoлжнa cчитaтьcя тoлькo пocлeдняя чacть. вoзмoжнocть иcпол. бeз 1-гo пap. и пoдcтaн.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="170" xml:space="preserve">&lt;includeonly&gt;{{ {{{|safesubst:}}}#invoke:String|replace|{{{1|{{ {{{|safesubst:}}}PAGENAME}}}}}|^%s*(.+)%s+%b()%s*$|%1||false}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>3pp71e6q6l13cymv2w30kcnrkqze3k0</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Wikidata</title>
    <ns>10</ns>
    <id>4448632</id>
    <revision>
      <id>113336664</id>
      <parentid>113335146</parentid>
      <timestamp>2021-04-01T12:24:50Z</timestamp>
      <contributor>
        <username>MBH</username>
        <id>529055</id>
      </contributor>
      <minor/>
      <comment>[[ВП:Откат|откат]] правок [[Special:Contribs/Lê Lợi (bot)|Lê Lợi (bot)]] ([[UT:Lê Lợi (bot)|обс.]]) к версии Wikisaurus</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="125" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Wikidata|formatProperty|property={{{1|}}}|value={{{2|}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>id80wbqj1q15y3qeo0hhisdwmkzsu4e</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Wikidata number switch</title>
    <ns>10</ns>
    <id>7928796</id>
    <revision>
      <id>108145433</id>
      <parentid>101966426</parentid>
      <timestamp>2020-07-12T09:21:12Z</timestamp>
      <contributor>
        <username>Serhio Magpie</username>
        <id>144541</id>
      </contributor>
      <comment>Проверка - если ничего нет из первых трёх параметров, ничего и не выводить</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="413" xml:space="preserve">{{#if: {{{3|}}}
| {{#if: {{{5|}}} | {{{5|}}} | {{{3|}}} }}
| {{#if: {{{2|}}}
  | {{#if: {{{4|}}} | {{{4|}}} | {{{2|}}} }}
  | {{#if: {{{1|}}}
    | {{#if: {{{4|}}}{{{5|}}}
      | {{#if: {{wikidata|{{{1|}}}|property-module=Wikidata/count|property-function=isMultiple|from={{{from|}}}}} | {{{5|}}} | {{{4|}}} }}
      | {{wikidata|{{{1|}}}|from={{{from|}}}}}
      }}
    }}
  }}
}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>dp36h28lqtj4r4ee1ak4aimumg0yicm</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/Викисклад</title>
    <ns>10</ns>
    <id>4082132</id>
    <revision>
      <id>121968537</id>
      <parentid>116442022</parentid>
      <timestamp>2022-04-30T14:39:04Z</timestamp>
      <contributor>
        <username>ShinePhantom</username>
        <id>46702</id>
      </contributor>
      <comment>еще одна проверочная категория для зачистки</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1226" xml:space="preserve">{{wikidata|p373|{{str rep|{{str rep|{{{1|}}}|Category:|}}|category:|}}|plain=false|text=Медиафайлы на Викискладе|icon={{{icon|}}}|icon_size={{{icon_size|}}}|from={{{from|}}}}}&lt;!--
--&gt;{{#if: {{{nocat|}}}{{NAMESPACE}} || &lt;!--
--&gt;{{#if: {{{1|}}} | [[Категория:Википедия:Ссылка на Викисклад непосредственно в статье]]&lt;!--
--&gt;{{#if: {{wikidata|p373|plain=true}}
    | {{#ifeq: {{str rep|{{str rep|{{{1|}}}|Category:|}}|category:|}} | {{wikidata|p373|plain=true}} |[[Категория:Википедия:Ссылки на Викисклад в статье и на Викиданных совпадают]]| [[Категория:Википедия:Ссылки на Викисклад в статье и на Викиданных отличаются]] }}
    | [[Категория:Википедия:Ссылка на Викисклад в статье, но не на Викиданных]]
    }} }}&lt;!--
--&gt; }}&lt;!--
--&gt;{{#ifeq: {{NAMESPACE}} | Шаблон | {{#if: {{{2|}}} | [[Категория:Википедия:Шаблоны для низа карточек с лишним параметром]] }} }}&lt;!--
--&gt;&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>7l2h3lr5t3bav7g2yx8645gdtd2pzcu</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Str rep</title>
    <ns>10</ns>
    <id>2965725</id>
    <revision>
      <id>68916551</id>
      <parentid>62716049</parentid>
      <timestamp>2015-02-28T09:38:11Z</timestamp>
      <contributor>
        <username>Rubinbot II</username>
        <id>459328</id>
      </contributor>
      <minor/>
      <comment>Защищена Шаблон:Str rep: Top used templates to be protected ([Редактирование=только администраторы] (бессрочно) [Переименование=только администраторы] (бессро</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="141" xml:space="preserve">&lt;includeonly&gt;{{{{{|safesubst:}}}#invoke:String|replace|source={{{1}}}|{{{2}}}|{{{3}}}|{{{4|1}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>na5hnfabkq8tesrxmvoxnsj4dw77ugq</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/внизу</title>
    <ns>10</ns>
    <id>6726667</id>
    <revision>
      <id>103315151</id>
      <parentid>100598805</parentid>
      <timestamp>2019-11-13T23:18:52Z</timestamp>
      <contributor>
        <username>Serhio Magpie</username>
        <id>144541</id>
      </contributor>
      <minor/>
      <comment>Перенесено в общие стили</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="260" xml:space="preserve">&lt;includeonly&gt;{{#if:{{{внизу|}}}|&lt;tr&gt;&lt;td colspan="2" class="infobox-below {{{класс_внизу|}}}" style="{{{стиль_внизу_общий|}}};{{{стиль_внизу|}}}"&gt;{{{внизу|}}}&lt;/td&gt;&lt;/tr&gt;}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>2n4yi2r414u9k8js75ji5uuxdal0lfz</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:String</title>
    <ns>828</ns>
    <id>4426162</id>
    <revision>
      <id>114034271</id>
      <parentid>113621422</parentid>
      <timestamp>2021-05-06T07:16:24Z</timestamp>
      <contributor>
        <username>Alexei Kopylov</username>
        <id>26580</id>
      </contributor>
      <minor/>
      <comment>[[ВП:Откат|откат]] правок [[Special:Contribs/Alexei Kopylov|Alexei Kopylov]] ([[UT:Alexei Kopylov|обс.]]) к версии DonRumata</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="18536" xml:space="preserve">--[[  

This module is intended to provide access to basic string functions.

Most of the functions provided here can be invoked with named parameters, 
unnamed parameters, or a mixture.  If named parameters are used, Mediawiki will 
automatically remove any leading or trailing whitespace from the parameter.  
Depending on the intended use, it may be advantageous to either preserve or
remove such whitespace.

Global options
    ignore_errors: If set to 'true' or 1, any error condition will result in 
        an empty string being returned rather than an error message.  
        
    error_category: If an error occurs, specifies the name of a category to 
        include with the error message.  The default category is  
        [Category:Errors reported by Module String].
        
    no_category: If set to 'true' or 1, no category will be added if an error
        is generated.
        
Unit tests for this module are available at Module:String/tests.
]]

local str = {}

--[[
subcount

This function returns the count of substring in source string.

Usage:
{{#invoke:String|subcount|source_string|substring|plain_flag}}
OR
{{#invoke:String|subcount|s=source_string|pattern=substring|plain=plain_flag}}

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    plain: A flag indicating that the substring should be understood as plain
        text. Defaults to true.

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.  
]]
function str.subcount( frame )
    local new_args = str._getParameters( frame.args, {'s', 'pattern', 'plain'} );
    local s = new_args['s'] or '';
    local plain_flag = str._getBoolean( new_args['plain'] or true );
    local pattern = new_args['pattern'] or '';
    if s == '' or pattern == '' then
    	return 0;
    end
    	
    if plain_flag then
        pattern = str._escapePattern( pattern );
    end
    
    local _, count = mw.ustring.gsub(s, pattern, "")
    return count;
end

--[[
len

This function returns the length of the target string.

Usage:
{{#invoke:String|len|target_string|}}
OR
{{#invoke:String|len|s=target_string}}

Parameters
    s: The string whose length to report

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.  
]]
function str.len( frame )
    local new_args = str._getParameters( frame.args, {'s'} );
    local s = new_args['s'] or '';
    return mw.ustring.len( s )
end

--[[
sub

This function returns a substring of the target string at specified indices.

Usage:
{{#invoke:String|sub|target_string|start_index|end_index}}
OR
{{#invoke:String|sub|s=target_string|i=start_index|j=end_index}}

Parameters
    s: The string to return a subset of
    i: The fist index of the substring to return, defaults to 1.
    j: The last index of the string to return, defaults to the last character.
    
The first character of the string is assigned an index of 1.  If either i or j
is a negative value, it is interpreted the same as selecting a character by 
counting from the end of the string.  Hence, a value of -1 is the same as 
selecting the last character of the string.

If the requested indices are out of range for the given string, an error is 
reported.
]]
function str.sub( frame )
    local new_args = str._getParameters( frame.args, { 's', 'i', 'j' } );
    local s = new_args['s'] or '';
    local i = tonumber( new_args['i'] ) or 1;
    local j = tonumber( new_args['j'] ) or -1;
    
    local len = mw.ustring.len( s );

    -- Convert negatives for range checking
    if i &lt; 0 then
        i = len + i + 1;
    end
    if j &lt; 0 then
        j = len + j + 1;
    end
    
    if i &gt; len or j &gt; len or i &lt; 1 or j &lt; 1 then
        return str._error( 'Значение индекса подстроки выходит за допустимые границы' );
    end
    if j &lt; i then
        return str._error( 'Неверный порядок индексов подстроки' );
    end
    
    return mw.ustring.sub( s, i, j )
end

--[[
This function implements that features of {{str sub old}} and is kept in order
to maintain these older templates.
]]
function str.sublength( frame )
    local i = tonumber( frame.args.i ) or 0
    local len = tonumber( frame.args.len )
    return mw.ustring.sub( frame.args.s, i + 1, len and ( i + len ) )
end

--[[
match

This function returns a substring from the source string that matches a 
specified pattern.

Usage:
{{#invoke:String|match|source_string|pattern_string|start_index|match_number|plain_flag|nomatch_output}}
OR
{{#invoke:String|pos|s=source_string|pattern=pattern_string|start=start_index
    |match=match_number|plain=plain_flag|nomatch=nomatch_output}}

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    start: The index within the source string to start the search.  The first
        character of the string has index 1.  Defaults to 1.
    match: In some cases it may be possible to make multiple matches on a single 
        string.  This specifies which match to return, where the first match is 
        match= 1.  If a negative number is specified then a match is returned 
        counting from the last match.  Hence match = -1 is the same as requesting
        the last match.  Defaults to 1.
    plain: A flag indicating that the pattern should be understood as plain
        text.  Defaults to false.
    nomatch: If no match is found, output the "nomatch" value rather than an error.

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from each string.  In some circumstances this is desirable, in 
other cases one may want to preserve the whitespace.

If the match_number or start_index are out of range for the string being queried, then
this function generates an error.  An error is also generated if no match is found.
If one adds the parameter ignore_errors=true, then the error will be suppressed and 
an empty string will be returned on any failure.

For information on constructing Lua patterns, a form of [regular expression], see:

* http://www.lua.org/manual/5.1/manual.html#5.4.1
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns

]]
function str.match( frame )
    local new_args = str._getParameters( frame.args, {'s', 'pattern', 'start', 'match', 'plain', 'nomatch'} );
    local s = new_args['s'] or '';
    local start = tonumber( new_args['start'] ) or 1;
    local plain_flag = str._getBoolean( new_args['plain'] or false );
    local pattern = new_args['pattern'] or '';
    local match_index = math.floor( tonumber(new_args['match']) or 1 );
    local nomatch = new_args['nomatch'];
    
    if s == '' then
        return str._error( 'Пустая строка поиска' );
    end
    if pattern == '' then
        return str._error( 'Пустой шаблон поиска' );
    end
    if math.abs(start) &lt; 1 or math.abs(start) &gt; mw.ustring.len( s ) then
        return str._error( 'Индекс начала поиска выходит за допустимые границы' );
    end
    if match_index == 0 then
        return str._error( 'Индекс совпадения выходит за допустимые границы' );
    end
    if plain_flag then
        pattern = str._escapePattern( pattern );
    end
    
    local result
    if match_index == 1 then
        -- Find first match is simple case
        result = mw.ustring.match( s, pattern, start )
    else
        if start &gt; 1 then
            s = mw.ustring.sub( s, start );
        end
        
        local iterator = mw.ustring.gmatch(s, pattern);
        if match_index &gt; 0 then
            -- Forward search
            for w in iterator do
                match_index = match_index - 1;
                if match_index == 0 then
                    result = w;
                    break;
                end
            end    
        else
            -- Reverse search
            local result_table = {};
            local count = 1;
            for w in iterator do
                result_table[count] = w;
                count = count + 1;
            end
            
            result = result_table[ count + match_index ];            
        end
    end        
    
    if result == nil then
        if nomatch == nil then
            return str._error( 'Совпадение не найдено' );
        else
            return nomatch;
        end
    else
        return result;
    end
end

--[[
pos

This function returns a single character from the target string at position pos.

Usage:
{{#invoke:String|pos|target_string|index_value}}
OR
{{#invoke:String|pos|target=target_string|pos=index_value}}

Parameters
    target: The string to search
    pos: The index for the character to return

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.  In some circumstances this is desirable, in 
other cases one may want to preserve the whitespace.

The first character has an index value of 1.

If one requests a negative value, this function will select a character by counting backwards 
from the end of the string.  In other words pos = -1 is the same as asking for the last character.

A requested value of zero, or a value greater than the length of the string returns an error.
]]
function str.pos( frame )
    local new_args = str._getParameters( frame.args, {'target', 'pos'} );
    local target_str = new_args['target'] or '';
    local pos = tonumber( new_args['pos'] ) or 0;

    if pos == 0 or math.abs(pos) &gt; mw.ustring.len( target_str ) then
        return str._error( 'Значение индекса строки выходит за допустимые границы' );
    end    
    
    return mw.ustring.sub( target_str, pos, pos );
end

--[[
str_find

This function duplicates the behavior of {{str_find}}, including all of its quirks.
This is provided in order to support existing templates, but is NOT RECOMMENDED for 
new code and templates.  New code is recommended to use the "find" function instead.

Returns the first index in "source" that is a match to "target".  Indexing is 1-based,
and the function returns -1 if the "target" string is not present in "source".

Important Note: If the "target" string is empty / missing, this function returns a
value of "1", which is generally unexpected behavior, and must be accounted for
separatetly.
]]
function str.str_find( frame )
    local new_args = str._getParameters( frame.args, {'source', 'target'} );
    local source_str = new_args['source'] or '';
    local target_str = new_args['target'] or '';

    if target_str == '' then
        return 1;
    end    
    
    local start = mw.ustring.find( source_str, target_str, 1, true )
    if start == nil then
        start = -1
    end
    
    return start
end

--[[
find

This function allows one to search for a target string or pattern within another
string.

Usage:
{{#invoke:String|find|source_str|target_string|start_index|plain_flag}}
OR
{{#invoke:String|find|source=source_str|target=target_str|start=start_index|plain=plain_flag}}

Parameters
    source: The string to search
    target: The string or pattern to find within source
    start: The index within the source string to start the search, defaults to 1
    plain: Boolean flag indicating that target should be understood as plain
        text and not as a Lua style regular expression, defaults to true

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the parameter.  In some circumstances this is desirable, in 
other cases one may want to preserve the whitespace.

This function returns the first index &gt;= "start" where "target" can be found 
within "source".  Indices are 1-based.  If "target" is not found, then this 
function returns 0.  If either "source" or "target" are missing / empty, this
function also returns 0.

This function should be safe for UTF-8 strings.
]]
function str.find( frame )
    local new_args = str._getParameters( frame.args, {'source', 'target', 'start', 'plain' } ); 
    local source_str = new_args['source'] or '';
    local pattern = new_args['target'] or '';
    local start_pos = tonumber(new_args['start']) or 1;
    local plain = new_args['plain'] or true;
        
    if source_str == '' or pattern == '' then
        return 0;
    end    
    
    plain = str._getBoolean( plain );

    local start = mw.ustring.find( source_str, pattern, start_pos, plain )
    if start == nil then
        start = 0
    end
    
    return start
end

--[[
replace

This function allows one to replace a target string or pattern within another
string.

Usage:
{{#invoke:String|replace|source_str|pattern_string|replace_string|replacement_count|plain_flag}}
OR
{{#invoke:String|replace|source=source_string|pattern=pattern_string|replace=replace_string|
   count=replacement_count|plain=plain_flag}}

Parameters
    source: The string to search
    pattern: The string or pattern to find within source
    replace: The replacement text
    count: The number of occurences to replace, defaults to all.
    plain: Boolean flag indicating that pattern should be understood as plain
        text and not as a Lua style regular expression, defaults to true 
]]
function str.replace( frame )
    local new_args = str._getParameters( frame.args, {'source', 'pattern', 'replace', 'count', 'plain' } ); 
    local source_str = new_args['source'] or '';
    local pattern = new_args['pattern'] or '';
    local replace = new_args['replace'] or '';
    local count = tonumber( new_args['count'] );
    local plain = new_args['plain'] or true;
        
    if source_str == '' or pattern == '' then
        return source_str;
    end    
    plain = str._getBoolean( plain );

    if plain then
        pattern = str._escapePattern( pattern );
        replace = mw.ustring.gsub( replace, "%%", "%%%%" ); --Only need to escape replacement sequences.
    end
    
    local result;

    if count ~= nil then
        result = mw.ustring.gsub( source_str, pattern, replace, count );
    else
        result = mw.ustring.gsub( source_str, pattern, replace );
    end        

    return result;
end

--[[
This function adds support for escaping parts of the patterns when using [plain=false].
]]
function str.escape( frame )
	local new_args = str._getParameters( frame.args, {'pattern' } );
	local pattern = new_args['pattern'] or '';
	
	local result = '';
	result = str._escapePattern( pattern );
	return result;
end

--[[
  Internal compare string function
]]
function str._strcmp(a , b)
    local s1c = mw.ustring.gcodepoint( a );
    local s2c = mw.ustring.gcodepoint( b );
    while true do
        local c1 = s1c();
        local c2 = s2c();
        if c1 == nil then
            if c2 == nil then
                return 0
            else
                return -1
            end
        else
            if c2 ~= nil then
                if c1 ~= c2 then
                  return c1 &lt; c2 and -1 or 1
              end
            else
                return 1
            end
        end
    end
    return 0
end
 
--[[
compare

This function compare two UTF-8 strings

Usage:
{{#invoke:String|compare|str1|str2}}

Returns:
 0 - if strings are equal
 1 - if st1 &gt; str2
-1 - if str1 &lt; str2
]]
function str.compare(frame)
    local str1 = frame.args[1] or '';
    local str2 = frame.args[2] or '';
    return str._strcmp(str1 , str2)
end

--[[ 
    simple function to pipe string.rep to templates.
]]
 
function str.rep( frame )
    local repetitions = tonumber( frame.args[2] )
    if not repetitions then 
        return str._error( 'функция rep ожидает число  во втором параметре, а получено "' .. ( frame.args[2] or '' ) .. '"' )
    end
    return string.rep( frame.args[1] or '', repetitions )
end

--[[
Helper function that populates the argument list given that user may need to use a mix of
named and unnamed parameters.  This is relevant because named parameters are not
identical to unnamed parameters due to string trimming, and when dealing with strings
we sometimes want to either preserve or remove that whitespace depending on the application.
]]
function str._getParameters( frame_args, arg_list )
    local new_args = {};
    local index = 1;
    local value;
    
    for i,arg in ipairs( arg_list ) do
        value = frame_args[arg]
        if value == nil then
            value = frame_args[index];
            index = index + 1;
        end
        new_args[arg] = value;
    end
    
    return new_args;
end        

--[[
Helper function to handle error messages.
]]
function str._error( error_str )
    local frame = mw.getCurrentFrame();
    local error_category = frame.args.error_category or 'Страницы с ошибками модуля String';
    local ignore_errors = frame.args.ignore_errors or false;
    local no_category = frame.args.no_category or false;
    
    if str._getBoolean(ignore_errors) then
        return '';
    end
    
    local error_str = '&lt;strong class="error"&gt;Ошибка модуля String: ' .. error_str .. '&lt;/strong&gt;';
    if error_category ~= '' and not str._getBoolean( no_category ) then
        error_str = '[[Категория:' .. error_category .. ']]' .. error_str;
    end        
    
    return error_str;
end

--[[
Helper Function to interpret boolean strings
]]
function str._getBoolean( boolean_str )
    local boolean_value;
    
    if type( boolean_str ) == 'string' then
        boolean_str = boolean_str:lower();
        if boolean_str == 'false' or boolean_str == 'no' or boolean_str == '0' 
                or boolean_str == '' then
            boolean_value = false;
        else
            boolean_value = true;
        end    
    elseif type( boolean_str ) == 'boolean' then
        boolean_value = boolean_str;
    else
        error( 'Логическое значение не найдено' );
    end    
    return boolean_value
end

--[[
Helper function that escapes all pattern characters so that they will be treated 
as plain text.
]]
function str._escapePattern( pattern_str )
    return mw.ustring.gsub( pattern_str, "([%(%)%.%%%+%-%*%?%[%^%$%]])", "%%%1" );
end

return str</text>
      <sha1>l3n7gxkh8xe7345uplf64qy76r1qkzv</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Wikidata</title>
    <ns>828</ns>
    <id>4494635</id>
    <revision>
      <id>133902720</id>
      <parentid>133209639</parentid>
      <timestamp>2023-10-31T01:59:03Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>проверка свойства [[d:Property:P282|письменность]] у всех меток, а не только у единиц измерения</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="65947" xml:space="preserve">---settings, may differ from project to project
local fileDefaultSize = '267x400px'
local outputReferences = true
local writingSystemElementId = 'Q8209'
local langElementId = 'Q7737'

---Ссылки на используемые модули, которые потребуются в 99% случаев загрузки страниц (чтобы иметь на виду при переименовании)
local moduleSources = require( 'Module:Sources' )
local WDS = require( 'Module:WikidataSelectors' )

---Константы
---@type string
local CONTENT_LANGUAGE_CODE = mw.language.getContentLanguage():getCode()

local p = {}
local g_config, g_frame
local formatDatavalue, formatEntityId, formatRefs, formatSnak, formatStatement,
formatStatementDefault, getSourcingCircumstances, getPropertyParams

---@param obj table
---@param target table
---@param skipEmpty boolean | nil
---@return table
local function copyTo( obj, target, skipEmpty )
    for key, val in pairs( obj ) do
        if skipEmpty ~= true or ( val ~= nil and val ~= '' ) then
            target[ key ] = val
        end
    end
    return target
end

---@param prev number | nil
---@param next number | nil
---@return number | nil
local function min( prev, next )
    if prev == nil or prev &gt; next then
        return next
    end
    return prev
end

---@param prev number | nil
---@param next number | nil
---@return number | nil
local function max( prev, next )
    if prev == nil or prev &lt; next then
        return next
    end
    return prev
end

---@param section string
---@param code string
---@return any | nil
local function getConfig( section, code )
    if g_config == nil then
        g_config = require( 'Module:Wikidata/config' )
    end
    if not g_config then
        g_config = {}
    end

    if not section then
        return g_config
    end
    if not code then
        return g_config[ section ] or {}
    end

    if not g_config[ section ] then
        return nil
    end
    return g_config[ section ][ code ]
end

---@param code string
---@param sortKey string | nil
---@return string
local function getCategoryByCode( code, sortKey )
    local value = getConfig( 'categories', code )
    if not value or value == '' then
        return ''
    end

    if sortKey ~= nil then
        return '[[Category:' .. value .. '|' .. sortKey .. ']]'; -- экранировать?
    else
        return '[[Category:' .. value .. ']]'
    end
end

---@param isoStr string | table
---@return table | nil
local function splitISO8601( isoStr )
    if 'table' == type( isoStr ) then
        if isoStr.args and isoStr.args[ 1 ] then
            isoStr = '' .. isoStr.args[ 1 ]
        else
            return 'unknown argument type: ' .. type( isoStr ) .. ': ' .. table.tostring( isoStr )
        end
    end
    local Y, M, D = ( function( str )
        local pattern = "(%-?%d+)%-(%d+)%-(%d+)T"
        local _Y, _M, _D = mw.ustring.match( str, pattern )
        return tonumber( _Y ), tonumber( _M ), tonumber( _D )
    end )( isoStr )
    local h, m, s = ( function( str )
        local pattern = "T(%d+):(%d+):(%d+)%Z"
        local _H, _M, _S = mw.ustring.match( str, pattern )
        return tonumber( _H ), tonumber( _M ), tonumber( _S )
    end )( isoStr )
    local oh, om = ( function( str )
        if str:sub(-1) == "Z" then  -- ends with Z, Zulu time
            return 0, 0
        end
        -- matches ±hh:mm, ±hhmm or ±hh; else returns nils
        local pattern = "([-+])(%d%d):?(%d?%d?)$"
        local sign, oh, om = mw.ustring.match( str, pattern )
        sign, oh, om = sign or "+", oh or "00", om or "00"
        return tonumber( sign .. oh ), tonumber( sign .. om )
    end )( isoStr )
    return { year=Y, month=M, day=D, hour=( h + oh ), min=( m + om ), sec=s }
end

---@param time string
---@param precision number
---@return table | nil
local function parseTimeBoundaries( time, precision )
    local s = splitISO8601( time )
    if not s then
        return nil
    end

    if precision &gt;= 0 and precision &lt;= 8 then
        local powers = { 1000000000 , 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10 }
        local power = powers[ precision + 1 ]
        local left = s.year - ( s.year % power )
        return { tonumber( os.time( { year=left, month=1, day=1, hour=0, min=0, sec=0 } ) ) * 1000,
                 tonumber( os.time( { year=left + power - 1, month=12, day=31, hour=29, min=59, sec=58 } ) ) * 1000 + 1999 }
    end

    if precision == 9 then
        return { tonumber( os.time( { year=s.year, month=1, day=1, hour=0, min=0, sec=0} )) * 1000,
                 tonumber( os.time( { year=s.year, month=12, day=31, hour=23, min=59, sec=58} )) * 1000 + 1999 }
    end

    if precision == 10 then
        local lastDays = { 31, 28.25, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
        local lastDay = lastDays[ s.month ]
        return { tonumber( os.time( { year=s.year, month=s.month, day=1, hour=0, min=0, sec=0 } ) ) * 1000,
                 tonumber( os.time( { year=s.year, month=s.month, day=lastDay, hour=23, min=59, sec=58 } ) ) * 1000 + 1999 }
    end

    if precision == 11 then
        return { tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=0, min=0, sec=0 } ) ) * 1000,
                 tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=23, min=59, sec=58 } ) ) * 1000 + 1999 }
    end

    if precision == 12 then
        return { tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=s.hour, min=0, sec=0 } ) ) * 1000,
                 tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=s.hour, min=59, sec=58 } ) ) * 1000 + 1999 }
    end

    if precision == 13 then
        return { tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=s.hour, min=s.min, sec=0 } ) ) * 1000,
                 tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=s.hour, min=s.min, sec=58 } ) ) * 1000 + 1999 }
    end

    if precision == 14 then
        local t = tonumber( os.time( { year=s.year, month=s.month, day=s.day, hour=s.hour, min=s.min, sec=0 } ) )
        return { t * 1000, t * 1000 + 999 }
    end

    error( 'Unsupported precision: ' .. precision )
end

---Функция для формирования категории на основе wikidata/config
---@param options table
---@param entityId string
---@return string
local function extractCategory( options, entityId )
    if not entityId or not options.category or options.nocat then
        return ''
    end
    if type( entityId ) ~= 'string' then
        entityId = entityId.id
    end
    local claims = WDS.load( entityId, options.category )
    if not claims then
        return ''
    end

    for _, claim in pairs( claims ) do
        if claim
                and claim.mainsnak
                and claim.mainsnak.datavalue
                and claim.mainsnak.datavalue.type == 'wikibase-entityid'
        then
            local catEntityId = claim.mainsnak.datavalue.value.id
            local wbStatus, catSiteLink = pcall( mw.wikibase.getSitelink, catEntityId )

            if wbStatus and catSiteLink then
                return '[[' .. catSiteLink .. ']]'
            end
        end
    end

    return ''
end

---Преобразует строку в булевое значение
---@param valueToParse string
---@return boolean Преобразованное значение, если его удалось распознать, или defaultValue во всех остальных случаях
local function toBoolean( valueToParse, defaultValue )
    if valueToParse ~= nil then
        if valueToParse == false or valueToParse == '' or valueToParse == 'false' or valueToParse == '0' then
            return false
        end
        return true
    end
    return defaultValue
end

---Обрачивает отформатированное значение в инлайновый или блочный тег.
---@param value string value
---@param attributes table of attributes
---@return string HTML tag with value
local function wrapValue( value, attributes )
    local tagName = 'span'
    local spacer = ''
    if string.match( value, '\n' )
            or string.match( value, '&lt;t[dhr][ &gt;]' )
            or string.match( value, '&lt;div[ &gt;]' )
            or string.find( value, 'UNIQ%-%-imagemap' )
    then
        tagName = 'div'
        spacer = '\n'
    end
    local attrString = ''
    for key, val in pairs( attributes or {} ) do
        local _key = mw.text.trim( key )
        local _value = mw.text.encode( mw.text.trim( val ) )
        attrString = attrString .. _key .. '="' .. _value .. '" '
    end
    return '&lt;' .. tagName .. ' ' .. attrString .. '&gt;' .. spacer .. value .. '&lt;/' .. tagName .. '&gt;'
end

---Wraps formatted snak value into HTML tag with attributes.
---@param value string value of snak
---@param hash string
---@param attributes table of extra attributes
---@return string HTML tag with value
local function wrapSnak( value, hash, attributes )
    local newAttributes = mw.clone( attributes or {} )
    newAttributes[ 'class' ] = ( newAttributes[ 'class' ] or '' ) .. ' wikidata-snak'

    if hash then
        newAttributes[ 'data-wikidata-hash'] = hash
    else
        newAttributes[ 'class' ] = newAttributes[ 'class' ] .. ' wikidata-main-snak'
    end

    return wrapValue( value, newAttributes )
end

---Wraps formatted statement value into HTML tag with attributes.
---@param value string value of statement
---@param propertyId string PID of property
---@param claimId string ID of claim or nil for local value
---@param attributes table of extra attributes
---@return string HTML tag with value
local function wrapStatement( value, propertyId, claimId, attributes )
    local newAttributes = mw.clone( attributes or {} )
    newAttributes[ 'class' ] = newAttributes[ 'class' ] or ''
    newAttributes[ 'data-wikidata-property-id' ] = string.upper( propertyId )

    if claimId then
        newAttributes[ 'class' ] = newAttributes[ 'class' ] .. ' wikidata-claim'
        newAttributes[ 'data-wikidata-claim-id' ] = claimId
    else
        newAttributes[ 'class' ] = newAttributes[ 'class' ] .. ' no-wikidata'
    end

    return wrapValue( value, newAttributes )
end

---Wraps formatted qualifier's statement value into HTML tag with attributes.
---@param value string value of qualifier's statement
---@param qualifierId string PID of qualifier
---@param attributes table of extra attributes
---@return string HTML tag with value
local function wrapQualifier( value, qualifierId, attributes )
    local newAttributes = mw.clone( attributes or {} )
    newAttributes[ 'data-wikidata-qualifier-id' ] = string.upper( qualifierId )
    return wrapValue( value, newAttributes )
end

---Функция для получения сущности (еntity) для текущей страницы
---Подробнее о сущностях см. d:Wikidata:Glossary/ru
---@param id string Идентификатор (типа P18, Q42)
---@return table Таблица, элементы которой индексируются с нуля
local function getEntityFromId( id )
    local entity
    local wbStatus

    if id then
        wbStatus, entity = pcall( mw.wikibase.getEntity, id )
    else
        wbStatus, entity = pcall( mw.wikibase.getEntity )
    end

    return entity
end

---Внутренняя функция для формирования сообщения об ошибке
---@param key string Ключ элемента в таблице config.errors (например entity-not-found)
---@return void
local function throwError( key )
    error( getConfig( 'errors', key ) )
end

---Функция для получения идентификатора сущностей
---@param value table
---@return string
local function getEntityIdFromValue( value )
    local prefix = ''
    if value[ 'entity-type' ] == 'item' then
        prefix = 'Q'
    elseif value[ 'entity-type' ] == 'property' then
        prefix = 'P'
    else
        throwError( 'unknown-entity-type' )
    end
    return prefix .. value[ 'numeric-id' ]
end

---Проверка на наличие специализированной функции в опциях
---@param options table
---@param prefix string
---@return function
local function getUserFunction( options, prefix, defaultFunction )
    -- проверка на указание специализированных обработчиков в параметрах,
    -- переданных при вызове
    if options[ prefix .. '-module' ] or options[ prefix .. '-function' ] then
        -- проверка на пустые строки в параметрах или их отсутствие
        if not options[ prefix .. '-module' ] or not options[ prefix .. '-function' ] then
            throwError( 'unknown-' .. prefix .. '-module' )
        end
        -- динамическая загруза модуля с обработчиком указанным в параметре
        local formatter = require( 'Module:' .. options[ prefix .. '-module' ] )
        if formatter == nil then
            throwError( prefix .. '-module-not-found' )
        end
        local fun = formatter[ options[ prefix .. '-function' ] ]
        if fun == nil then
            throwError( prefix .. '-function-not-found' )
        end
        return fun
    end

    return defaultFunction
end

---Выбирает свойства по property id, дополнительно фильтруя их по рангу
---@param context table
---@param options table
---@param propertySelector string
---@return table | nil
local function selectClaims( context, options, propertySelector )
    if not context then error( 'context not specified' ); end
    if not options then error( 'options not specified' ); end
    if not options.entityId then error( 'options.entity is missing' ); end
    if not propertySelector then error( 'propertySelector not specified' ); end

    local result = WDS.load( options.entityId, propertySelector )

    if not result or #result == 0 then
        return nil
    end

    if options.limit and options.limit ~= '' and options.limit ~= '-'  then
        local limit = tonumber( options.limit, 10 )
        while #result &gt; limit do
            table.remove( result )
        end
    end

    return result
end

---Функция для получения значения свойства элемента в заданный момент времени.
---@param entityId string
---@param boundaries table Временные границы
---@param propertyIds table&lt;string&gt;
---@param selectors table&lt;string&gt;
---@return table Таблица соответствующих значений свойства
local function getPropertyInBoundaries( context, entityId, boundaries, propertyIds, selectors )
    if type( entityId ) ~= 'string' then error( 'type of entityId argument expected string, but was ' .. type(entityId)); end

    local results = {}

    if not propertyIds or #propertyIds == 0 then
        return results
    end

    for i, propertyId in ipairs( propertyIds ) do
        local selector
        if selectors ~= nil then
            selector = selectors[ i ] or selectors[ propertyId ] or propertyId
        else
            selector = propertyId
        end

        local fakeAllClaims = {}
        fakeAllClaims[ propertyId ] = mw.wikibase.getAllStatements( entityId, propertyId )

        local filteredClaims = WDS.filter( fakeAllClaims, selector .. '[rank:preferred, rank:normal]' )
        if filteredClaims then
            for _, claim in pairs( filteredClaims ) do
                if not boundaries then
                    table.insert( results, claim.mainsnak )
                else
                    local startBoundaries = p.getTimeBoundariesFromQualifier( context.frame, context, claim, 'P580' )
                    local endBoundaries = p.getTimeBoundariesFromQualifier( context.frame, context, claim, 'P582' )

                    if ( startBoundaries == nil or startBoundaries[ 1 ] &lt;= boundaries[ 1 ] ) and
                            ( endBoundaries == nil or endBoundaries[ 1 ] &gt;= boundaries[ 2 ] )
                    then
                        table.insert( results, claim.mainsnak )
                    end
                end
            end
        end

        if #results &gt; 0 then
            break
        end
    end

    return results
end

---@param context table
---@param statement table
---@param qualifierId string
---@return table | nil
function p.getTimeBoundariesFromQualifier( _, context, statement, qualifierId )
    -- only support exact date so far, but need improvement
    local left, right
    if statement.qualifiers and statement.qualifiers[ qualifierId ] then
        for _, qualifier in pairs( statement.qualifiers[ qualifierId ] ) do
            local boundaries = context.parseTimeBoundariesFromSnak( qualifier )
            if not boundaries then
                return nil
            end
            left = min( left, boundaries[ 1 ] )
            right = max( right, boundaries[ 2 ] )
        end
    end

    if not left or not right then
        return nil
    end

    return { left, right }
end

---@param frame table
---@param context table
---@param statement table
---@param qualifierIds table&lt;string&gt;
---@return table | nil
function p.getTimeBoundariesFromQualifiers( frame, context, statement, qualifierIds )
    if not qualifierIds then
        qualifierIds = { 'P582', 'P580', 'P585' }
    end

    for _, qualifierId in pairs( qualifierIds ) do
        local result = p.getTimeBoundariesFromQualifier( frame, context, statement, qualifierId )
        if result then
            return result
        end
    end

    return nil
end

---@type table&lt;string&gt;
local getLabelWithLang_DEFAULT_PROPERTIES = { 'P1813', 'P1448', 'P1705' }

---@type table&lt;string&gt;
local getLabelWithLang_DEFAULT_SELECTORS = {
    'P1813[language:' .. CONTENT_LANGUAGE_CODE .. '][!P282,P282:' .. writingSystemElementId .. '][!P3831,P3831:Q105690470]',
    'P1448[language:' .. CONTENT_LANGUAGE_CODE .. '][!P282,P282:' .. writingSystemElementId .. '][!P3831,P3831:Q105690470]',
    'P1705[language:' .. CONTENT_LANGUAGE_CODE .. '][!P282,P282:' .. writingSystemElementId .. '][!P3831,P3831:Q105690470]'
}

---Функция для получения метки элемента в заданный момент времени.
---@param context table
---@param options table
---@param entityId string
---@param boundaries table
---@param propertyIds table
---@param selectors table&lt;string&gt;
---@return string, string Текстовая метка элемента, язык метки
local function getLabelWithLang( context, options, entityId, boundaries, propertyIds, selectors )
    if type( entityId ) ~= 'string' then error( 'type of entityId argument expected string, but was ' .. type( entityId ) ); end
    if not entityId then
        return nil
    end

    local langCode = CONTENT_LANGUAGE_CODE

    -- name from label
    local label
    if options.text and options.text ~= '' then
        label = options.text
    else
        if not propertyIds then
            propertyIds = getLabelWithLang_DEFAULT_PROPERTIES
            selectors = getLabelWithLang_DEFAULT_SELECTORS
        end

        -- name from properties
        local results = getPropertyInBoundaries( context, entityId, boundaries, propertyIds, selectors )

        for _, result in pairs( results ) do
            if result.datavalue and result.datavalue.value then
                if result.datavalue.type == 'monolingualtext' and result.datavalue.value.text then
                    label = result.datavalue.value.text
                    langCode = result.datavalue.value.language
                    break
                elseif result.datavalue.type == 'string' then
                    label = result.datavalue.value
                    break
                end
            end
        end

        if not label then
            label, langCode = mw.wikibase.getLabelWithLang( entityId )
            if not langCode then
                return nil
            end
        end
    end

    return label, langCode
end

---@param context table
---@param options table
---@return string
local function formatPropertyDefault( context, options )
    if not context then error( 'context not specified' ); end
    if not options then error( 'options not specified' ); end
    if not options.entityId then error( 'options.entityId missing' ); end

    local claims
    if options.property then -- TODO: Почему тут может не быть property?
        if options.rank then -- передать настройки ранга из конфига
            claims = context.selectClaims( options, options.property .. options.rank )
        else
            claims = context.selectClaims( options, options.property )
        end
    end
    if claims == nil then
        return '' --TODO error?
    end

    -- Обход всех заявлений утверждения и с накоплением оформленных предпочтительных
    -- заявлений в таблице
    local formattedClaims = {}

    for _, claim in pairs( claims ) do
        local formattedStatement = context.formatStatement( options, claim )
        -- здесь может вернуться либо оформленный текст заявления, либо строка ошибки, либо nil
        if formattedStatement and formattedStatement ~= '' then
        	if not options.plain then
	            formattedStatement = context.wrapStatement( formattedStatement, options.property, claim.id )
            end
            table.insert( formattedClaims, formattedStatement )
        end
    end

    -- создание текстовой строки со списком оформленых заявлений из таблицы
    local out = mw.text.listToText( formattedClaims, options.separator, options.conjunction )
    if out ~= '' then
        if options.before then
            out = options.before .. out
        end
        if options.after then
            out = out .. options.after
        end
    end

    return out
end

---Create context
---@param initOptions table
---@return table | nil
local function initContext( initOptions )
    local context = {
        entityId = initOptions.entityId,
        entity = initOptions.entity,
        extractCategory = extractCategory,
        formatSnak = formatSnak,
        formatPropertyDefault = formatPropertyDefault,
        formatStatementDefault = formatStatementDefault,
        getPropertyInBoundaries = getPropertyInBoundaries,
        getTimeBoundariesFromQualifier = p.getTimeBoundariesFromQualifier,
        getTimeBoundariesFromQualifiers = p.getTimeBoundariesFromQualifiers,
        wrapSnak = wrapSnak,
        wrapStatement = wrapStatement,
        wrapQualifier = wrapQualifier,
    }
    context.cloneOptions = function( options )
        local entity = options.entity
        options.entity = nil

        local newOptions = mw.clone( options )
        options.entity = entity
        newOptions.entity = entity
        newOptions.frame = options.frame; -- На склонированном фрейме frame:expandTemplate()

        return newOptions
    end
    context.formatProperty = function( options )
        local func = getUserFunction( options, 'property', context.formatPropertyDefault )
        return func( context, options )
    end
    context.formatStatement = function( options, statement ) return formatStatement( context, options, statement ) end
    context.formatSnak = function( options, snak, circumstances ) return formatSnak( context, options, snak, circumstances ) end
    context.formatRefs = function( options, statement ) return formatRefs( context, options, statement ) end

    context.parseTimeFromSnak = function( snak )
        if snak and snak.datavalue and snak.datavalue.value and snak.datavalue.value.time then
            return tonumber( os.time( splitISO8601( tostring( snak.datavalue.value.time ) ) ) ) * 1000
        end
        return nil
    end
    context.parseTimeBoundariesFromSnak = function( snak )
        if snak and snak.datavalue and snak.datavalue.value and snak.datavalue.value.time and snak.datavalue.value.precision then
            return parseTimeBoundaries( snak.datavalue.value.time, snak.datavalue.value.precision )
        end
        return nil
    end
    context.getSourcingCircumstances = function( statement )
        return getSourcingCircumstances( statement )
    end
    context.selectClaims = function( options, propertyId )
        return selectClaims( context, options, propertyId )
    end

    return context
end

---Функция для оформления утверждений (statement)
---Подробнее о утверждениях см. d:Wikidata:Glossary/ru
---@param options table
---@return string Formatted wikitext.
local function formatProperty( options )
    -- Получение сущности по идентификатору
    local entity = getEntityFromId( options.entityId )
    if not entity then
        return -- throwError( 'entity-not-found' )
    end
    -- проверка на присутсвие у сущности заявлений (claim)
    -- подробнее о заявлениях см. d:Викиданные:Глоссарий
    if not entity.claims then
        return '' --TODO error?
    end

    -- improve options
    options.frame = g_frame
    options.entity = entity
    options.extends = function( self, newOptions )
        return copyTo( newOptions, copyTo( self, {} ) )
    end

    if options.i18n then
        options.i18n = copyTo( options.i18n, copyTo( getConfig( 'i18n' ), {} ) )
    else
        options.i18n = getConfig( 'i18n' )
    end

    local context = initContext( options )

    return context.formatProperty( options )
end

---Функция для оформления одного утверждения (statement)
---@param context table
---@param options table
---@param statement table
---@return string Formatted wikitext.
function formatStatement( context, options, statement )
    if not statement then
        error( 'statement is not specified or nil' )
    end
    if not statement.type or statement.type ~= 'statement' then
        throwError( 'unknown-claim-type' )
    end

    local functionToCall = getUserFunction( options, 'claim', context.formatStatementDefault )
    return functionToCall( context, options, statement )
end

---@param statement table
---@return table
function getSourcingCircumstances( statement )
    if not statement then
        error( 'statement is not specified' )
    end

    local circumstances = {}
    if statement.qualifiers and statement.qualifiers.P1480 then
        for _, qualifier in pairs( statement.qualifiers.P1480 ) do
            if qualifier
                    and qualifier.datavalue
                    and qualifier.datavalue.type == 'wikibase-entityid'
                    and qualifier.datavalue.value
                    and qualifier.datavalue.value[ 'entity-type'] == 'item'
            then
                table.insert( circumstances, qualifier.datavalue.value.id )
            end
        end
    end
    return circumstances
end

---Функция для оформления одного утверждения (statement)
---@param context table Context.
---@param options table Parameters.
---@param statement table
---@return string Formatted wikitext.
function formatStatementDefault( context, options, statement )
    if not context then error( 'context is not specified' ) end
    if not options then error( 'options is not specified' ) end
    if not statement then error( 'statement is not specified' ) end

    local circumstances = context.getSourcingCircumstances( statement )

    options.qualifiers = statement.qualifiers

    local result = context.formatSnak( options, statement.mainsnak, circumstances )

    if options.qualifier and statement.qualifiers and statement.qualifiers[ options.qualifier ] then
        local qualifierConfig = getPropertyParams( options.qualifier, nil, {} )
        if options.i18n then
            qualifierConfig.i18n = options.i18n
        end
        if qualifierConfig.datatype == 'time' then
            qualifierConfig.nolinks = true
        end
        local qualifierValues = {}
        for _, qualifierSnak in pairs( statement.qualifiers[ options.qualifier ] ) do
            local snakValue = context.formatSnak( qualifierConfig, qualifierSnak )
            if snakValue and snakValue ~= '' then
                table.insert( qualifierValues, snakValue )
            end
        end
        if result and result ~= '' and #qualifierValues then
            if qualifierConfig.invisible then
                result = result .. table.concat( qualifierValues, ', ' )
            else
                result = result .. ' (' .. table.concat( qualifierValues, ', ' ) .. ')'
            end
        end
    end

    if result and result ~= '' and options.references then
        result = result .. context.formatRefs( options, statement )
    end

    return result
end

---Функция для оформления части утверждения (snak)
---Подробнее о snak см. d:Викиданные:Глоссарий
---@param context table Context.
---@param options table Parameters.
---@param snak table
---@param circumstances table
---@return string Formatted wikitext.
function formatSnak( context, options, snak, circumstances )
    circumstances = circumstances or {}
    local result

    if snak.snaktype == 'somevalue' then
        if options[ 'somevalue' ] and options[ 'somevalue' ] ~= '' then
            result = options[ 'somevalue' ]
        else
            result = options.i18n[ 'somevalue' ]
        end
    elseif snak.snaktype == 'novalue' then
        if options[ 'novalue' ] and options[ 'novalue' ] ~= '' then
            result = options[ 'novalue' ]
        else
            result = options.i18n[ 'novalue' ]
        end
    elseif snak.snaktype == 'value' then
        result = formatDatavalue( context, options, snak.datavalue, snak.datatype )
        for _, item in pairs( circumstances ) do
            if options.i18n[ item ] then
                result = options.i18n[ item ] .. result
            end
        end
    else
        throwError( 'unknown-snak-type' )
    end

    if not result or result == '' then
        return nil
    end
    
    if options.plain then
    	return result
	end

    return context.wrapSnak( result, snak.hash )
end

---Функция для оформления объектов-значений с географическими координатами
---@param value string Raw value.
---@param options table Parameters.
---@return string Formatted string.
local function formatGlobeCoordinate( value, options )
    -- проверка на требование в параметрах вызова на возврат сырого значения
    if options[ 'subvalue' ] == 'latitude' then -- широты
        return value[ 'latitude' ]
    elseif options[ 'subvalue' ] == 'longitude' then -- долготы
        return value[ 'longitude' ]
    elseif options[ 'nocoord' ] and options[ 'nocoord' ] ~= '' then
        -- если передан параметр nocoord, то не выводить координаты
        -- обычно это делается при использовании нескольких карточек на странице
        return ''
    else
        -- в противном случае формируются параметры для вызова шаблона {{coord}}
        -- нужно дописать в документации шаблона, что он отсюда вызывается, и что
        -- любое изменние его парамеров  должно быть согласовано с кодом тут

        local coordModule = require( 'Module:Coordinates' )

        local globe = options.globe or ''
        if globe == '' and value[ 'globe' ] then
            local globes = require( 'Module:Wikidata/Globes' )
            globe = globes[ value[ 'globe' ] ] or ''
        end

        local display = 'inline'
        if options.display and options.display ~= '' then
            display = options.display
        elseif ( options.property:upper() == 'P625' ) then
            display = 'title'
        end

        local format = options.format or ''
        if format == '' then
            format = 'dms'
            if value[ 'precision' ] then
                local precision = value[ 'precision' ] * 60
                if precision &gt;= 60 then
                    format = 'd'
                elseif precision &gt;= 1 then
                    format = 'dm'
                end
            end
        end

        g_frame.args = {
            tostring( value[ 'latitude' ] ),
            tostring( value[ 'longitude' ] ),
            globe = globe,
            type = options.type and options.type or '',
            scale = options.scale and options.scale or '',
            display = display,
            format = format,
        }

        return coordModule.coord(g_frame)
    end
end

---Функция для оформления объектов-значений с файлами с Викисклада
---@param value string Raw value.
---@param options table Parameters.
---@return string Formatted string.
local function formatCommonsMedia( value, options )
    local image = value

    local caption = ''
    if options[ 'caption' ] and options[ 'caption' ] ~= '' then
        caption = options[ 'caption' ]
    end
    if caption ~= '' then
        caption = wrapQualifier( caption, 'P2096', { class = 'media-caption', style = 'display:block' } )
    end

    if not string.find( value, '[%[%]%{%}]' ) and not string.find( value, 'UNIQ%-%-imagemap' ) then
        -- если в value не содержится викикод или imagemap, то викифицируем имя файла
        -- ищем слово imagemap в строке, потому что вставляется плейсхолдер: [[phab:T28213]]
        image = '[[File:' .. value .. '|frameless'
        if options[ 'border' ] and options[ 'border' ] ~= '' then
            image = image .. '|border'
        end

        local size = options[ 'size' ]
        if size and size ~= '' then
            -- TODO: check localized pixel names too
            if not string.match( size, 'px$' ) then
                size = size .. 'px'
            end
        else
            size = fileDefaultSize
        end
        image = image .. '|' .. size

        if options[ 'alt' ] and options[ 'alt' ] ~= '' then
            image = image .. '|alt=' .. options[ 'alt' ]
        end

        if caption ~= '' then
            image = image .. '|' .. caption
        end
        image = image .. ']]'

        if caption ~= '' then
            image = image .. '&lt;br&gt;' .. caption
        end
    else
        image = image .. caption .. getCategoryByCode( 'media-contains-markup' )
    end

    return image
end

---Function for render math formulas
---@param value string Value.
---@param options table Parameters.
---@return string Formatted string.
local function formatMath( value, options )
    return options.frame:extensionTag{ name = 'math', content = value }
end

---Функция для оформления внешних идентификаторов
---@param value string
---@param options table
---@return string
local function formatExternalId( value, options )
    local formatter = options.formatter
    local propertyId = options.property:upper()

    if not formatter or formatter == '' then
        local isGoodFormat = false

        local wbStatus, formatRegexStatements = pcall( mw.wikibase.getBestStatements, propertyId, 'P1793' )
        if wbStatus and formatRegexStatements then
            for _, statement in pairs( formatRegexStatements ) do
                if statement.mainsnak.snaktype == 'value' then
                    local pattern = mw.ustring.gsub( statement.mainsnak.datavalue.value, '\\', '%' )
                    pattern = mw.ustring.gsub( pattern, '{%d+,?%d*}', '+' )
                    if ( string.find( pattern, '|' ) or string.find( pattern, '%)%?' )
                            or mw.ustring.match( value, '^' .. pattern .. '$' ) ~= nil ) then
                        isGoodFormat = true
                        break
                    end
                end
            end
        end

        if isGoodFormat then
            local formatterStatements
            wbStatus, formatterStatements = pcall( mw.wikibase.getBestStatements, propertyId, 'P1630' )
            if wbStatus and formatterStatements then
                for _, statement in pairs( formatterStatements ) do
                    if statement.mainsnak.snaktype == 'value' then
                        formatter = statement.mainsnak.datavalue.value
                        break
                    end
                end
            end
        end
    end

    if formatter and formatter ~= '' then
        local encodedValue = mw.ustring.gsub( value, '%%', '%%%%' ) -- ломается, если подставить внутрь другого mw.ustring.gsub

        local link = mw.ustring.gsub(
                mw.ustring.gsub( formatter, '$1', encodedValue ), '.',
                { [ ' ' ] = '%20', [ '+' ] = '%2b', [ '[' ] = '%5B', [ ']' ] = '%5D' } )

        local title = options.title
        if not title or title == '' then
            title = '$1'
        end
        title = mw.ustring.gsub(
                mw.ustring.gsub( title, '$1', encodedValue ), '.',
                { [ '[' ] = '(', [ ']' ] = ')' } )

        return '[' .. link .. ' ' .. title .. ']'
    end

    return value
end

---Функция для оформления числовых значений
---@param value table Объект-значение
---@param options table Таблица параметров
---@return string Оформленный текст
local function formatQuantity( value, options )
    -- диапазон значений
    local amount = string.gsub( value.amount, '^%+', '' )
    local lang = mw.language.getContentLanguage()
    local langCode = lang:getCode()

    local function formatNum( number, sigfig )
        local multiplier = ''

        if options.countByThousands then
            local powers = options.i18n.thousandPowers
            local pos = 1
            while math.abs( number ) &gt;= 1000 and pos &lt; #powers do
                number = number / 1000
                pos = pos + 1
            end
            multiplier = powers[ pos ]

            if math.abs( number ) &gt;= 100 then
                sigfig = sigfig or 0
            elseif math.abs( number ) &gt;= 10 then
                sigfig = sigfig or 1
            else
                sigfig = sigfig or 2
            end
        else
            sigfig = sigfig or 12 -- округление до 12 знаков после запятой, на 13-м возникает ошибка в точности
        end

        local iMultiplier = 10^sigfig
        number = math.floor( number * iMultiplier + 0.5 ) / iMultiplier
        return string.gsub( lang:formatNum( number ), '^-', '−' ) .. multiplier
    end

    local out = formatNum( tonumber( amount ) )
    if value.upperBound then
        local diff = tonumber( value.upperBound ) - tonumber( amount )
        if diff &gt; 0 then -- временная провека, пока у большинства значений не будет убрано ±0
            -- Пробуем понять до какого знака округлять
            local integer, dot, decimals, _ = value.upperBound:match( '^+?-?(%d*)(%.?)(%d*)(.*)' )
            local precision
            if dot == '' then
                precision = -integer:match( '0*$' ):len()
            else
                precision = #decimals
            end
            local bound = formatNum( diff, precision )
            if string.match( bound, 'E%-(%d+)' ) then -- если в экспоненциальном формате
                local digits = tonumber( string.match( bound, 'E%-(%d+)' ) ) - 2
                bound = formatNum( diff * 10 ^ digits, precision )
                bound = string.sub( bound, 0, 2 ) .. string.rep( '0', digits ) .. string.sub( bound, -string.len( bound ) + 2 )
            end
            out = out .. ' ± ' .. bound
        end
    end

    if options.unit and options.unit ~= '' then
        if options.unit ~= '-' then
            out = out .. ' ' .. options.unit
        end
    elseif value.unit and string.match( value.unit, 'http://www.wikidata.org/entity/' ) then
        local unitEntityId = string.gsub( value.unit, 'http://www.wikidata.org/entity/', '' )
        if unitEntityId ~= 'undefined' then
            local wbStatus, unitEntity = pcall( mw.wikibase.getEntity, unitEntityId )
            if wbStatus == true and unitEntity then
                if unitEntity.claims.P2370 and
                        unitEntity.claims.P2370[ 1 ].mainsnak.snaktype == 'value' and
                        not value.upperBound and
                        options.siConversion == true
                then
                    local conversionToSiUnit = string.gsub( unitEntity.claims.P2370[ 1 ].mainsnak.datavalue.value.amount, '^%+', '' )
                    if math.floor( math.log10( conversionToSiUnit ) ) ~= math.log10( conversionToSiUnit ) then
                        -- Если не степени десятки (переводить сантиметры в метры не надо!)
                        local outValue = tonumber( amount ) * conversionToSiUnit

                        if outValue &gt; 0 then
                            -- Пробуем понять до какого знака округлять
                            local integer, dot, decimals, _ = amount:match( '^(%d*)(%.?)(%d*)(.*)' )
                            local precision
                            if dot == '' then
                                precision = -integer:match( '0*$' ):len()
                            else
                                precision = #decimals
                            end
                            local adjust = math.log10( math.abs( conversionToSiUnit ) ) + math.log10( 2 )
                            local minPrecision = 1 - math.floor( math.log10( outValue ) + 2e-14 )
                            out = formatNum( outValue, math.max( math.floor( precision + adjust ), minPrecision ) )
                        else
                            out = formatNum( outValue, 0 )
                        end
                        unitEntityId = string.gsub( unitEntity.claims.P2370[ 1 ].mainsnak.datavalue.value.unit, 'http://www.wikidata.org/entity/', '' )
                        wbStatus, unitEntity = pcall( mw.wikibase.getEntity, unitEntityId )
                    end
                end

                local label = getLabelWithLang( context, options, unitEntity.id, nil, { "P5061", "P558", "P558" }, {
                    'P5061[language:' .. langCode .. ']',
                    'P558[P282:' .. writingSystemElementId .. ', P407:' .. langElementId .. ']',
                    'P558[!P282][!P407]'
                } )

                out = out .. ' ' .. label
            end
        end
    end

    return out
end

---Функция для оформления URL
---@param context table
---@param options table
---@param value string
local function formatUrlValue( context, options, value )
    if not options.length or options.length == '' then
        options.length = 25
    end

    local moduleUrl = require( 'Module:URL' )
    return moduleUrl.formatUrlSingle( context, options, value )
end

local DATATYPE_CACHE = {}

---Get property datatype by ID.
---@param propertyId string Property ID, e.g. 'P123'.
---@return string Property datatype, e.g. 'commonsMedia', 'time' or 'url'.
local function getPropertyDatatype( propertyId )
    if not propertyId or not string.match( propertyId, '^P%d+$' ) then
        return nil
    end

    local cached = DATATYPE_CACHE[ propertyId ]
    if cached ~= nil then
        return cached
    end

    local wbStatus, propertyEntity = pcall( mw.wikibase.getEntity, propertyId )
    if wbStatus ~= true or not propertyEntity then
        return nil
    end
    mw.log("Loaded datatype " .. propertyEntity.datatype .. " of " .. propertyId .. ' from wikidata, consider passing datatype argument to formatProperty call or to Wikidata/config' )

    DATATYPE_CACHE[ propertyId ] = propertyEntity.datatype
    return propertyEntity.datatype
end

---@param datavalue table
---@return function
local function getPlainValueFunction( datavalue, _ )
    if datavalue.type == 'wikibase-entityid' then
        return function( _, _, value )
            return getEntityIdFromValue( value )
        end
    elseif datavalue.type == 'string' then
        return function( _, _, value )
            return value
        end
    elseif datavalue.type == 'monolingualtext' then
        return function( _, _, value )
            return value.text
        end
    elseif datavalue.type == 'globecoordinate' then
        return function( _, _, value )
            return value.latitude .. ',' .. value.longitude
        end
    elseif datavalue.type == 'quantity' then
        return function( _, _, value )
            return value.amount
        end
    elseif datavalue.type == 'time' then
        return function( _, _, value )
            return value.time
        end
    end

    throwError( 'unknown-datavalue-type' )
end

---@param datavalue table
---@param datatype string
---@return function
local function getDefaultValueFunction( datavalue, datatype )
    -- вызов обработчиков по умолчанию для известных типов значений
    if datavalue.type == 'wikibase-entityid' then
        -- Entity ID
        return function( context, options, value )
            return formatEntityId( context, options, getEntityIdFromValue( value ) )
        end
    elseif datavalue.type == 'string' then
        -- String
        if datatype and datatype == 'commonsMedia' then
            -- Media
            return function( _, options, value )
                return formatCommonsMedia( value, options )
            end
        elseif datatype and datatype == 'external-id' then
            -- External ID
            return function( _, options, value )
                return formatExternalId( value, options )
            end
        elseif datatype and datatype == 'math' then
            -- Math formula
            return function( _, options, value )
                return formatMath( value, options )
            end
        elseif datatype and datatype == 'url' then
            -- URL
            return formatUrlValue
        end
        return function( _, _, value )
            return value
        end
    elseif datavalue.type == 'monolingualtext' then
        -- моноязычный текст (строка с указанием языка)
        return function( _, options, value )
            if options.monolingualLangTemplate == 'lang' then
                if value.language == CONTENT_LANGUAGE_CODE then
                    return value.text
                end
                return options.frame:expandTemplate{ title = 'lang-' .. value.language, args = { value.text } }
            elseif options.monolingualLangTemplate == 'ref' then
                return '&lt;span class="lang" lang="' .. value.language .. '"&gt;' .. value.text .. '&lt;/span&gt;' .. options.frame:expandTemplate{ title = 'ref-' .. value.language }
            else
                return '&lt;span class="lang" lang="' .. value.language .. '"&gt;' .. value.text .. '&lt;/span&gt;'
            end
        end
    elseif datavalue.type == 'globecoordinate' then
        -- географические координаты
        return function( _, options, value )
            return formatGlobeCoordinate( value, options )
        end
    elseif datavalue.type == 'quantity' then
        return function( _, options, value )
            return formatQuantity( value, options )
        end
    elseif datavalue.type == 'time' then
        return function( context, options, value )
            local moduleDate = require( 'Module:Wikidata/date' )
            return moduleDate.formatDate( context, options, value )
        end
    end

    -- во всех стальных случаях возвращаем ошибку
    throwError( 'unknown-datavalue-type' )
end

---Функция для оформления значений (value)
---Подробнее о значениях  см. d:Wikidata:Glossary/ru
---@param context table
---@param options table
---@param datavalue table
---@param datatype string
---@return string Оформленный текст
function formatDatavalue( context, options, datavalue, datatype )
    if not context then error( 'context not specified' ); end
    if not options then error( 'options not specified' ); end
    if not datavalue then error( 'datavalue not specified' ); end
    if not datavalue.value then error( 'datavalue.value is missing' ); end

    -- проверка на указание специализированных обработчиков в параметрах,
    -- переданных при вызове
    if options.plain then
        context.formatValueDefault = getPlainValueFunction( datavalue, datatype )
    else
        context.formatValueDefault = getDefaultValueFunction( datavalue, datatype )
    end
    local functionToCall = getUserFunction( options, 'value', context.formatValueDefault )
    return functionToCall( context, options, datavalue.value )
end

local DEFAULT_BOUNDARIES = { os.time() * 1000, os.time() * 1000}

---Функция для оформления идентификатора сущности
---@param context table
---@param options table
---@param entityId string
---@return string Оформленный текст
function formatEntityId( context, options, entityId )
    -- получение локализованного названия
    local boundaries
    if options.qualifiers then
        boundaries = p.getTimeBoundariesFromQualifiers( context.frame, context, { qualifiers = options.qualifiers } )
    end
    if not boundaries then
        boundaries = DEFAULT_BOUNDARIES
    end
    local label, labelLanguageCode = getLabelWithLang( context, options, entityId, boundaries )

    -- определение соответствующей показываемому элементу категории
    local category = context.extractCategory( options, { id = entityId } )

    -- получение ссылки по идентификатору
    local link = mw.wikibase.sitelink( entityId )
    if link then
        -- ссылка на категорию, а не добавление страницы в неё
        if mw.ustring.match( link, '^' .. mw.site.namespaces[ 14 ].name .. ':' ) then
            link = ':' .. link
        end
        if label and not options.rawArticle then
            if labelLanguageCode ~= CONTENT_LANGUAGE_CODE then
                label = '&lt;span lang="' .. label .. '"&gt;' .. label .. '&lt;/span&gt;'
            end
            local a = '[[' .. link .. '|' .. label .. ']]'
            if CONTENT_LANGUAGE_CODE ~= labelLanguageCode and 'mul' ~= labelLanguageCode then
                a = a .. getCategoryByCode( 'links-to-entities-with-missing-local-language-label' )
            end
            return a .. category
        else
            return '[[' .. link .. ']]' .. category
        end
    end

    if label then  -- TODO: возможно, лучше просто mw.wikibase.getLabel(entityId)
        -- красная ссылка
        -- TODO: разобраться, почему не всегда есть options.frame
        local title = mw.title.new( label )
        if title and not title.exists and options.frame then
            local moduleRedLink = require( 'Module:Wikidata/redLink' )
            local rawLabel = mw.wikibase.getLabel(entityId) or label -- без |text= и boundaries; or label - костыль
            local redLink = moduleRedLink.formatRedLinkWithInfobox(rawLabel, label, entityId)
            if CONTENT_LANGUAGE_CODE ~= labelLanguageCode and 'mul' ~= labelLanguageCode then
                redLink = '&lt;span lang="' .. labelLanguageCode .. '"&gt;' .. redLink .. '&lt;/span&gt;' ..
                        getCategoryByCode( 'links-to-entities-with-missing-local-language-label' )
            end
            return redLink .. '&lt;sup&gt;[[:d:' .. entityId .. '|[d]]]&lt;/sup&gt;' .. category
        end

        -- TODO: перенести до проверки на существование статьи
        local sup = ''
        if ( not options.format or options.format ~= 'text' )
                and entityId ~= 'Q6581072' and entityId ~= 'Q6581097' -- TODO: переписать на format=text
        then
            sup = '&lt;sup class="plainlinks noprint"&gt;[//www.wikidata.org/wiki/' .. entityId .. '?uselang=' .. CONTENT_LANGUAGE_CODE .. ' [d&amp;#x5d;]&lt;/sup&gt;'
        end

        -- одноимённая статья уже существует - выводится текст и ссылка на ВД
        return '&lt;span class="iw" data-title="' .. label .. '"&gt;' .. label
                .. sup
                .. '&lt;/span&gt;' .. category
    end
    -- сообщение об отсутвии локализованного названия
    -- not good, but better than nothing
    return '[[:d:' .. entityId .. '|' .. entityId .. ']]&lt;span style="border-bottom: 1px dotted; cursor: help; white-space: nowrap" title="В Викиданных нет русской подписи к элементу. Вы можете помочь, указав русский вариант подписи."&gt;?&lt;/span&gt;' .. getCategoryByCode( 'links-to-entities-with-missing-label' ) .. category
end

---Функция для оформления утверждений (statement)
---Подробнее о утверждениях см. d:Wikidata:Glossary/ru
---@deprecated Use p.formatProperty() instead
---@param frame table
---@return string Строка оформленного текста, предназначенная для отображения в статье
function p.formatStatements( frame )
    return p.formatProperty( frame )
end

---Получение параметров, которые обычно используются для вывода свойства.
---@param propertyId string
---@param datatype string
---@param params table
function getPropertyParams( propertyId, datatype, params )
    local config = getConfig()

    -- Различные уровни настройки параметров, по убыванию приоритета
    local propertyParams = {}

    -- 1. Параметры, указанные явно при вызове
    if params then
        for key, value in pairs( params ) do
            if value ~= '' then
                propertyParams[ key ] = value
            end
        end
    end
    
    if toBoolean( propertyParams.plain, false ) then
    	propertyParams.separator = propertyParams.separator or ', '
		propertyParams.conjunction = propertyParams.conjunction or ', '
	else
	    -- 2. Настройки конкретного параметра
	    if config.properties and config.properties[ propertyId ] then
	        for key, value in pairs( config.properties[ propertyId ] ) do
	            if propertyParams[ key ] == nil then
	                propertyParams[ key ] = value
	            end
	        end
	    end
	
	    -- 3. Указанный пресет настроек
	    if propertyParams.preset and config.presets and
	            config.presets[ propertyParams.preset ]
	    then
	        for key, value in pairs( config.presets[ propertyParams.preset ] ) do
	            if propertyParams[ key ] == nil then
	                propertyParams[ key ] = value
	            end
	        end
	    end
	
	    datatype = datatype or params.datatype or propertyParams.datatype or getPropertyDatatype( propertyId )
	    if propertyParams.datatype == nil then
	        propertyParams.datatype = datatype
	    end
	
	    -- 4. Настройки для типа данных
	    if datatype and config.datatypes and config.datatypes[ datatype ] then
	        for key, value in pairs( config.datatypes[ datatype ] ) do
	            if propertyParams[ key ] == nil then
	                propertyParams[ key ] = value
	            end
	        end
	    end
	
	    -- 5. Общие настройки для всех свойств
	    if config.global then
	        for key, value in pairs( config.global ) do
	            if propertyParams[ key ] == nil then
	                propertyParams[ key ] = value
	            end
	        end
	    end
	end

    return propertyParams
end

---Функция для оформления утверждений (statement)
---Подробнее о утверждениях см. d:Wikidata:Glossary/ru
---@param frame table
---@return string Строка оформленного текста, предназначенная для отображения в статье
function p.formatProperty( frame )
    local args = copyTo( frame.args, {} )

    -- проверка на отсутствие обязательного параметра property
    if not args.property then
        throwError( 'property-param-not-provided' )
    end
    local override
    local propertyId = mw.language.getContentLanguage():ucfirst( string.gsub( args.property, '([^Pp0-9].*)$', function(w)
        if string.sub( w, 1, 1 ) == '~' then
            override = w
        end
        return ''
    end ) )

    if override then
        args[ override:match( '[,~]([^=]*)=' ) ] = override:match( '=(.*)' )
        args.property = propertyId
    end

    -- проброс всех параметров из шаблона {wikidata} и параметра from откуда угодно
    local p_frame = frame
    while p_frame do
        if p_frame:getTitle() == mw.site.namespaces[ 10 ].name .. ':Wikidata' then
            copyTo( p_frame.args, args, true )
        end
        if p_frame.args and p_frame.args.from and p_frame.args.from ~= '' then
            args.entityId = p_frame.args.from
        else
            args.entityId = mw.wikibase.getEntityIdForCurrentPage()
        end
        p_frame = p_frame:getParent()
    end

    args = getPropertyParams( propertyId, nil, args )
    local datatype = args.datatype

    -- перевод итоговых значений флагов в true/false и добавление значений
    -- по умолчанию только в том случае, если они нигде не были указаны ранее
    args.plain = toBoolean( args.plain, false )
    args.nocat = not args.plain and toBoolean( args.nocat, false )
    args.references = not args.plain and toBoolean( args.references, true )

    -- если значение передано в параметрах вызова то выводим только его
    if args.value and args.value ~= '' then
        -- специальное значение для скрытия Викиданных
        if args.value == '-' then
            return ''
        end
        local value = args.value

        -- опция, запрещающая оформление значения, поэтому никак не трогаем
        if args.plain then
            return value
        end

        local context = initContext( args )
        -- обработчики по типу значения
        local wrapperExtraArgs = {}
        if args[ 'value-module' ] and args[ 'value-function' ] and not string.find( value, '[%[%]%{%}]' ) then
            local func = getUserFunction( args, 'value' )
            value = func( context, args, value )
        elseif datatype == 'commonsMedia' then
            value = formatCommonsMedia( value, args )
        elseif datatype == 'external-id' and not string.find( value, '[%[%]%{%}]' ) then
            wrapperExtraArgs[ 'data-wikidata-external-id' ] = mw.text.killMarkers( value )
            value = formatExternalId( value, args )
            --elseif datatype == 'math' then
            -- args.frame = frame -- костыль: в formatMath нужно frame:extensionTag
            --	value = formatMath( value, args )
        elseif datatype == 'url' then
            value = formatUrlValue( context, args, value )
        end

        -- оборачиваем в тег для JS-функций
        if string.match( propertyId, '^P%d+$' ) then
            value = mw.text.trim( value )

            -- временная штрафная категория для исправления табличных вставок
            local allowTables = getPropertyParams( propertyId, nil, {} ).allowTables
            if not allowTables
                    and string.match( value, '&lt;t[dhr][ &gt;]' )
            -- and not string.match( value, '&lt;table[ &gt;]' )
            -- and not string.match( value, '^%{%|' )
            then
                value = value .. getCategoryByCode( 'value-contains-table', propertyId )
            else
                value = wrapStatement( value, propertyId, nil, wrapperExtraArgs )
            end
        end

        return value
    end

    -- ability to disable loading Wikidata
    if args.entityId == '-' then
        return ''
    end

    g_frame = frame
    -- после проверки всех аргументов -- вызов функции оформления для свойства (набора утверждений)
    return formatProperty( args )
end

---Функция проверки на присутствие источника в списке нерекомендованных.
---@param snaks table
---@return boolean
local function isReferenceDeprecated( snaks )
    if not snaks then
        return false
    end
    if snaks.P248
            and snaks.P248[ 1 ]
            and snaks.P248[ 1 ].datavalue
            and snaks.P248[ 1 ].datavalue.value.id
    then
        local entityId = snaks.P248[ 1 ].datavalue.value.id
        if getConfig( 'deprecatedSources', entityId ) then
            return true
        end
    elseif snaks.P1433
            and snaks.P1433[ 1 ]
            and snaks.P1433[ 1 ].datavalue
            and snaks.P1433[ 1 ].datavalue.value.id
    then
        local entityId = snaks.P1433[ 1 ].datavalue.value.id
        if getConfig( 'deprecatedSources', entityId ) then
            return true
        end
    end
    return false
end

---Функция оформления ссылок на источники (reference)
---Подробнее о ссылках на источники см. d:Wikidata:Glossary/ru
---
---Экспортируется в качестве зарезервированной точки для вызова из функций-расширения вида claim-module/claim-function через context
---Вызов из других модулей напрямую осуществляться не должен (используйте frame:expandTemplate вместе с одним из специлизированных шаблонов вывода значения свойства).
---@param context table
---@param options table
---@param statement table
---@return string Оформленные примечания для отображения в статье
function formatRefs( context, options, statement )
    if not context then error( 'context not specified' ); end
    if not options then error( 'options not specified' ); end
    if not options.entityId then error( 'options.entityId missing' ); end
    if not statement then error( 'statement not specified' ); end

    if not outputReferences then
        return ''
    end

    ---@type string[]
    local references = {}
    if statement.references then
        local hasNotDeprecated = false
        local displayCount = 0
        for _, reference in pairs( statement.references ) do
            if not isReferenceDeprecated( reference.snaks ) then
                hasNotDeprecated = true
            end
        end

        for _, reference in pairs( statement.references ) do
            local display = true
            if hasNotDeprecated then
                if isReferenceDeprecated( reference.snaks ) then
                    display = false
                end
            end
            if displayCount &gt;= 2 then
                if options.entityId and options.property then
                    local propertyId = mw.ustring.match( options.property, '^[Pp][0-9]+' )  -- TODO: обрабатывать не тут, а раньше
                    local moreReferences = '&lt;sup&gt;[[d:' .. options.entityId .. '#' .. string.upper( propertyId ) .. '|[…]]]&lt;/sup&gt;'
                    table.insert( references, moreReferences )
                end
                break
            end
            if display == true then
                ---@type string
                local refText = moduleSources.renderReference( g_frame, options.entityId, reference )
                if refText and refText ~= '' then
                    table.insert( references, refText )
                    displayCount = displayCount + 1
                end
            end
        end
    end
    return table.concat( references )
end

return p</text>
      <sha1>sf2423tmefc6ng73453006j8r1ilcun</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Sources</title>
    <ns>828</ns>
    <id>5167285</id>
    <revision>
      <id>133259378</id>
      <parentid>130738729</parentid>
      <timestamp>2023-09-25T20:55:34Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>брать идентификаторы с текущей страницы, если значение сущности не указано явно — см. [[Википедия:Форум/Викиданные#Ссылка на источник]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="56334" xml:space="preserve">---@alias args table
---@alias frame { args: args, extensionTag: function, newChild: ( fun( args: args ): frame ) }
---@alias source { publication: source, [string]: any }
---@alias value: string | { id: string }
---@alias snak { datatype: string, snaktype: string, datavalue: { type: string, value: value } }
---@alias snaks table&lt;string, table&lt;number, snak&gt;&gt;
---@alias statement { mainsnak: snak, rank: string, qualifiers: snaks }
---@alias statements table&lt;string, table&lt;number, statement&gt;&gt;
---@alias map { name: string, ids: string[] }[]&gt;

---@type table
local p = {}

---@type table&lt;string, string&gt;
local NORMATIVE_DOCUMENTS = {
    Q20754888 = 'Закон Российской Федерации',
    Q20754884 = 'Закон РСФСР',
    Q20873831 = 'Распоряжение Президента Российской Федерации',
    Q20873834 = 'Указ исполняющего обязанности Президента Российской Федерации',
    Q2061228 = 'Указ Президента Российской Федерации',
}

---@type table&lt;string, string&gt;
local LANG_CACHE =	{
    Q150 = 'fr',
    Q188 = 'de',
    Q1321 = 'es',
    Q1860 = 'en',
    Q652 = 'it',
    Q7737 = 'ru',
    Q8798 = 'uk',
}

---@type map
local PROPERTY_MAP = {
    { name = 'sourceId', ids = { 'P248', 'P805' } },
    { name = 'lang', ids = { 'P407', 'P364' } },
    { name = 'author', ids = { 'P50', 'P2093' } },
    { name = 'part', ids = { 'P958', 'P1810' } },
    { name = 'title', ids = { 'P1476' } },
    { name = 'subtitle', ids = { 'P1680' } },
    { name = 'url', ids = { 'P953', 'P1065', 'P854', 'P973', 'P2699', 'P888' } },
    { name = 'editor', ids = { 'P98' } },
    { name = 'translator', ids = { 'P655' } },
    { name = 'publication-id', ids = { 'P1433' } },
    { name = 'edition', ids = { 'P393' } },
    { name = 'publisher', ids = { 'P123' } },
    { name = 'place', ids = { 'P291' } },
    { name = 'volume', ids = { 'P478' } },
    { name = 'issue', ids = { 'P433' } },
    { name = 'dateOfCreation', ids = { 'P571' } },
    { name = 'dateOfPublication', ids = { 'P577' } },
    { name = 'pages', ids = { 'P304' } },
    { name = 'numberOfPages', ids = { 'P1104' } },
    { name = 'tirage', ids = { 'P1092' } },
    { name = 'isbn', ids = { 'P212', 'P957' } },
    { name = 'issn', ids = { 'P236' } },
    -- { name = 'accessdate', ids = { 'P813' } }, -- disable, creates duplicate references
    { name = 'docNumber', ids = { 'P1545' } },
    { name = 'type', ids = { 'P31' } },
    { name = 'arxiv', ids = { 'P818' } },
    { name = 'doi', ids = { 'P356' } },
    { name = 'pmid', ids = { 'P698' } },
}
-- table.insert( PROPERTY_MAP.url, 'P856' ) -- only as qualifier

---@type map
local PUBLICATION_PROPERTY_MAP = mw.clone( PROPERTY_MAP )

---@type string[]
local monthGen = { 'января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря' }

---@type string
local i18nDefaultLanguage = mw.language.getContentLanguage():getCode()
p.i18nDefaultLanguage = i18nDefaultLanguage

---@type string
local i18nEtAlDefault = ' et al.'

---@type table&lt;string, string&gt;
local i18nEtAl = {
    ru	= ' и др.',
    uk	= ' та ін.',
}

---@type table&lt;string, string&gt;
local i18nEditors = {
    fr	= '',
    de	= 'Hrsg.: ',
    es	= '',
    en	= '',
    it	= '',
    ru	= 'под ред. ',
    uk	= 'за ред. ',
}

---@type table&lt;string, string&gt;
local i18nTranslators = {
    fr	= '',
    de	= '',
    es	= '',
    en	= '',
    it	= '',
    ru	= 'пер. ',
    uk	= 'пер. ',
}

---@type table&lt;string, string&gt;
local i18nVolume = {
    de  = 'Vol.',
    fr	= 'Vol.',
    es	= 'Vol.',
    en	= 'Vol.',
    it	= 'Vol.',
    ru	= 'Т.',
    uk	= 'Т.',
}

---@type table&lt;string, string&gt;
local i18nIssue = {
    en	= 'Iss.',
    ru	= 'вып.',
    uk	= 'вип.',
}

---@type table&lt;string, string&gt;
local i18nPages = {
    fr = 'P.',
    de = 'S.',
    es = 'P.',
    en = 'P.',
    it = 'P.',
    ru = 'С.',
    uk = 'С.',
}

---@type table&lt;string, string&gt;
local i18nNumberOfPages = {
    en = 'p.',
    ru = 'с.',
}

---@type table&lt;string, string&gt;
local i18nTirage = {
    en	= 'ed. size: %d',
    ru	= '%d экз.',
}

---@param args args
---@return source
local function getFilledArgs( args )
    ---@type source
    local data = {}

    for key, value in pairs( args ) do
        if mw.text.trim( value ) ~= '' then
            if key == 1 then
                key = 'sourceId'
            end
            data[ key ] = mw.text.trim( value )
        end
    end

    return data
end

---Returns formatted pair {Family name(s), First name(s)}
---@param fullName string
---@return table&lt;number, string&gt;
local function tokenizeName( fullName )
    local space = '%s+' -- matches single or more spacing character
    local name = "(%a[%a%-']*)%.?" -- matches single name, have to start with letter, can contain apostrophe and hyphen, may end with dot
    local surname = "(%a[%a%-']*)" -- same as name, but can't end with dot
    local surnamePrefixes = { 'ван', 'van', 'де', 'de' }

    local nm, nm2, srn, srn2, pref

    fullName = ' ' .. fullName .. ' '
    fullName = mw.ustring.gsub( fullName, ' оглы ', ' ' )
    fullName = mw.text.trim( fullName )

    -- Surname, Name
    local pattern = '^' .. surname .. ',' .. space .. name .. '$'
    srn, nm = mw.ustring.match( fullName, pattern )
    if srn then
        return {
            srn,
            mw.ustring.sub( nm, 1, 1 ) .. '.'
        }
    end

    -- Surname, Name prefix
    for _, surnamePrefix in pairs( surnamePrefixes ) do
        pattern = '^' .. surname .. ',' .. space .. name .. space .. '(' .. surnamePrefix .. ')' .. '$'
        srn, nm, pref = mw.ustring.match( fullName, pattern )
        if srn then
            return {
                mw.ustring.sub( pref ) .. ' ' .. srn,
                mw.ustring.sub( nm, 1, 1 ) .. '.' }
        end
    end

    -- Surname, Name Name
    pattern = '^' .. surname .. ',' .. space .. name .. space .. name .. '$'
    srn, nm, nm2 = mw.ustring.match( fullName, pattern )
    if srn then
        return {
            srn,
            mw.ustring.sub( nm, 1, 1 ) .. '.&amp;nbsp;' .. mw.ustring.sub( nm2, 1, 1 ) .. '.'
        }
    end

    -- Surname Surname, Name
    pattern = '^' .. surname .. space .. surname .. ',' .. space .. name .. '$'
    srn, srn2, nm = mw.ustring.match( fullName, pattern )
    if srn then
        return {
            srn .. '&amp;nbsp;' .. srn2,
            mw.ustring.sub( nm, 1, 1 ) .. '.'
        }
    end

    -- Name Name Surname
    pattern = '^' .. name .. space .. name .. space .. surname .. '$'
    nm, nm2, srn = mw.ustring.match( fullName, pattern )
    if srn then
        return {
            srn,
            mw.ustring.sub( nm, 1, 1 ) .. '.&amp;nbsp;' .. mw.ustring.sub( nm2, 1, 1 ) .. '.'
        }
    end

    -- Name Name prefix Surname
    for _, surnamePrefix in pairs( surnamePrefixes ) do
        pattern = '^' .. name .. space .. name .. space .. '(' .. surnamePrefix .. ')' .. space .. surname .. '$'
        nm, nm2, pref, srn = mw.ustring.match( fullName, pattern )
        if srn then
            return {
                mw.ustring.sub( pref ) .. ' ' .. srn,
                mw.ustring.sub( nm, 1, 1 ) .. '.&amp;nbsp;' .. mw.ustring.sub( nm2, 1, 1 ) .. '.'
            }
        end
    end

    -- Surname, Name Name prefix
    for _, surnamePrefix in pairs( surnamePrefixes ) do
        pattern = '^' .. surname .. ',' .. space .. name .. space .. name .. space .. '(' .. surnamePrefix .. ')' .. '$'
        srn, nm, nm2, pref = mw.ustring.match( fullName, pattern )
        if srn then
            return {
            	mw.ustring.sub( pref ) .. ' ' .. srn,
            	mw.ustring.sub( nm, 1, 1 ) .. '.&amp;nbsp;' .. mw.ustring.sub( nm2, 1, 1 ) .. '.'
            }
        end
    end

    -- Name{1,4} Surname
    for k = 1, 4 do
        pattern = '^' .. string.rep( name .. space, k ) .. surname .. '$'
        ---@type string[]
        local matched = { mw.ustring.match( fullName, pattern ) }
        if #matched ~= 0 then
            for j = 1, k do
                matched[ j ] = mw.ustring.sub( matched[ j ], 1, 1 )
            end
            return {
            	matched[ k + 1 ],
            	table.concat( matched, '.&amp;nbsp;', 1, k ) .. '.'
            }
        end
    end

    -- Surname Name{1,4}
    for k = 1, 4 do
        pattern = '^' .. surname .. string.rep( space .. name, k ) .. '$'
        ---@type string[]
        local matched = { mw.ustring.match( fullName, pattern ) }
        if #matched ~= 0 then
            for j = 2, k + 1 do
                matched[ j ] = mw.ustring.sub( matched[ j ], 1, 1 )
            end
            return {
            	matched[ 1 ],
            	table.concat( matched, '.&amp;nbsp;', 2, k + 1 ) .. '.'
            }
        end
    end

    return { fullName }
end

---@param fullName string | nil
---@return string | nil
local function personNameToAuthorName( fullName )
    if not fullName then
        return nil
    end

    local tokenized = tokenizeName( fullName )
    if #tokenized == 1 then
        return tokenized[ 1 ]
    end

    return tokenized[ 1 ] .. '&amp;nbsp;' .. tokenized[ 2 ]
end

---@param fullName string | nil
---@return string | nil
local function personNameToResponsibleName( fullName )
    if not fullName then
        return nil
    end

    local tokenized = tokenizeName( fullName )
    if #tokenized == 1 then
        return tokenized[ 1 ]
    end

    return tokenized[ 2 ] .. '&amp;nbsp;' .. tokenized[ 1 ]
end

---@alias options { separator: string, conjunction: string, format: ( fun( data: string ): string ), nolinks: boolean, preferids: boolean, short: boolean }

---@type options
local options_commas = {
    separator = ', ',
    conjunction = ', ',
    format = function( data ) return data end,
    nolinks = false,
    preferids = false,
    short = false,
}

---@type options
local options_commas_short = mw.clone( options_commas )
options_commas_short.short = true

---@type options
local options_commas_it_short = mw.clone( options_commas_short )
options_commas_it_short.format = function( data ) return "''" .. data .. "''" end

---@type options
local options_commas_nolinks = mw.clone( options_commas )
options_commas_nolinks.nolinks = true

---@type options
local options_citetypes = {
    separator = ' ',
    conjunction = ' ',
    format = function( data ) return 'citetype_' .. data end,
    nolinks = true ,
    preferids = true,
    short = false,
}

---@type options
local options_commas_authors = mw.clone( options_commas )
options_commas_authors.format = personNameToAuthorName

---@type options
local options_commas_responsible = mw.clone( options_commas )
options_commas_responsible.format = personNameToResponsibleName

---@type options
local options_ids = {
    separator = '; ',
    conjunction = '; ',
    format = function( id ) return id end,
    nolinks = true,
    preferids = false,
    short = false,
}

---@type options
local options_arxiv = mw.clone( options_ids )
options_arxiv.format = function( id ) return '[https://arxiv.org/abs/' .. id .. ' arXiv:' .. id .. ']' end

---@type options
local options_doi = mw.clone( options_ids )
options_doi.format = function( doi ) return '[https://dx.doi.org/' .. doi .. ' doi:' .. doi .. ']' end

---@type options
local options_issn = mw.clone( options_ids )
options_issn.format = function( issn ) return '[https://www.worldcat.org/issn/' .. issn .. ' ' .. issn .. ']' end

---@type options
local options_pmid = mw.clone( options_ids )
options_pmid.format = function( pmid ) return '[https://www.ncbi.nlm.nih.gov/pubmed/?term=' .. pmid .. ' PMID:' .. pmid .. ']' end

---@param str string | nil
---@return boolean
local function isEmpty( str )
    return not str or #str == 0
end

---@param allQualifiers snaks
---@param qualifierPropertyId string
---@return string | nil
local function getSingleStringQualifierValue( allQualifiers, qualifierPropertyId )
    if not allQualifiers or not allQualifiers[ qualifierPropertyId ] then
        return nil
    end

    ---@type table&lt;number, snak&gt;
    local propertyQualifiers = allQualifiers[ qualifierPropertyId ]

    for _, qualifier in pairs( propertyQualifiers ) do
        if ( qualifier
                and qualifier.datatype == 'string'
                and qualifier.datavalue
                and qualifier.datavalue.type == 'string'
                and qualifier.datavalue.value ~= ''
        ) then
            return qualifier.datavalue.value
        end
    end

    return nil
end

---@param data table
---@param resultProperty string
---@return void
local function appendImpl_toTable( data, resultProperty )
    if not data[ resultProperty ] then
        data[ resultProperty ] = {}
    elseif ( type( data[ resultProperty ] ) == 'string' or ( type( data[ resultProperty ] ) == 'table' and type( data[ resultProperty ].id ) == 'string' ) ) then
        data[ resultProperty ] = { data[ resultProperty ] }
    end
end

---@param datavalue table
---@param qualifiers snaks
---@param data table
---@param propertyName string
---@param options table
local function appendImpl( datavalue, qualifiers, data, propertyName, options )
    data[ propertyName ] = data[ propertyName ] or {}
    if propertyName == 'issn' then
        table.insert( data[ propertyName ], datavalue.value )
    elseif propertyName == 'url' or datavalue.type == 'url' then
        local value = datavalue.value
        if options.format then
            value = options.format( value )
        end
        appendImpl_toTable( data, propertyName )
        table.insert( data[ propertyName ], value )
    elseif datavalue.type == 'string' then
        local value = getSingleStringQualifierValue( qualifiers, 'P1932' )
        if not value then
            value = getSingleStringQualifierValue( qualifiers, 'P1810' )
        end

        if not value then
            value = datavalue.value
            if options.format then
                value = options.format( value )
            end
        end

        appendImpl_toTable(data, propertyName)
        local pos = getSingleStringQualifierValue( qualifiers, 'P1545' )
        if pos then
            table.insert( data[ propertyName ], tonumber(pos), value )
        else
            table.insert( data[ propertyName ], value )
        end
    elseif datavalue.type == 'monolingualtext' then
        local value = datavalue.value.text
        if options.format then
            value = options.format( value )
        end
        appendImpl_toTable( data, propertyName )
        table.insert( data[ propertyName ], value )
    elseif datavalue.type == 'quantity' then
        local value = datavalue.value.amount
        if ( mw.ustring.sub( value , 1, 1 ) == '+' ) then
            value = mw.ustring.sub( value , 2 )
        end
        if options.format then
            value = options.format( value )
        end
        appendImpl_toTable( data, propertyName )
        table.insert( data[ propertyName ], value )
    elseif datavalue.type == 'wikibase-entityid' then
        local pos = getSingleStringQualifierValue( qualifiers, 'P1545' )
        local value = datavalue.value
        appendImpl_toTable(data, propertyName)
        local label = getSingleStringQualifierValue( qualifiers, 'P1932' )
        if not label then
            label = getSingleStringQualifierValue( qualifiers, 'P1810' )
        end
        local toInsert = {
            id = value.id,
            label = label
        }
        if pos and tonumber( pos ) then
            table.insert( data[ propertyName ], tonumber( pos ), toInsert )
        else
            table.insert( data[ propertyName ], toInsert )
        end
    elseif datavalue.type == 'time' then
        local value = datavalue.value
        if options.format then
            value = options.format( value )
        end
        appendImpl_toTable( data, propertyName )
        table.insert( data[ propertyName ], tostring( value.time ) )
    end
end

---@param entityId string
---@param propertyId string
---@return table&lt;number, statement&gt;
local function getAllStatements( entityId, propertyId )
    ---@type boolean, table&lt;number, statement&gt;
    local wdStatus, statements = pcall( mw.wikibase.getAllStatements, entityId, propertyId )
    if wdStatus and statements then
        return statements
    end

    return {}
end

---@param entityId string
---@param propertyId string
---@return table&lt;number, statement&gt;
local function getBestStatements( entityId, propertyId )
    ---@type boolean, table&lt;number, statement&gt;
    local wdStatus, statements = pcall( mw.wikibase.getBestStatements, entityId, propertyId )
    if wdStatus and statements then
        return statements
    end

    return {}
end

---@param entityId string
---@param projectToCheck string?
---@return string | nil
local function getSitelink( entityId, projectToCheck )
    ---@type boolean, string
    local wbStatus, sitelink

    if projectToCheck then
        wbStatus, sitelink = pcall( mw.wikibase.getSitelink, entityId, projectToCheck )
    else
        wbStatus, sitelink = pcall( mw.wikibase.getSitelink, entityId )
    end

    if not wbStatus then
        return nil
    end

    return sitelink
end

---@param args any[]
---@return any | nil
local function coalesce( args )
    for _, arg in pairs( args ) do
        if not isEmpty( arg ) then return arg end
    end
    return nil
end

---@param value any
---@return string | nil
local function getSingle( value )
    if type( value ) == 'string' then
        return tostring( value )
    elseif type( value ) == 'table' then
        if value.id then
            return tostring( value.id )
        end

        for _, tableValue in pairs( value ) do
            return getSingle( tableValue )
        end
    end

    return nil
end

---@param langEntityId string
---@return string | nil
local function getLangCode( langEntityId )
    if not langEntityId then
        return nil
    end

    langEntityId = getSingle( langEntityId )

    if not string.match( langEntityId, '^Q%d+$' ) then
        return langEntityId
    end

    local cached = LANG_CACHE[ langEntityId ]
    if cached then
        if cached == '' then
            return nil
        end
        return cached
    end

    local claims = getBestStatements( langEntityId, 'P424' )
    for _, claim in pairs( claims ) do
        if claim
                and claim.mainsnak
                and claim.mainsnak.datavalue
                and claim.mainsnak.datavalue.value
        then
            LANG_CACHE[ langEntityId ] = claim.mainsnak.datavalue.value
            return claim.mainsnak.datavalue.value
        end
    end

    LANG_CACHE[ langEntityId ] = ''
    return nil
end

---@param entityId string
---@param propertyId string
---@param data source
---@param propertyName string
---@param options table?
---@return void
local function appendEntitySnaks( entityId, propertyId, data, propertyName, options )
    options = options or {}

    -- do not populate twice
    if data[ propertyName ] and ( propertyName ~= 'author' or data[ propertyId ] ) then
        return
    end

    local statements = getBestStatements( entityId, propertyId )

    if propertyName == 'author' then
        data[ propertyId ] = true
    end

    local lang = getLangCode( data.lang ) or i18nDefaultLanguage

    if propertyId == 'P1680' then -- if there is a default language
        for _, statement in pairs( statements ) do
            if statement and
                    statement.mainsnak and
                    statement.mainsnak.datavalue and
                    statement.mainsnak.datavalue.value and
                    statement.mainsnak.datavalue.value.language == lang
            then
                --found default language string
                appendImpl( statement.mainsnak.datavalue, statement.qualifiers, data, propertyName, options )
                return
            end
        end
    end

    for _, statement in pairs( statements ) do
        if statement and statement.mainsnak and statement.mainsnak.datavalue then
            appendImpl( statement.mainsnak.datavalue, statement.qualifiers or {}, data, propertyName, options )
            if propertyName == 'publication-id' and statement.qualifiers then
                data[ 'publication-qualifiers' ] = statement.qualifiers
            end
        end
    end
end

---@param claims table&lt;number, statement&gt;
---@param qualifierPropertyId string
---@param result table
---@param resultPropertyId string
---@param options table
---@return void
local function appendQualifiers( claims, qualifierPropertyId, result, resultPropertyId, options )
    -- do not populate twice
    if not claims or result[ resultPropertyId ] then
        return
    end

    for _, claim in pairs( claims ) do
        if claim.qualifiers and claim.qualifiers[ qualifierPropertyId ] then
            ---@type table&lt;number, snak&gt;
            local propertyQualifiers = claim.qualifiers[ qualifierPropertyId ]
            for _, qualifier in pairs( propertyQualifiers ) do
                if qualifier and qualifier.datavalue then
                    appendImpl( qualifier.datavalue, nil, result, resultPropertyId, options )
                end
            end
        end
    end
end

---@param entityId string
---@param propertyId string
---@param value any
---@return table&lt;number, statement&gt;
local function findClaimsByValue( entityId, propertyId, value )
    local result = {}

    local claims = getAllStatements( entityId, propertyId )
    for _, claim in pairs( claims ) do
        if ( claim.mainsnak and claim.mainsnak.datavalue ) then
            local datavalue = claim.mainsnak.datavalue
            if ( datavalue.type == "string" and datavalue.value == value ) or
                    ( datavalue.type == "wikibase-entityid" and
                            datavalue.value[ "entity-type" ] == "item" and
                            tostring( datavalue.value.id ) == value )
            then
                table.insert( result, claim )
            end
        end
    end

    return result
end

---@param entityId string
---@param typeEntityId string
---@return boolean
local function isInstanceOf( entityId, typeEntityId )
    return findClaimsByValue( entityId, 'P31', typeEntityId )[ 1 ] ~= nil
end

---@param entityId string
---@param typeEntityIds string[]
---@return string
---@todo Rewrite
local function getFirstType( entityId, typeEntityIds )
    for _, typeEntityId in pairs( typeEntityIds ) do
        if isInstanceOf( entityId, typeEntityId ) then
            return typeEntityId
        end
    end

    return nil
end

---@param snaks snaks
---@param data source
---@param map map
---@return void
local function populateDataFromSnaks( snaks, data, map )
    for _, row in ipairs( map ) do
        local parameterName, propertyIds = row.name, row.ids
        for _, propertyId in pairs( propertyIds ) do
            if not data[ parameterName ] and snaks[ propertyId ] then
                local options = {}
                if propertyId == 'P888' then
                    options = { format = function( id ) return 'http://www.jstor.org/stable/' .. id end }
                end

                for _, snak in pairs( snaks[ propertyId ] ) do
                    if snak and snak.datavalue then
                        appendImpl( snak.datavalue, {}, data, parameterName, options )
                    end
                end
            end
        end
    end
end

---@param entityId string | nil
---@param data source
---@param map map
---@return void
local function populateDataFromEntity( entityId, data, map )
    if not data.title then
        if not isEmpty( entityId ) then
            local optionsAsLinks = { format = function( text ) return { id = entityId, label = text } end }
            appendEntitySnaks( entityId, 'P1476', data, 'title', optionsAsLinks )
        else
            appendEntitySnaks( entityId, 'P1476', data, 'title', {} )
        end
        appendEntitySnaks( entityId, 'P1680', data, 'subtitle', {} )
    end

    local bookSeriesStatements = getBestStatements( entityId, 'P361' )
    for _, statement in pairs( bookSeriesStatements ) do
        if statement and
                statement.mainsnak and
                statement.mainsnak.datavalue and
                statement.mainsnak.datavalue.value and
                statement.mainsnak.datavalue.value.id
        then
            local possibleBookSeriesEntityId = statement.mainsnak.datavalue.value.id
            if isInstanceOf( possibleBookSeriesEntityId, 'Q277759' ) then
                appendImpl_toTable( data, 'bookSeries' )
                table.insert( data.bookSeries, { id = possibleBookSeriesEntityId } )

                appendQualifiers( { statement }, 'P478', data, 'bookSeriesVolume', {} )
                appendQualifiers( { statement }, 'P433', data, 'bookSeriesIssue', {} )
            end
        end
    end

    for _, row in ipairs( map ) do
        local parameterName, propertyIds = row.name, row.ids
        for _, propertyId in pairs( propertyIds ) do
            local options = {}
            if propertyId == 'P888' then
                options = { format = function( id ) return 'http://www.jstor.org/stable/' .. id end }
            end

            appendEntitySnaks( entityId, propertyId, data, parameterName, options )
        end
    end
end

---@param data source
---@return void
local function expandPublication( data )
    if not data[ 'publication-id' ] then
        return
    end

    local publicationId = getSingle( data[ 'publication-id' ] )
    data.publication = {}
    for key, value in pairs( data ) do
        if not string.match( key, '^publication-' ) then
            data.publication[ key ] = value
        end
    end
    data.publication.sourceId = publicationId
    data.publication.title = data[ 'publication-title' ]
    data.publication.subtitle = data[ 'publication-subtitle' ]

    if data[ 'publication-qualifiers' ] then
        populateDataFromSnaks( data[ 'publication-qualifiers' ], data.publication, PUBLICATION_PROPERTY_MAP )
    end
    populateDataFromEntity( publicationId, data.publication, PUBLICATION_PROPERTY_MAP )

    if type( data.publication.title ) == 'table' and data.publication.title[ 1 ] then
        data.publication.title = data.publication.title[ 1 ]
    end
    if type( data.publication.subtitle ) == 'table' and data.publication.subtitle[ 1 ] then
        data.publication.subtitle = data.publication.subtitle[ 1 ]
    end

    for key, value in pairs( data.publication ) do
        if key ~= 'sourceId' and key ~= 'title' and key ~= 'subtitle' and key ~= 'url' and not data[ key ] then
            data[ key ] = value
        end
    end
end

---@param data source
---@return void
local function expandBookSeries( data )
    local bookSeries = data.bookSeries
    if not bookSeries then
        return
    end

    -- use only first one
    if type( bookSeries ) == 'table' and bookSeries[ 1 ] and bookSeries[ 1 ].id then
        data.bookSeries = bookSeries[ 1 ]
        bookSeries = data.bookSeries
    end

    if not bookSeries or not bookSeries.id then
        return
    end

    appendEntitySnaks( bookSeries.id, 'P123', data, 'publisher', {} )
    appendEntitySnaks( bookSeries.id, 'P291', data, 'place', {} )
    appendEntitySnaks( bookSeries.id, 'P236', data, 'issn', {} )
end

---@param entityId string
---@return string | nil
local function getNormativeTitle( entityId )
    local possibleTypeIds = {}
    for typeId, _ in pairs( NORMATIVE_DOCUMENTS ) do
        table.insert( possibleTypeIds, typeId )
    end

    local foundTypeId = getFirstType( entityId, possibleTypeIds )
    if foundTypeId then
        return NORMATIVE_DOCUMENTS[ foundTypeId ]
    end

    return nil
end

---@param urls table&lt;number, string&gt; | string
---@param text string
---@return string
local function wrapInUrl( urls, text )
    local url = getSingle( urls )

    if string.sub( url, 1, 1 ) == ':' then
        return '[[' .. url .. '|' .. text .. ']]'
    else
        return '[' .. url .. ' ' .. text .. ']'
    end
end

---@param entityId string
---@param lang string
---@return string
local function getElementLink( entityId, lang )
    local sitelink = getSitelink( entityId, nil )
    if sitelink then
        return ':' .. sitelink
    end

    if lang ~= 'mul' then
        -- link to entity in source language
        sitelink = getSitelink( entityId, lang .. 'wiki' )
        if sitelink then
            return ':' .. lang .. ':' .. sitelink
        end
    end

    return ':d:' .. entityId
end

---@param entityId string
---@param lang string
---@return string
local function getLabel( entityId, lang )
    local wbStatus, label = pcall( mw.wikibase.getLabelByLang, entityId, lang )
    if not wbStatus then
        return ''
    end

    if label and label ~= '' then
        return label
    end

    wbStatus, label = pcall( mw.wikibase.getLabel, entityId )
    if not wbStatus then
        return ''
    end

    return label or ''
end

---@param lang string
---@param entityId string
---@param customTitle string
---@param options table
local function renderLink( lang, entityId, customTitle, options )
    if not entityId then
        error( 'entityId is not specified' )
    end
    if type( entityId ) ~= 'string' then
        error( 'entityId is not string, but ' .. type( entityId ) )
    end
    if type( customTitle or '' ) ~= 'string' then
        error( 'customTitle is not string, but ' .. type( customTitle ) )
    end

    local title = customTitle

    -- ISO 4
    if isEmpty( title ) then
        local propertyStatements = getBestStatements( entityId, 'P1160' )
        for _, claim in pairs( propertyStatements ) do
            if ( claim
                    and claim.mainsnak
                    and claim.mainsnak.datavalue
                    and claim.mainsnak.datavalue.value
                    and claim.mainsnak.datavalue.value.language == lang
            ) then
                title = claim.mainsnak.datavalue.value.text
                -- mw.log( 'Got title of ' .. entityId .. ' from ISO 4 claim: «' .. title .. '»' )
                break
            end
        end
    end

    -- official name P1448
    -- short name P1813
    if isEmpty( title ) and options.short then
        local propertyStatements = getBestStatements( entityId, 'P1813' )
        for _, claim in pairs( propertyStatements ) do
            if ( claim
                    and claim.mainsnak
                    and claim.mainsnak.datavalue
                    and claim.mainsnak.datavalue.value
                    and claim.mainsnak.datavalue.value.language == lang
            ) then
                title = claim.mainsnak.datavalue.value.text
                -- mw.log( 'Got title of ' .. entityId .. ' from short name claim: «' .. title .. '» (' .. lang .. ')' )
                break
            end
        end
    end

    -- person name P1559
    -- labels
    if isEmpty( title ) then
        title = getLabel( entityId, lang )
        -- mw.log( 'Got title of ' .. entityId .. ' from label: «' .. title .. '» (' .. lang .. ')' )
    end

    local actualText = title or '\'\'(untranslated)\'\''
    local link = getElementLink( entityId, lang )
    return wrapInUrl( link, actualText )
end

---@param lang string
---@param value value
---@param options options
---@return string
local function asString( lang, value, options )
    if type( value ) == 'string' then
        return options.format( value )
    end
    if type( value ) ~= 'table' then
        return options.format( '(unknown type)' )
    end

    if value.id then
        -- this is link
        if type( value.label or '' ) ~= 'string' then
            mw.logObject( value, 'error value' )
            error( 'label of table value is not string but ' .. type( value.label ) )
        end

        local title
        if options.preferids then
            title = value.id
        elseif options.nolinks then
            title = value.label or getLabel( value.id, lang )
        else
            title = renderLink( lang, value.id, value.label, options )
        end

        if title == '' then
            title = "''(untranslated title)''"
        end

        return options.format( title )
    end

    local resultList = {}
    for _, tableValue in pairs( value ) do
        table.insert( resultList, asString( lang, tableValue, options ) )
    end

    return mw.text.listToText( resultList, options.separator, options.conjunction )
end

---@param entityId string
---@param data source
---@return source
local function populateSourceDataImpl( entityId, data, map )
    local wsLink = getSitelink( entityId, 'ruwikisource' )
    if wsLink and not mw.ustring.gmatch( wsLink, 'Категория:' ) then
        data.url = ":ru:s:" .. wsLink
    end
    populateDataFromEntity( entityId, data, map )

    local normativeTitle = getNormativeTitle( entityId )
    if normativeTitle then
        local y, m, d = mw.ustring.match( getSingle( data.dateOfCreation ) , "(%-?%d+)%-(%d+)%-(%d+)T" )
        y, m, d = tonumber( y ),tonumber( m ), tonumber( d )
        local title = asString( 'ru', data.title, options_commas_nolinks )
        local docNumber = getSingle( data.docNumber )
        data.title = {
            normativeTitle ..
                    " от&amp;nbsp;" .. tostring( d ) .. "&amp;nbsp;" .. monthGen[ m ]  .. " " .. tostring( y ) .. "&amp;nbsp;г." ..
                    ( docNumber and ( " №&amp;nbsp;" .. docNumber ) or '' ) ..
                    ' «' .. title.. '»'
        }
    end

    if not data.title then
        local lang = getLangCode( data.lang ) or i18nDefaultLanguage
        local label = getLabel( entityId, lang )
        if label ~= '' then
            data.title = { label }
        end
    end

    return data
end

---@param entityId string
---@param propertyId string
---@param data source
---@return void
local function expandSpecialsQualifiers( entityId, propertyId, data )
    local statements = getBestStatements( entityId, propertyId )
    for _, statement in pairs( statements ) do
        populateDataFromSnaks( statement.qualifiers or {}, data, PROPERTY_MAP )
    end
end

---Expand special types of references when additional data could be found in OTHER entity properties
---@param data source
---@return void
local function expandSpecials( data )
    if not data.entityId then
        return
    end

    if data.sourceId == 'Q36578' then
        -- Gemeinsame Normdatei -- specified by P227
        appendEntitySnaks( data.entityId, 'P227', data, 'part', { format = function(gnd ) return 'Record #' .. gnd; end } )
        appendEntitySnaks( data.entityId, 'P227', data, 'url', { format = function(gnd ) return 'http://d-nb.info/gnd/' .. gnd .. '/'; end } )
        data.year = '2012—2016'
        expandSpecialsQualifiers( data.entityId, 'P227', data )

    elseif data.sourceId == 'Q15222191' then
        -- BNF -- specified by P268
        appendEntitySnaks( data.entityId, 'P268', data, 'part', { format = function(id ) return 'Record #' .. id; end } )
        appendEntitySnaks( data.entityId, 'P268', data, 'url', { format = function(id ) return 'http://catalogue.bnf.fr/ark:/12148/cb' .. id; end } )
        expandSpecialsQualifiers( data.entityId, 'P268', data )

    elseif data.sourceId == 'Q54919' then
        -- VIAF -- specified by P214
        appendEntitySnaks( data.entityId, 'P214', data, 'part', { format = function(id ) return 'Record #' .. id; end } )
        appendEntitySnaks( data.entityId, 'P214', data, 'url', { format = function(id ) return 'https://viaf.org/viaf/' .. id; end } )
        expandSpecialsQualifiers( data.entityId, 'P214', data )

    else
        -- generic property search
        for _, sourceClaim in pairs( getBestStatements( data.sourceId, 'P1687' ) ) do
            if sourceClaim.mainsnak.snaktype == 'value' then
                local sourcePropertyId = sourceClaim.mainsnak.datavalue.value.id
                for _, sourcePropertyClaim in pairs( getBestStatements( sourcePropertyId, 'P1630' ) ) do
                    if sourcePropertyClaim.mainsnak.snaktype == 'value' then
                        appendEntitySnaks( data.entityId, sourcePropertyId, data, 'url', {
                            format = function( id )
                                return mw.ustring.gsub( mw.ustring.gsub( sourcePropertyClaim.mainsnak.datavalue.value, '$1', id ), ' ', '%%20' )
                            end
                        } )
                        expandSpecialsQualifiers( data.entityId, sourcePropertyId, data )
                        break
                    end
                end
            end
        end
    end

    -- do we have appropriate record in P1433 ?
    local claims = findClaimsByValue( currentEntityId, 'P1343', data.sourceId )
    if claims and #claims ~= 0 then
        for _, claim in pairs( claims ) do
            populateDataFromSnaks( claim.qualifiers, data, PROPERTY_MAP )
            populateDataFromEntity( data.sourceId, data, PROPERTY_MAP )
        end
    end
end

---@param text string
---@param tip string
---@return string
local function toTextWithTip( text, tip )
    return '&lt;span title="' .. tip .. '" style="border-bottom: 1px dotted; cursor: help; white-space: nowrap"&gt;' .. text .. '&lt;/span&gt;'
end

---@param lang string
---@param placeId string
---@return string
local function getPlaceName( placeId, lang )
    -- ГОСТ Р 7.0.12—2011
    if lang == 'ru' then
        if placeId == 'Q649' then return toTextWithTip( 'М.', 'Москва' ); end
        if placeId == 'Q656' then return toTextWithTip( 'СПб.', 'Санкт-Петербург' ); end
        if placeId == 'Q891' then return toTextWithTip( 'Н. Новгород', 'Нижний Новгород' ); end
        if placeId == 'Q908' then return toTextWithTip( 'Ростов н/Д.', 'Ростов-на-Дону' ); end
    end
    return nil
end

---@param data source
---@param lang string
---@return void
local function preprocessPlace( data, lang )
    if not data.place then
        return
    end

    ---@type table&lt;number, string&gt;
    local newPlace = {}

    for index, place in pairs( data.place ) do
        if place.id then
            local newPlaceStr = getPlaceName( place.id, lang )
            if newPlaceStr then
                newPlace[ index ] = newPlaceStr
            else
                newPlace[ index ] = getLabel( place.id, lang )
            end
        else
            newPlace[ index ] = place
        end
    end

    data.place = newPlace
end

---@param entityId string
---@param lang string
---@param providedLabel string | nil
---@param options options
---@return string
local function getPersonNameAsLabel( entityId, lang, providedLabel, options )
    -- would custom label provided we don't need to check entity at all
    if not isEmpty( providedLabel ) then
        return options.format( providedLabel )
    end

    if lang == 'mul' then
        lang = i18nDefaultLanguage
    end

    ---@type string | nil
    local personName = getLabel( entityId, lang )

    if isEmpty( personName ) then
        return '\'\'(not translated to ' .. lang .. ')\'\''
    end

    if not isInstanceOf( entityId, 'Q5' ) then
        return personName
    end

    return options.format( personName )
end

---@param entityId string
---@param lang string
---@param customLabel string | nil
---@param options options
---@return string
local function getPersonNameAsWikitext( entityId, lang, customLabel, options )
    local personName = getPersonNameAsLabel( entityId, lang, customLabel, options )
    local link = getElementLink( entityId, lang )
    return wrapInUrl( link, personName )
end

---@param value value
---@param lang string
---@param options options
---@return string
local function getPeopleAsWikitext( value, lang, options )
    if type( value ) == 'string' then
        return options.format( value )
    elseif type( value ) == 'table' then
        if value.id then
            -- this is link
            if options.preferids then
                return tostring( value.id )
            else
                if options.nolinks then
                    return getPersonNameAsLabel( value.id, lang, value.label, options )
                else
                    return getPersonNameAsWikitext( value.id, lang, value.label, options )
                end
            end
        end

        local maxAuthors = 10 -- need some restrictions, as some publications have enormous amount of authors (e.g. 115 authors of Q68951544)
        local resultList = {}
        for _, tableValue in pairs( value ) do
            local nextWikitext = getPeopleAsWikitext( tableValue, lang, options )
            if not isEmpty( nextWikitext ) then
                table.insert( resultList, nextWikitext )
                if #resultList == maxAuthors + 1 then
                    -- keep one more to indicate that there are too many
                    break
                end
            end
        end

        local resultWikitext = ''
        for i, wikitext in pairs( resultList ) do
            if i == maxAuthors + 1 then
                resultWikitext = resultWikitext .. ( i18nEtAl[ lang ] or i18nEtAlDefault )
                break
            end
            if i ~= 1 then
                resultWikitext = resultWikitext .. ', '
            end
            resultWikitext = resultWikitext .. wikitext
        end

        return resultWikitext
    end

    return '' -- options.format( '(unknown type)' )
end

---@param lang string
---@param data source
---@return string
local function generateAuthorLinks( lang, data )
    local result = ''
    if data.author then
        result = getPeopleAsWikitext( data.author, lang, options_commas_authors )
        result = '&lt;i class="wef_low_priority_links"&gt;' .. result .. '&lt;/i&gt; '
    end
    return result
end

---@param lang string
---@param data source
---@param conjunction string
---@param propertyName string
---@param urlPropertyName string?
---@return string
local function appendProperty( lang, data, conjunction, propertyName, urlPropertyName )
    if not data[ propertyName ] then
        return ''
    end

    local out
    if urlPropertyName and data[ urlPropertyName ] then
        out = wrapInUrl( data[ urlPropertyName ], asString( lang, data[ propertyName ], options_commas_nolinks ) )
    else
        out = asString( lang, data[ propertyName ], options_commas )
    end

    if not out or out == '' then
        return ''
    end

    return conjunction .. out
end

---@param lang string
---@param data source
---@return string
local function appendTitle( lang, data )
    local conjunction = ''
    local result = ''

    if data.part then
        result = result .. appendProperty( lang, data, '', 'part', 'parturl' )
        conjunction = ' // '
    end

    return result .. appendProperty( lang, data, conjunction, 'title', 'url' )
end

---@param lang string
---@return string
local function appendLanguage( lang )
    if lang == i18nDefaultLanguage then
        return ''
    end

    ---@type { getRefHtml: ( fun( lang: string ): string ), list_ref: ( fun( frame: frame ): string ) }
    local langs = require( 'Module:Languages' )
    return langs.list_ref( p.currentFrame:newChild{ args = { lang } } )
end

---@param lang string
---@param data source
---@return string
local function appendSubtitle( lang, data )
    return appendProperty( lang, data, ': ', 'subtitle', nil )
end

---@param lang string
---@param data source
---@return string
local function appendOriginalTitle( lang, data )
    return appendProperty( lang, data, ' = ', 'originaltitle', nil )
end

---@param lang string
---@param data source
---@return string
local function appendPublication( lang, data )
    if not data.publication then
        return ''
    end

    local result = ' // ' .. asString( lang, data.publication.title, options_commas_it_short )
    if data.publication.subtitle and data.publication.subtitle ~= '' then
        result = result .. ': ' .. asString( lang, data.publication.subtitle, options_commas_it_short )
    end

    return result
end

---@param lang string
---@param data source
---@return string
local function appendEditor( lang, data )
    if not data.editor and not data.translator then
        return ''
    end

    local result = ' / '
    if data.editor then
        local prefix = i18nEditors[ lang ] or i18nEditors[ i18nDefaultLanguage ]
        result = result .. prefix .. getPeopleAsWikitext( data.editor, lang, options_commas_responsible )
        if data.translator then
            result = result .. ', '
        end
    end
    if data.translator then
        local prefix = i18nTranslators[ lang ] or i18nTranslators[ i18nDefaultLanguage ]
        result = result .. prefix .. getPeopleAsWikitext( data.translator, lang, options_commas_responsible )
    end

    return result
end

---@param lang string
---@param data source
local function appendEdition( lang, data )
    return appendProperty( lang, data, ' — ', 'edition', nil )
end

---@param lang string
---@param data source
---@return string
local function appendPublicationData( lang, data )
    if not data.place and not data.publisher and not data.year then
        return ''
    end

    local result = ' — '
    if data.place then
        result = result .. asString( lang, data.place, options_commas_short )
        if data.publisher or data.year then
            result = result .. ': '
        end
    end
    if data.publisher then
        result = result .. asString( lang, data.publisher, options_commas_short )
        if data.year then
            result = result .. ', '
        end
    end
    if data.year then
        result = result .. asString( lang, data.year, options_commas )
    end
    result = result .. '.'

    return result
end

---@param lang string
---@param data source
---@return string
local function appendVolumeAndIssue( lang, data )
    if not data.volume and not data.issue then
        return ''
    end

    local result = ' — '
    local letter_vol = i18nVolume[ lang ] or i18nVolume[ i18nDefaultLanguage ]
    local letter_iss = i18nIssue[ lang ] or i18nIssue[ i18nDefaultLanguage ]
    if data.volume then
        result = result .. appendProperty( lang, data, letter_vol .. '&amp;nbsp;', 'volume', nil )
        result = result ..appendProperty( lang, data, ', ' .. letter_iss .. '&amp;nbsp;', 'issue', nil )
    else
        result = result .. appendProperty( lang, data, letter_iss .. '&amp;nbsp;', 'issue', nil )
    end
    result = result .. '.'

    return result
end

---@param lang string
---@param data source
---@return string
local function appendPages( lang, data )
    if not data.pages then
        return ''
    end

    local letter = i18nPages[ lang ] or i18nPages[ i18nDefaultLanguage ]
    local strPages = asString( lang, data.pages, options_commas )
    strPages = mw.ustring.gsub( strPages, '[-—]', '—' )
    return ' — ' .. letter .. '&amp;nbsp;' .. strPages .. '.'
end

---@param lang string
---@param data source
---@return string
local function appendNumberOfPages( lang, data )
    if not data.numberOfPages then
        return ''
    end

    local letter = i18nNumberOfPages[ lang ] or i18nNumberOfPages[ i18nDefaultLanguage ]
    return appendProperty( lang, data, ' — ', 'numberOfPages', nil ) .. '&amp;nbsp;' .. letter
end

---@param lang string
---@param data source
---@return string
local function appendBookSeries( lang, data )
    if not data.bookSeries then
        return ''
    end

    local result = appendProperty( lang, data, ' — (', 'bookSeries', nil )
    if data.bookSeriesVolume or data.bookSeriesIssue then
        result = result .. '; '
        local letter_vol = i18nVolume[ lang ] or i18nVolume[ i18nDefaultLanguage ]
        local letter_iss = i18nIssue[ lang ] or i18nIssue[ i18nDefaultLanguage ]
        if data.bookSeriesVolume then
            result = result .. appendProperty( lang, data, letter_vol .. '&amp;nbsp;', 'bookSeriesVolume', nil )
            result = result .. appendProperty( lang, data, ', ' .. letter_iss .. '&amp;nbsp;', 'bookSeriesIssue', nil )
        else
            result = result .. appendProperty( lang, data, letter_iss .. '&amp;nbsp;', 'bookSeriesIssue', nil )
        end
    end
    result = result .. ')'

    return result
end

---@param lang string
---@param data source
---@return string
local function appendTirage( lang, data )
    if not data.tirage then
        return ''
    end

    local tirageTemplate = i18nTirage[ lang ] or i18nTirage[ i18nDefaultLanguage ]
    ---@type options
    local optionsTirage = {
        separator = '; ',
        conjunction = '; ',
        format = function( _data ) return tostring( mw.ustring.format( tirageTemplate, _data ) ) end,
        short = false,
        nolinks = false,
        preferids = false,
    }
    return ' — ' .. asString( lang, data.tirage, optionsTirage )
end

---@param lang string
---@param value string | nil
---@param options options
---@param prefix string?
---@return string
local function appendIdentifier( lang, value, options, prefix )
    if not value then
        return ''
    end

    return ' — ' .. ( prefix or '' ) .. asString( lang, value, options )
end

---@param result string
---@param lang string
---@param data source
---@return string
local function wrapSourceId( result, lang, data )
    if not data.sourceId then
        return result
    end

    local citeType = data.type and asString( lang, data.type, options_citetypes ) or 'citetype_unknown'
    return '&lt;span class="wikidata_cite ' .. citeType .. '" data-entity-id="' .. data.sourceId .. '"&gt;' .. result .. '&lt;/span&gt;'
end

---@param data source
---@return string
local function appendAccessDate( data )
    if not data.accessdate then
        return ''
    end

    local date = getSingle( data.accessdate )
    local pattern = "(%-?%d+)%-(%d+)%-(%d+)T"
    local y, m, d = mw.ustring.match( date, pattern )
    y, m, d = tonumber( y ), tonumber( m ), tonumber( d )
    local date_str = ( d &gt; 0 and ' ' .. tostring( d ) or '' )
            .. ( m &gt; 0 and ' ' .. monthGen[ m ] or '' )
            .. ( y &gt; 0 and ' ' .. tostring( y ) or '' )


    return " &lt;small&gt;Проверено" .. date_str .. ".&lt;/small&gt;"
end

---@param data source
---@param lang string
---@return void
local function populateUrl( data, lang )
    if data.sourceId and not data.url then
        local sitelink = getSitelink( data.sourceId, lang .. 'wikisource' )
        if sitelink then
            data.url = ':' .. lang .. ':s:' .. sitelink
        end
    end
end

---@param data source
---@return void
local function populateYear( data )
    if not data.year and data.dateOfPublication then
        local date = getSingle( data.dateOfPublication )
        data.year = mw.ustring.sub( date, 2, 5 )
    end
    if not data.year and data.dateOfCreation then
        local date = getSingle( data.dateOfCreation )
        data.year = mw.ustring.sub( date, 2, 5 )
    end
end

---@param data source
---@return void
local function populateTitle( data )
    data.title = data.title or getSingle( data.url )
end

---@param data source
---@return string
local function renderSource( data )
    local lang = getLangCode( data.lang ) or i18nDefaultLanguage

    preprocessPlace( data, lang )
    populateUrl( data, lang )
    populateTitle( data )
    if not data.title then
        return ''
    end

    populateYear( data )

    local result = generateAuthorLinks( lang, data )
    result = result .. appendTitle( lang, data )
    result = result .. appendLanguage( lang )
    result = result .. appendSubtitle( lang, data )
    result = result .. appendOriginalTitle( lang, data )
    result = result .. appendPublication( lang, data )

    result = result .. '&lt;span class="wef_low_priority_links"&gt;'
    result = result .. appendEditor( lang, data ) -- Might take current editor instead of actual. Use with caution
    result = result .. appendEdition( lang, data )
    result = result .. appendPublicationData( lang, data )
    result = result .. appendVolumeAndIssue( lang, data )
    result = result .. appendPages( lang, data )
    result = result .. appendNumberOfPages( lang, data )
    result = result .. appendBookSeries( lang, data )
    result = result .. appendTirage( lang, data )

    result = result .. appendIdentifier( lang, data.isbn, options_commas, 'ISBN ' )
    result = result .. appendIdentifier( lang, data.issn, options_issn, 'ISSN ' )
    result = result .. appendIdentifier( lang, data.doi, options_doi, nil )
    result = result .. appendIdentifier( lang, data.pmid, options_pmid, nil )
    result = result .. appendIdentifier( lang, data.arxiv, options_arxiv, nil )
    result = result .. appendAccessDate( data )
    result = result .. '&lt;/span&gt;'

    return wrapSourceId( result, lang, data )
end

---@param data source Данные в простом формате, согласованном с модулями формирования библиографического описания
---@param snaks snaks
---@return string | nil
local function renderReferenceImpl( data, snaks )
    -- не показывать источники с "импортировано из"
    if snaks.P143 then
        return nil
    end

    -- забрать данные из reference
    populateDataFromSnaks( snaks or {}, data, PROPERTY_MAP )
    data.sourceId = getSingle( data.sourceId )
    populateDataFromEntity( data.sourceId, data, PROPERTY_MAP )

    expandSpecials( data )
    populateSourceDataImpl( data.sourceId, data, PROPERTY_MAP )

    expandPublication( data )
    expandBookSeries( data )

    if next( data ) == nil then
        return nil
    end

    local rendered = renderSource( data )
    if mw.ustring.len( rendered ) == 0 then
        return nil
    end

    if data.ref then
        local anchorValue = 'CITEREF' .. data.ref .. ( coalesce( { data[ 'ref-year' ], data.year } ) or '' )
        rendered = '&lt;span class="citation" id="' .. mw.uri.anchorEncode( anchorValue ) .. '"&gt;' .. rendered .. '&lt;/span&gt;'
    end

    return rendered
end

---@param frame frame
---@param currentEntityId string | { id: string }
---@param reference table{ snaks: snaks }
---@return string | nil
function p.renderSource( frame, currentEntityId, reference )
    reference = reference or { snaks = {} }
    p.currentFrame = frame

    local data = getFilledArgs( frame.args or {} )
    populateDataFromSnaks( reference.snaks, data, PROPERTY_MAP )
    data.sourceId = getSingle( data.sourceId )

    if not currentEntityId then
    	data.entityId = mw.wikibase.getEntityIdForCurrentPage()
    elseif type( currentEntityId ) == 'string' then
        data.entityId = currentEntityId
    elseif type( currentEntityId ) == 'table' and currentEntityId.id then
        data.entityId = currentEntityId.id
    end

    ---@type string
    local rendered = renderReferenceImpl( data, reference.snaks or {} )
    if not rendered then
        return ''
    end

    return rendered
end


---@param frame frame
---@param currentEntityId string
---@param reference table
---@return string
function p.renderReference( frame, currentEntityId, reference )
    local rendered = p.renderSource( frame, currentEntityId, reference )
    if not rendered or rendered == '' then
        return ''
    end

    -- Про выбор алгоритма хеширования см. [[Модуль:Hash]]. Знак подчёркивания в начале позволяет
    -- исключить ошибку, когда имя сноски — чисто числовое значение, каковыми иногда бывают хеши.
    return frame:extensionTag( 'ref', rendered, { name = '_' .. mw.hash.hashValue( 'fnv164', rendered ) } ) .. '[[Category:Википедия:Статьи с источниками из Викиданных]]'
end

---@param frame frame
---@return string | nil
function p.testPersonNameToAuthorName( frame )
    return personNameToAuthorName( frame.args[ 1 ] )
end

---@param frame frame
---@return string | nil
function p.testPersonNameToResponsibleName( frame )
    return personNameToResponsibleName( frame.args[ 1 ] )
end

return p</text>
      <sha1>dop7xvqa91b8yy7gqq2qr9g1x3j3g18</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:WikidataSelectors</title>
    <ns>828</ns>
    <id>5715249</id>
    <revision>
      <id>130333001</id>
      <parentid>130321031</parentid>
      <timestamp>2023-05-09T18:46:16Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>исправление метода load()</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16619" xml:space="preserve">local i18n = {
    ["errors"] = {
        ["rank-not-valid"] = "Некорретное значение приоритета (rank)",
        ["cant-parse-condition"] = "Не удалось разобрать условие"
    }
}

local validRanks = {
	'best',
	'preferred',
	'normal',
	'deprecated'
}


--[[ 
  Internal function for error message
 
  Input: key in errors table
  Output: error message
]]
local function throwError( key )
    error( i18n.errors[key] )
end


local p = {}

--[[
  Load property and filter statements
 
  Input: entityId, selector string
  Output: filtered statements table
]]
function p.load( entityId, propertySelector )
	local propertyId = mw.ustring.match( propertySelector, '^[Pp]%d+' )
	if not propertyId then
		return nil
	end
	propertyId = string.upper( propertyId )

	local allStatements = {}
	allStatements[ propertyId ] = mw.wikibase.getAllStatements( entityId, propertyId )

	return p.filter( allStatements, propertySelector )
end

--[[
  Parse selectors and filter statements
 
  Input: statements table, selector string
  Output: filtered statements table
]]
function p.filter( allClaims, propertySelector )
	propertySelector = mw.text.trim( propertySelector )

	-- Get property ID from selector
	local propertyId = mw.ustring.match( propertySelector, '^[Pp]%d+' )
	if not propertyId then
		propertyId = ''
	end
	local initPos = #propertyId + 1
	propertyId = string.upper( propertyId )
    if ( not allClaims ) then
    	return nil
    end
	local allPropertyClaims = allClaims[propertyId]
    if ( not allPropertyClaims ) then
    	return nil
    end

	-- Gathering rules
	local rules = p.matchSelectors( propertySelector, initPos )

	-- If there is no rank filter, than default rank is 'best'
	local isRanked = false
	for i, subRules in ipairs( rules ) do
		for j, rule in ipairs( subRules ) do
			if rule['type'] == 'rank' then
				isRanked = true
				break
			end
		end
	end
	if not isRanked then
		table.insert( rules, 1, { { type = 'rank', value = 'best' } } )
	end

	-- Execute rules
	allPropertyClaims = p.applyRules( allPropertyClaims, rules )

	return allPropertyClaims
end


--[[
  Match and gather selector rules
 
  Input: string with selectors rules, start position
  Output: rules table
]]
function p.matchSelectors( selectorsString, initPos )
	local rules = {}
	local rawRulePattern = '^%s*%[%s*[^%[%]]+%s*%]%s*'
	local rulePattern = '^%s*%[%s*([^%[%]]+)%s*%]%s*$'
	
	if not initPos then
		initPos = 1
	end

	local rawRule = mw.ustring.match( selectorsString, rawRulePattern, initPos )

	while rawRule do
		initPos = initPos + #rawRule
		rule = mw.ustring.match( rawRule, rulePattern )
		rule = mw.text.trim( rule )

		local subRules = mw.text.split( rule, '%s*,%s*' )
		local commands = {}
		local comm

		for i, subRule in ipairs( subRules ) do
			local isInversed = false
			if mw.ustring.match( subRule, '^!' ) then
				isInversed = true
				subRule = mw.ustring.match( subRule, '^!%s*(.+)$' )
			end

			-- p123[1]
			if mw.ustring.match( subRule, '^%d+$' ) then
				table.insert( commands, {
					type = 'position',
					value = subRule,
					inversed = isInversed
				} )
	
			-- p123[rank:preferred]
			elseif mw.ustring.match( subRule, '^rank%s*:%s*(%a+)$' ) then
				rank = mw.ustring.match( subRule, '^rank%s*:%s*(%a+)$' )
				table.insert( commands, {
					type = 'rank',
					value = rank,
					inversed = isInversed
				} )

			-- p123[language:xx]
			elseif mw.ustring.match( subRule, '^language%s*:%s*([%a%-]+)$' ) then
				value = mw.ustring.match( subRule, '^language%s*:%s*([%a%-]+)$' )
				table.insert( commands, {
					type = 'language',
					value = value,
					inversed = isInversed
				} )

			-- p123[language!:xx]
			elseif mw.ustring.match( subRule, '^language%s*!:%s*([%a%-]+)$' ) then
				value = mw.ustring.match( subRule, '^language%s*!:%s*([%a%-]+)$' )
				table.insert( commands, {
					type = 'language',
					value = value,
					inversed = not isInversed
				} )

			-- p123[min]
			elseif mw.ustring.match( subRule, '^min$' ) then
				table.insert( commands, { type = 'value_min' } )

			-- p123[max]
			elseif mw.ustring.match( subRule, '^max$' ) then
				table.insert( commands, { type = 'value_max' } )

			-- p123[min:p456]
			elseif mw.ustring.match( subRule, '^min%s*:%s*[Pp]%d+$' ) then
				value = mw.ustring.match( subRule, ':%s*([Pp]%d+)$' )
				table.insert( commands, {
					type = 'qualifier_min',
					qualifier = value
				} )

			-- p123[max:p456]
			elseif mw.ustring.match( subRule, '^max%s*:%s*[Pp]%d+$' ) then
				value = mw.ustring.match( subRule, ':%s*([Pp]%d+)$' )
				table.insert( commands, {
					type = 'qualifier_max',
					qualifier = value
				} )

			-- p123[unit:q789]
			elseif mw.ustring.match( subRule, '^unit%s*:%s*[^%[%],:]+$' ) then
				value = mw.ustring.match( subRule, ':%s*([^%[%],:]+)$' )
				table.insert( commands, {
					type = 'unit',
					value = value,
					inversed = isInversed
				} )

			-- p123[unit!:q789]
			elseif mw.ustring.match( subRule, '^unit%s*!:%s*[^%[%],:]+$' ) then
				value = mw.ustring.match( subRule, '!:%s*([^%[%],:]+)$' )
				table.insert( commands, {
					type = 'unit',
					value = value,
					inversed = not isInversed
				} )

			-- p123[p456]
			elseif mw.ustring.match( subRule, '^[Pp]%d+$' ) then
				qualifier = mw.ustring.match( subRule, '^[Pp]%d+' )
				table.insert( commands, {
					type = 'qualifier',
					qualifier = qualifier,
					value = nil,
					inversed = isInversed
				} )

			-- p123[p456:q789]
			elseif mw.ustring.match( subRule, '^[Pp]%d+%s*:%s*[^%[%],:]+$' ) then
				qualifier = mw.ustring.match( subRule, '^([Pp]%d+)%s*:?' )
				value = mw.ustring.match( subRule, ':%s*([^%[%],:]+)$' )
				table.insert( commands, {
					type = 'qualifier',
					qualifier = qualifier,
					value = value,
					inversed = isInversed
				} )

			-- p123[p456!:q789]
			elseif mw.ustring.match( subRule, '^[Pp]%d+%s*!:%s*[^%[%],:]+$' ) then
				qualifier = mw.ustring.match( subRule, '^([Pp]%d+)%s*!:?' )
				value = mw.ustring.match( subRule, '!:%s*([^%[%],:]+)$' )
				table.insert( commands, {
					type = 'qualifier',
					qualifier = qualifier,
					value = value,
					inversed = not isInversed
				} )

			-- p123[q456]
			elseif mw.ustring.match( subRule, '^[Qq]%d+$' ) then
				value = mw.ustring.match( subRule, '^[Qq]%d+' )
				table.insert( commands, {
					type = 'value',
					value = value,
					inversed = isInversed
				} )

			else
				throwError( 'cant-parse-condition' )
			end
		end

		if #commands then
			table.insert( rules, commands )

		end

		rawRule = mw.ustring.match( selectorsString, rawRulePattern, initPos )
	end
	
	return rules
end


--[[
  Intercept statements with selector rules
 
  Input: statements table, selector rules
  Output: filtered statements table
]]
function p.applyRules( claims, rules )
	for i, subRules in ipairs( rules ) do
		local newClaims = {}
		for j, rule in ipairs( subRules ) do
			if rule['type'] == 'rank' then
				table.insert( newClaims, p.filterByRank( claims, rule['value'], rule['inversed'] ) )
			elseif rule['type'] == 'language' then
				table.insert( newClaims, p.filterByLanguage( claims, rule['value'], rule['inversed'] ) )
			elseif rule['type'] == 'unit' then
				table.insert( newClaims, p.filterByUnit( claims, rule['value'], rule['inversed'] ) )
			elseif rule['type'] == 'position' then
				table.insert( newClaims, p.filterByPosition( claims, rule['value'], rule['inversed'] ) )
			elseif rule['type'] == 'qualifier' then
				table.insert( newClaims, p.filterByQualifier( claims, rule['qualifier'], rule['value'], rule['inversed'] ) )
			elseif rule['type'] == 'qualifier_min' then
				table.insert( newClaims, p.filterUtterByQualifier( claims, rule['qualifier'], true ) )
			elseif rule['type'] == 'qualifier_max' then
				table.insert( newClaims, p.filterUtterByQualifier( claims, rule['qualifier'], false ) )
			elseif rule['type'] == 'value' then
				table.insert( newClaims, p.filterByValue( claims, rule['value'], rule['inversed'] ) )
			elseif rule['type'] == 'value_min' then
				table.insert( newClaims, p.filterUtter( claims, true ) )
			elseif rule['type'] == 'value_max' then
				table.insert( newClaims, p.filterUtter( claims, false ) )
			end
		end
		claims = {}

		--[[
			Merge all claims
			TODO: It's not good
		]]
		for j, newSubClaims in ipairs( newClaims ) do
			for k, newClaim in ipairs( newSubClaims ) do
				local isNew = true
				for l, oldClaim in ipairs( claims ) do
					if oldClaim['id'] == newClaim['id'] then
						isNew = false
						break
					end
				end
				if isNew then
					table.insert( claims, newClaim )
				end
			end
		end
	end

	return claims
end


--[[
  Filter statements by rank
 
  Input: claims table, rank value, inversion
  Output: filtered statements table
]]
function p.filterByRank( claims, rank, inversed )
	if not inversed then
		inversed = false
	end

	if not rank then
		rank = 'best'
	end
	
	-- Check if rank value is valid
	local isValidRank = false
	for i, validRank in ipairs( validRanks ) do
		if rank == validRank then
			isValidRank = true
			break
		end
	end
	if not isValidRank then
		throwError( 'rank-not-valid' )
	end

	-- Find the best rank
	if rank == 'best' then
		rank = 'normal' -- default rank (don't use deprecated even if it's no more claims)

		-- If we have at least one preferred rank, mark it as best
		for i, statement in pairs( claims ) do
			if (statement.rank == 'preferred') then
				rank = 'preferred'
				break
			end
		end
	end

	local resultClaims = {};
	for i, statement in pairs( claims ) do
		if ( statement.rank == rank ) ~= inversed then
			table.insert( resultClaims, statement )
		end
	end

	return resultClaims
end


--[[
  Filter statements by language of value
 
  Input: claims table, language, inversion
  Output: filtered statements table
]]
function p.filterByLanguage( claims, language, inversed )
	if not inversed then
		inversed = false
	end

	local resultClaims = {}
	local mulStatement = {}
	for i, statement in ipairs( claims ) do
		isMatchLanguage = false
		if statement['mainsnak']
				and statement['mainsnak']['datavalue']
				and statement['mainsnak']['datavalue']['value']
				and statement['mainsnak']['datavalue']['value']['language'] then
				
			if statement['mainsnak']['datavalue']['value']['language'] == language then
				isMatchLanguage = true
			end
			if statement['mainsnak']['datavalue']['value']['language'] == 'mul' then
				mulStatement = statement
			end
		end
		if isMatchLanguage ~= inversed then
			table.insert( resultClaims, statement )
		end
	end
	
	if next(resultClaims) == nil and next(mulStatement) ~= nil then
		-- if specific language is not found, but there is Q20923490 value
		table.insert( resultClaims, mulStatement )
	end

	return resultClaims
end


--[[
  Filter statements by unit of value
 
  Input: claims table, unit, inversion
  Output: filtered statements table
]]
function p.filterByUnit( claims, unit, inversed )
	if not inversed then
		inversed = false
	end

	unit = 'http://www.wikidata.org/entity/' .. string.upper( unit )

	local resultClaims = {}
	for i, statement in ipairs( claims ) do
		isMatchUnit = false
		if statement['mainsnak']
				and statement['mainsnak']['datavalue']
				and statement['mainsnak']['datavalue']['value']
				and statement['mainsnak']['datavalue']['value']['unit']
				and statement['mainsnak']['datavalue']['value']['unit'] == unit then
			isMatchUnit = true
		end
		if isMatchUnit ~= inversed then
			table.insert( resultClaims, statement )
			break
		end
	end

	return resultClaims
end


--[[
  Filter statements by position
 
  Input: claims table, position, inversion
  Output: filtered statements table
]]
function p.filterByPosition( claims, position, inversed )
	if not inversed then
		inversed = false
	end

	local resultClaims = {};
	for statementPosition, statement in ipairs( claims ) do
		if ( statementPosition == tonumber( position ) ) ~= inversed then
			table.insert( resultClaims, statement )
			break
		end
	end

	return resultClaims
end


--[[
  Filter statements by qualifier existance or it's value
 
  Input: claims table, ID of qualifier's property, qualifier's value, inversion
  Output: filtered statements table
]]
function p.filterByQualifier( claims, qualifierId, value, inversed )
	if not inversed then
		inversed = false
	end

	qualifierId = string.upper( qualifierId )

	local resultClaims = {}
	for i, statement in ipairs( claims ) do
		if statement['qualifiers'] and statement['qualifiers'][qualifierId] then
			if value == nil then
				if ( #statement['qualifiers'][qualifierId] &gt; 0 ) ~= inversed then
					table.insert( resultClaims, statement )
				end
			else
				local isQualifierFound = false
				for j, qualifier in ipairs( statement['qualifiers'][qualifierId] ) do
					if qualifier['datavalue'] then
						local qualifierValue = qualifier['datavalue']['value']
						if qualifier['datavalue']['type'] == 'wikibase-entityid' then
							qualifierValue = qualifierValue.id
							value = string.upper( value )
						end
			
						if qualifierValue == value then
							isQualifierFound = true
							break
						end
					end
				end
				if isQualifierFound ~= inversed then
					table.insert( resultClaims, statement )
				end
			end
		elseif inversed then
			table.insert( resultClaims, statement )
		end
	end
	return resultClaims
end


--[[
  Filter statements by it's values
 
  Input: claims table, value, inversed
  Output: filtered statements table
]]
function p.filterByValue( claims, value, inversed )
	inversed = inversed or false

	local resultClaims = {}
	for i, statement in ipairs( claims ) do
		local statementValue
		if statement['mainsnak'] 
		and statement['mainsnak']['datavalue'] 
		and statement['mainsnak']['datavalue']['type']
		then 
			statementValue = statement['mainsnak']['datavalue']['value']
			if statement['mainsnak']['datavalue']['type'] == 'quantity' then
				statementValue = statementValue.amount
			end
			if statement['mainsnak']['datavalue']['type'] == 'time' then
				statementValue = statementValue.time
			end
			if statement['mainsnak']['datavalue']['type'] == 'wikibase-entityid' then
				statementValue = statementValue.id
				value = string.upper( value )
			end
		end

		if ( statementValue == value ) ~= inversed then
			table.insert( resultClaims, statement )
		end
	end

	return resultClaims
end


--[[
  Find a statement with minimum or maximum value
 
  Input: claims table, asc, inversed
  Output: filtered statements table
]]
function p.filterUtter( claims, asc, inversed )
	local resultValue = nil
	for i, statement in ipairs( claims ) do
		local statementValue
		if statement['mainsnak'] and
			statement['mainsnak']['datavalue'] and
			statement['mainsnak']['datavalue']['type']
		then
			statementValue = statement['mainsnak']['datavalue']['value']
			if statement['mainsnak']['datavalue']['type'] == 'quantity' then
				statementValue = statementValue.amount
			end
			if statement['mainsnak']['datavalue']['type'] == 'time' then
				statementValue = statementValue.time
			end
			if statement['mainsnak']['datavalue']['type'] == 'wikibase-entityid' then
				statementValue = statementValue.id
			end

			if not resultValue or ( statementValue &lt; resultValue ) == asc then
				resultValue = statementValue
			end
		end
	end

	mw.logObject( resultValue, 'resultValue' )
	return p.filterByValue( claims, resultValue, inversed )
end


--[[
  Find a statement with minimum or maximum qualifier value
 
  Input: claims table, qualifierId, asc
  Output: filtered statements table
]]
function p.filterUtterByQualifier( claims, qualifierId, asc )
	qualifierId = string.upper( qualifierId )

	local resultValue = nil
	local resultStatement = nil
	for i, statement in ipairs( claims ) do
		if not statement['qualifiers'] and not statement['qualifiers'][qualifierId] then
			if resultStatement == nil then
				resultStatement = statement
			end
		else
			for _, qualifier in ipairs( statement['qualifiers'][qualifierId] ) do
				if qualifier['datavalue'] then
					local qualifierValue = qualifier['datavalue']['value']
					if qualifier['datavalue']['type'] == 'quantity' then
						qualifierValue = qualifierValue.amount
					end
					if qualifier['datavalue']['type'] == 'time' then
						qualifierValue = qualifierValue.time
					end
					if qualifier['datavalue']['type'] == 'wikibase-entityid' then
						qualifierValue = qualifierValue.id
					end

					if not resultValue or ( qualifierValue &lt; resultValue ) == asc then
						resultStatement = statement
						resultValue = qualifierValue
					end
				end
			end
		end
	end

	return { resultStatement }
end


return p</text>
      <sha1>1dxp0wo0q6562afoqdn8y9um3ufb2io</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Wikidata/config</title>
    <ns>828</ns>
    <id>6724517</id>
    <revision>
      <id>137323090</id>
      <parentid>137323067</parentid>
      <timestamp>2024-04-18T14:43:27Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <minor/>
      <comment>[[ВП:Откат|откат]] правок [[Special:Contribs/Stjn|Stjn]] ([[UT:Stjn|обс.]]) к версии Ghuron</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17330" xml:space="preserve">-- Property configuration for Wikidata module
return {
	global = {
		separator = ',&amp;#32;',
		conjunction = '&amp;#32;и&amp;#32;',
	},
	presets = {
		['catonly'] = {
			datatype = 'wikibase-item',
			conjunction = '',
			invisible = true,
			['value-module'] = 'Wikidata/item',
			['value-function'] = 'formatCategoryOnly',
			references = '',
			category = 'P910',
		},
		['country'] = {
			datatype = 'wikibase-item',
			['claim-module'] = 'Wikidata/Places',
			['claim-function'] = 'formatCountryClaimWithFlag',
			before = '&lt;ul&gt;&lt;li&gt;',
			separator = '&lt;/li&gt;&lt;li&gt;',
			conjunction = '&lt;/li&gt;&lt;li&gt;',
			after = '&lt;/li&gt;&lt;/ul&gt;',
		},
		['from-to'] = {
			datatype = 'time',
			['property-module'] = 'Wikidata/date',
			['property-function'] = 'formatDateIntervalProperty',
		},
		['link'] = {
			['value-module'] = 'Wikidata/link',
			['value-function'] = 'fromModule',
		},
		['list'] = {
			before = '&lt;ul&gt;&lt;li&gt;',
			separator = '&lt;/li&gt;&lt;li&gt;',
			conjunction = '&lt;/li&gt;&lt;li&gt;',
			after = '&lt;/li&gt;&lt;/ul&gt;',
		},
		['name'] = {
			datatype = 'monolingualtext',
			monolingualLangTemplate = 'lang',
			separator = '&lt;br&gt;',
			conjunction = '&lt;br&gt;',
		},
		['place'] = {
			datatype = 'wikibase-item',
			['claim-module'] = 'Wikidata/Places',
			['claim-function'] = 'formatPlaceWithQualifiers',
			before = '&lt;ul&gt;&lt;li&gt;',
			separator = '&lt;/li&gt;&lt;li&gt;',
			conjunction = '&lt;/li&gt;&lt;li&gt;',
			after = '&lt;/li&gt;&lt;/ul&gt;',
		},
		['quantity (date)'] = {
			datatype = 'quantity',
			before = '&lt;ul&gt;&lt;li&gt;',
			separator = '&lt;/li&gt;&lt;li&gt;',
			conjunction = '&lt;/li&gt;&lt;li&gt;',
			after = '&lt;/li&gt;&lt;/ul&gt;',
			qualifier = 'P585',
		},
	},
	datatypes = {
		commonsMedia = {
			limit = 1,
			references = false,
			size = '274x400px',
			separator = '&lt;br&gt;',
			conjunction = '&lt;br&gt;',
			somevalue = '',
			['value-module'] = 'Wikidata/media',
			['value-function'] = 'formatCommonsMediaValue',
		},
		['external-id'] = {
			references = false,
		},
		['globe-coordinate'] = {
			limit = 1,
			references = false,
		},
		url = {
			separator = '&lt;br&gt;',
			conjunction = '&lt;br&gt;',
			references = false,
			['value-module'] = 'Wikidata/url',
			['value-function'] = 'formatUrlValue',
		},
		quantity = {
			siConversion = true
		}
	},
	properties = {
		P6 = { datatype = 'wikibase-item', },
		P17 = {
			preset = 'country',
		},
		P18 = { 
			datatype = 'commonsMedia', 
			fixdouble = true,
		},
		P19 = {
			preset = 'place',
			separator = ',&lt;/li&gt;&lt;li&gt;',
			conjunction = ' или &lt;/li&gt;&lt;li&gt;',
		},
		P20 = {
			preset = 'place',
			separator = ',&lt;/li&gt;&lt;li&gt;',
			conjunction = ' или &lt;/li&gt;&lt;li&gt;',
		},
		P22 = {
			datatype = 'wikibase-item',
			conjunction = ' или '
		},
		P25 = {
			datatype = 'wikibase-item',
			conjunction = ' или '
		},
		P26 = { datatype = 'wikibase-item', },
		P27 = {
			preset = 'country',
		},
		P31 = { 
			datatype = 'wikibase-item',
			references = false,
		},
		P37 = { datatype = 'wikibase-item', },
		P39 = {
			datatype = 'wikibase-item',
			['claim-module'] = 'Wikidata/positions',
			['claim-function'] = 'formatPositionClaim',
			separator = '',
			conjunction = '',
			allowTables = true,
		},
		P40 = { datatype = 'wikibase-item', },
		P41 = {
			datatype = 'commonsMedia',
			size = '150x200px',
		},
		P53 = {
			datatype = 'wikibase-item',
			category = 'P910',
		},
		P54 = {
			category = 'P6112',
		},
		P57 = {
			datatype = 'wikibase-item',
			preset = 'list',
		},
		P58 = {
			datatype = 'wikibase-item',
			preset = 'list',
		},
		P59 = {
			datatype = 'wikibase-item',
			category = 'P910',
			references = false,
		},
		P69 = {
			datatype = 'wikibase-item',
			preset = 'list',
			category = 'P3876',
			qualifier = 'P582',
		},
		P94 = {
			datatype = 'commonsMedia',
			size = '100x200px',
		},
		P86 = {
			datatype = 'wikibase-item',
			preset = 'list',
		},
		P101 = { datatype = 'wikibase-item', },
		P102 = { 
			datatype = 'wikibase-item', 
			preset = 'list',
			qualifier = 'P582',
			category = 'P6365',
		},
		P103 = { datatype = 'wikibase-item', },
		P106 = {
			datatype = 'wikibase-item',
			['claim-module'] = 'Wikidata/item',
			['claim-function'] = 'formatEntityWithGenderClaim',
			conjunction = ',&amp;#32;',
		},
		P108 = {
			datatype = 'wikibase-item',
			preset = 'list',
			category = 'P4195',
		},
		P109 = {
			datatype = 'commonsMedia',
			size = '150x150px',
			alt = 'Изображение автографа',
		},
		P117 = {
			datatype = 'commonsMedia',
			size = '290x300px',
			alt = 'Изображение химической структуры',
		},
		P119 = {
			preset = 'place',
			thisLocationOnly = 'true',
		},
		P131 = { datatype = 'wikibase-item', },
		P140 = {
			datatype = 'wikibase-item',
		},
		P154 = {
			size = '220x80px',
			alt = 'Изображение логотипа',
		},
		P159 = {
			preset = 'place',
		},
		P161 = {
			preset = 'list',
		},
		P162 = {
			preset = 'list',
		},
		P163 = { datatype = 'wikibase-item', },
		P166 = {
			datatype = 'wikibase-item',
			['property-module'] = 'Wikidata/Medals',
			['property-function'] = 'formatProperty',
			['value-module'] = 'Wikidata/Medals',
			['value-function'] = 'formatValue',
			before = '&lt;div style="text-align:justify"&gt;',
			after = '&lt;/div&gt;',
			separator = '&amp;#32;',
			conjunction = '&amp;#32;',
			references = false,
			allowTables = true,
		},
		P190 = { datatype = 'wikibase-item', },
		P212 = {
			preset = 'link',
		},
		P225 = {
			preset = 'list',
			['claim-module'] = 'Wikidata/Biology',
			['claim-function'] = 'formatTaxonNameClaim',
		},
		P237 = { datatype = 'wikibase-item', },
		P241 = { datatype = 'wikibase-item', },
		P242 = {
			datatype = 'commonsMedia',
			size = '300x300px',
		},
		P247 = {
			formatter = 'https://nssdc.gsfc.nasa.gov/nmc/spacecraft/display.action?id=$1',
		},
		P267 = {
			preset = 'link',
		},
		P276 = {
			preset = 'place',
		},	
		P281 = { datatype = 'string', },
		P286 = {
			preset = 'list',
		},
		P296 = {
			formatter = 'http://osm.sbin.ru/esr/esr:$1',
		},
		P301 = {
			rawArticle = true,
		},
		P344 = {
			preset = 'list',
		},
		P345 = {
			preset = 'link',
		},
		P348 = {
			preset = 'list',
			['property-module'] = 'Wikidata/Software',
			['property-function'] = 'formatVersionProperty',
		},
		P361 = { datatype = 'wikibase-item', },
		P373 = {
			datatype = 'string',
			['value-module'] = 'Wikidata/media',
			['value-function'] = 'formatCommonsCategory',
			limit = 1,
		},
		P374 = { datatype = 'external-id', },
		P395 = { datatype = 'string', },
		P407 = { datatype = 'wikibase-item', },
		P410 = { datatype = 'wikibase-item', },
		P412 = {
			datatype = 'wikibase-item',
			category = 'P910',
		},
		P413 = {
			datatype = 'wikibase-item',
			['claim-module'] = 'Wikidata/item',
			['claim-function'] = 'formatEntityWithGenderClaim',
			conjunction = ',&amp;#32;',
			category = 'P910',
		},
		P414 = {
			['claim-module'] = 'Wikidata/item',
			['claim-function'] = 'applyDefaultTemplate',
		},
		P421 = { datatype = 'wikibase-item', },
		P473 = { datatype = 'string', },
		P495 = {
			preset = 'country',
		},
		P505 = {
			preset = 'list',
		},
		P512 = {
			datatype = 'wikibase-item',
			['property-module'] = 'Wikidata/P512',
			['property-function'] = 'formatAcademicDegree',
		},
		P527 = {
			preset = 'list',
		},
		P528 = {
			references = false,
			qualifier = 'P972',
		},
		P551 = {
			preset = 'place',
		},
		P569 = {
			datatype = 'time',
			['claim-module'] = 'Wikidata/date',
			['claim-function'] = 'formatDateOfBirthClaim',
		},
		P570 = {
			datatype = 'time',
			['claim-module'] = 'Wikidata/date',
			['claim-function'] = 'formatDateOfDeathClaim',
		},
		P571 = { datatype = 'time', },
		P576 = { datatype = 'time', },
		P598 = { datatype = 'wikibase-item', },
		P607 = {
			datatype = 'wikibase-item',
			preset = 'list',
		},
		P625 = { datatype = 'globe-coordinate', },
		P669 = {
			qualifier = 'P670',
		},
		P685 = {
			formatter = 'https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=Info&amp;id=$1',
		},
		P721 = {
			preset = 'link',
		},
		P764 = {
			preset = 'link',
		},
		P803 = { datatype = 'wikibase-item', },
		P856 = { datatype = 'url', },
		P881 = {
			novalue = 'нет',
			category = 'P910',
		},
		P884 = {
			preset = 'link',
		},
		P915 = {
			category = 'P1740',
		},
		P957 = {
			preset = 'link',
		},
		P972 = {
			preset = 'catonly',	
		},
		P1077 = {
			preset = 'link',
		},
		P1082 = {
			preset = 'quantity (date)',
			unit = 'чел.',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator'
		},
		P1098 = {
			preset = 'quantity (date)',
			unit = 'чел.',
		},
		P1120 = {
			preset = 'quantity (date)',
			unit = 'чел.',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator'
		},
		P1128 = {
			datatype = 'quantity',
			preset = 'quantity (date)',
			unit = 'чел.',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator'
		},
		P1114 = {
			datatype = 'quantity',
			qualifier = 'P585',
		},
		P1174 = {
			preset = 'quantity (date)',
			unit = 'чел.',
		},
		P1195 = {
			['value-module'] = 'Wikidata/Software',
			['value-function'] = 'formatExtension',
			conjunction = ' или ',
		},
		P1215 = {
			datatype = 'quantity',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatVisualMagnitude'
		},
		P1246 = {
			preset = 'link',
		},
		P1249 = { datatype = 'time', },
		P1352 = { preset = 'quantity (date)', },
		P1376 = { datatype = 'wikibase-item', },
		P1402 = {
			preset = 'link',
		},
		P1448 = {
			preset = 'name',
		},
		P1458 = {
			datatype = 'quantity',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatColorIndex'
		},
		P1464 = { datatype = 'wikibase-item', },
		P1476 = {
			preset = 'name',
		},
		P1477 = {
			preset = 'name',
		},
		P1532 = {
			preset = 'country',
			rank = '[rank:normal, rank:preferred]',
		},
		P1543 = {
			datatype = 'commonsMedia',
		},
		P1559 = {
			preset = 'name',
		},
		P1603 = {
			preset = 'quantity (date)',
			unit = 'чел.',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator'
		},
		P1621 = {
			size = '300x300px',
		},
		P1692 = {
            preset = 'link',
        },
		P1705 = {
			preset = 'name',
		},
		P1753 = {
			rowArticle = true,
		},
		P1809 = {
			preset = 'list',
		},
		P1846 = { 
			datatype = 'commonsMedia', 
			fixdouble = true,
		},
		P2031 = {
			preset = 'from-to',
			to = 'P2032',
			within = 'P570',
		},
		P2043 = {
			preset = 'quantity (date)',
		},
		P2044 = { datatype = 'quantity', },
		P2046 = {
			preset = 'quantity (date)',
			siConversion = false,
		},
		P2047 = {
			siConversion = false,
		},
		P2048 = {
			conjunction = '&amp;#32;или&amp;#32;',
		},
		P2060 = {
			siConversion = false,
		},
		P2097 = {
			siConversion = false,
		},
		P2120 = {
			siConversion = false,
		},
		P2137 = {
			preset = 'quantity (date)',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator',
			countByThousands = true,
		},
		P2139 = {
			preset = 'quantity (date)',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator',
			countByThousands = true,
		},
		P2146 = {
			siConversion = false,
		},
		P2214 = {
			siConversion = false
		},
		P2226 = {
			preset = 'quantity (date)',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator',
			countByThousands = true,
		},	
		P2257 = {
			siConversion = false
		},	
		P2260 = {
			siConversion = false
		},
		P2295 = {
			preset = 'quantity (date)',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator',
			countByThousands = true,
		},
		P2324 = {
			datatype = 'quantity',
			preset = 'quantity (date)',
			unit = 'чел.'	
		},
		P2403 = {
			preset = 'quantity (date)',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator',
			countByThousands = true,
		},
		P2425 = {
			alt = 'Изображение орденской планки',
		},
		P2583 = {
			siConversion = false,
		},
		P2597 = {
			preset = 'catonly',
		},
		P2650 = { datatype = 'wikibase-item', },
		P2789 = {
			preset = 'list',
		},
		P2896 = {
			siConversion = false,
		},
		P2910 = {
			size = '100x80px',
		},
		P3083 = {
			formatter = 'http://simbad.u-strasbg.fr/simbad/sim-id?Ident=$1',
		},	
		P3086 = {
			siConversion = false,
		},
		P3362 = {
			preset = 'quantity (date)',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator',
			countByThousands = true,
		},
		P4614 = {
			category = 'P1200',
		},
		P5348 = {
			siConversion = false,
		},
		P6257 = {
			['value-module'] = 'Wikidata/number',
			['value-function'] = 'formatRA',
		},
		P6258 = {
			['value-module'] = 'Wikidata/number',
			['value-function'] = 'formatDMS',
		},
		P6259 = {
			['references'] = false,
		},
		P7584 = {
			siConversion = false,
		},
		P8010 = {
			datatype = 'quantity',
			preset = 'quantity (date)',
			unit = 'чел.',
			['property-module'] = 'Wikidata/number',
			['property-function'] = 'formatPropertyWithMostRecentClaimAndIndicator'
		},
		P8224 = {
			alt = 'Изображение молекулярной модели',
		},
	},
	categories = {
		['links-to-entities-with-missing-label'] = 'Википедия:Статьи со ссылками на элементы Викиданных без подписи',
		['links-to-entities-with-wikibase-error'] = 'Википедия:Страницы с ошибками скриптов, использующих Викиданные',
		['links-to-entities-with-missing-local-language-label'] = 'Википедия:Статьи со ссылками на элементы Викиданных без русской подписи',
		['media-contains-local-caption'] = 'Википедия:Локальная подпись у изображения из Викиданных',
		['media-contains-markup'] = 'Википедия:Статьи с вики-разметкой в изображении карточки',
		['media-contains-local-double'] = 'Википедия:Изображение в статье дублирует изображение в карточке',
		['value-contains-table'] = 'Википедия:Статьи с табличной вставкой в карточке',
	},
	errors = {
		['property-param-not-provided'] = 'Не дан параметр свойства',
		['entity-not-found'] = 'Сущность не найдена.',
		['unknown-claim-type'] = 'Неизвестный тип заявления.',
		['unknown-snak-type'] = 'Неизвестный тип снэка.',
		['unknown-datavalue-type'] = 'Неизвестный тип значения данных.',
		['unknown-entity-type'] = 'Неизвестный тип сущности.',
		['unknown-property-module'] = 'Вы должны установить и property-module, и property-function.',
		['unknown-claim-module'] = 'Вы должны установить и claim-module, и claim-function.',
		['unknown-value-module'] = 'Вы должны установить и value-module, и value-function.',
		['property-module-not-found'] = 'Модуль для отображения свойства не найден',
		['property-function-not-found'] = 'Функция для отображения свойства не найдена',
		['claim-module-not-found'] = 'Модуль для отображения утверждения не найден.',
		['claim-function-not-found'] = 'Функция для отображения утверждения не найдена.',
		['value-module-not-found'] = 'Модуль для отображения значения не найден.',
		['value-function-not-found'] = 'Функция для отображения значения не найдена.',
	},
	i18n = {
		somevalue = "''неизвестно''",
		novalue = '',
		-- Обстоятельства источника
		Q5727902 = 'около ',
		Q18122778 = '&lt;span style="border-bottom: 1px dotted; cursor: help;" title="предположительно"&gt;предп.&lt;/span&gt; ',
		Q30230067 = 'возможно ',
		Q52834024 = '&lt;span style="border-bottom: 1px dotted; cursor: help;" title="менее чем"&gt;&amp;lt;&lt;/span&gt; ',
		Q54418095 = '&lt;span style="border-bottom: 1px dotted; cursor: help;" title="более чем"&gt;&amp;gt;&lt;/span&gt; ',
		thousandPowers = {'', ' тыс.', ' млн', ' млрд', ' трлн'},
	},
	deprecatedSources = {
		Q355 = true, -- Facebook
		Q36578 = true, -- Gemeinsame Normdatei
		Q63056 = true, -- Find a Grave
		Q212256 = true, -- АиФ
		Q504063 = true, -- Discogs
		Q523660 = true, -- International Music Score Library Project by https://ru.wikipedia.org/?diff=107090748
		Q1798125 = true, -- LIBRIS
		Q2621214 = true, -- Geni
		Q15222191 = true, -- BNF
		Q15241312 = true, -- Freebase
		Q19938912 = true, -- BNF
		Q21697707 = true, -- Хайазг
		Q25328680 = true, -- Prabook
		Q29861311 = true, -- SNAC
		Q86999151 = true, -- WeChangEd
	},
};</text>
      <sha1>lfrl00j6izi56hkdzrqcdy5r764xywo</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Infobox</title>
    <ns>828</ns>
    <id>7452264</id>
    <revision>
      <id>116104026</id>
      <parentid>113221900</parentid>
      <timestamp>2021-08-16T20:12:46Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>scope="colgroup" для заголовков</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3570" xml:space="preserve">local p = {};

local yesno = require('Module:Yesno')

local function _renderLine( frame, args, i )
	if args[ 'заголовок' .. i ] and args[ 'заголовок' .. i ] == '-' then
		return ''
	elseif args[ 'заголовок' .. i ] and args[ 'заголовок' .. i ] ~= '' then
		local style = ( args[ 'стиль_заголовков' ] or '' ) .. ( args[ 'стиль_заголовка' .. i ] or '' );
		local class = ( args[ 'класс' .. i ] or '' );
		return '\n&lt;tr&gt;\n&lt;th colspan="2" scope="colgroup" class="infobox-header ' .. class .. '" style="' .. style .. '"&gt;' ..
			args[ 'заголовок' .. i ] ..
			'&lt;/th&gt;\n&lt;/tr&gt;';
	end
	
	if args[ 'блок' .. i ] and args[ 'блок' .. i ] ~= '' then
		return args[ 'блок' .. i ];
	end

	local text = args[ 'текст' .. i ] or '';
	if args[ 'викиданные' .. i ] and args[ 'викиданные' .. i ] ~= '' then
		text = frame:expandTemplate{ title = 'Wikidata', args = {
			args[ 'викиданные' .. i ],
			text,
			from = args[ 'from' ] or ''
		} };
	end

    if text ~= '' then
		local label = args[ 'метка' .. i ] or '';

    	local class = args[ 'класс' .. i ] or '';
    	if string.find(class, 'noplainlist') == nil and string.find(class, 'nofirstlevel') == nil then
    		class = class .. ' plainlist';
    	end
    	if class ~= '' then
			class = ' class="' .. class .. '"';
    	end

    	local style = ( args[ 'стиль_текстов' ] or '' ) .. ( args[ 'стиль_текста' ] or '' ) .. ( args[ 'стиль_текста' .. i ] or '' );
		if label == '' then
			style = 'text-align:center;' .. style;
		end
    	if style ~= '' then
    		style = ' style="' .. style .. '"';
		end

		if label ~= '' then
	    	local labelClass = args[ 'класс_меток' ] or '';
	    	if string.find(labelClass, 'noplainlist') == nil and string.find(labelClass, 'nofirstlevel') == nil then
    			labelClass = labelClass .. ' plainlist';
			end
	    	if labelClass ~= '' then
	    		labelClass = ' class="' .. labelClass .. '"';
			end
	
	    	local labelStyle = ( args[ 'стиль_меток' ] or '' ) .. ( args[ 'стиль_метки' .. i ] or '' );
	    	if labelStyle ~= '' then
	    		labelStyle = ' style="' .. labelStyle .. '"';
			end

			return '\n&lt;tr&gt;\n&lt;th scope="row"' .. labelClass .. labelStyle .. '&gt;' .. label .. '&lt;/th&gt;' ..
	    		'\n&lt;td' .. class .. style .. '&gt;\n' .. text .. '&lt;/td&gt;\n&lt;/tr&gt;';
		end
		
	    return '\n&lt;tr&gt;\n&lt;td colspan="2"' .. class .. style .. '&gt;\n' .. text .. '&lt;/td&gt;\n&lt;/tr&gt;';
	end	    
    
	return '';
end

local function maxNumber ( args )
	local maxNumber = 0
	for argName, _ in pairs(args) do
		local argNumber = mw.ustring.match(argName, '^[^0-9]+([0-9]+)$')
		if argNumber and tonumber(argNumber) &gt; maxNumber then
			maxNumber = tonumber(argNumber)
		end
	end
	return maxNumber
end

function p.renderLine( frame )
	local args = frame:getParent().args;
	return _renderLine(frame, args, '')
end

function p.renderLines( frame )
	local args = frame:getParent().args;
	
	local res = ''
	local header, text = '', ''
	
	local autoHeaders = yesno(args [ 'автозаголовки' ] or 'false', false)
	
	for i = 1, maxNumber(args) do
		if args[ 'заголовок' .. i ] and args[ 'заголовок' .. i ] ~= '' then
			if text ~= '' or not autoHeaders then
				res = res .. header .. text
			end
			header, text = _renderLine(frame, args, i), ''
		else
			text = text .. _renderLine(frame, args, i)
		end
	end
	if text ~= '' or not autoHeaders then
		res = res .. header .. text
	end
	
	return res
end

return p;</text>
      <sha1>nduavkxg9sqiqaqjgd0eycdie28b2im</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Transclude</title>
    <ns>828</ns>
    <id>4437762</id>
    <revision>
      <id>110536814</id>
      <parentid>110371555</parentid>
      <timestamp>2020-11-17T12:38:34Z</timestamp>
      <contributor>
        <username>Wikisaurus</username>
        <id>2172652</id>
      </contributor>
      <comment>пропускать пустые параметры в forall и join</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5768" xml:space="preserve">local p={}

-- Вызывает внутренний шаблон с аргументами объемлющего шаблона
function p.call(frame)
	local template = frame.args[1]
	local args = frame:getParent().args
    return frame:expandTemplate{ title=template, args=args }
end

-- Общая реализация для forall и call
local function forallImpl(args, separator, conjunction, func)
	-- нумерованные ключи из args
	local keys = {}
	-- перебор в произвольном порядке, даже для нумерованных ключей
	for key, value in pairs(args) do
		if type(key) == 'number' and value and value ~= '' then
			table.insert(keys, key)
		end
	end
	table.sort(keys)
	
	local results = {}
	for _, key in ipairs(keys) do
		local value = func(args[key])
		table.insert(results, value)
	end
	
	return mw.text.listToText(results, separator, conjunction)
end

-- Вызывает внутренний шаблон, передавая ему нумерованные параметры объемлющего шаблона по-одному
function p.forall(frame)
	local template = frame.args[1]
	local separator = frame.args.separator or ''
	local conjunction = frame.args.conjunction or separator
	local args = frame:getParent().args
	local func = function(value)
		return frame:expandTemplate{ title = template, args = {value} } -- или другой frame?
	end
	return forallImpl(args, separator, conjunction, func)
end

-- Берёт нумерованные аргументы объемлющего шаблона и склеивает их в единую строку
function p.join(frame)
	local separator = frame.args[1] or ''
	local conjunction = frame.args[2] or separator
	local args = frame:getParent().args
	local func = function(value)
		return value
	end
	return forallImpl(args, separator, conjunction, func)
end

-- Служебная функция: удаляет дубликаты из отсортированного массива с нумерованными индексами
local function deleteDuplicates(args)
	local res = {}
	for key, value in pairs(args) do
		if args[key+1] ~= value then
			table.insert(res, value)
		end
	end
	return res
end

-- Вызывает внутренний шаблон несколько раз, передавая в него блоки аргументов объемлющего шаблона
function p.npc(frame)
	local args = frame:getParent().args
	local templateFrame = frame:getParent()
	local template = frame.args[1]
	
	-- определение, блоки аргументов с какими номерами нужны:
	-- если в объемлющем шаблоне есть "параметр12" и в вызове модуля есть "параметр", то вызывается 12-й блок
	local nums = {}
	for key, _ in pairs(args) do
		local main, num = string.match(key, '^(.-)%s*(%d*)$')
		num = tonumber(num)
		-- учитывать "параметр12", только если задано "параметр"
		if num and frame.args[main] then
			table.insert(nums, num)
		end
	end
	table.sort(nums)
	nums = deleteDuplicates(nums)
	
	-- проходить по нужным номерам блоков по возрастанию и однократно
	-- подставлять в шаблон:
	-- 1. общие аргументы данного модуля
	-- 2. аргументы объемлющего шаблона вида "параметр12" как "параметр" в 12-й блок
	local results = {}
	for _, blockNum in ipairs(nums) do
		-- общие аргументы модуля, которые передаются в каждый блок
		local blockArgs = mw.clone(frame.args)
		 -- metatable ломает expandTemplate
		setmetatable(blockArgs, nil)
		
		for key, value in pairs(args) do
			local main, num = string.match(key, '^(.-)%s*(%d*)$')
			num = tonumber(num)
			-- передавать "параметр12" как "параметр" в 12-й блок, только если есть "параметр" в вызове модуля
			if blockNum == num and frame.args[main] then
				blockArgs[main] = value
			end
		end
		
		local blockText = templateFrame:expandTemplate{ title=template; args=blockArgs }
		table.insert(results, blockText)
	end
	
    return table.concat(results)
end

-- Действует аналогично forall по числовой переменной, изменяющейся (по умолчанию, от 1) до f.args[2].
function p.cycle(f)
    local tf,ac,op=f:getParent(), {}, f.args.output or 'inline';
    local sep='';
    if op == 'newline' then
    	sep='\n';
    end
    for p,k in pairs(f.args) do
        if type(p)=='number' then
            if p&gt;2 then ac[p-1]=k end
        else ac[p]=k
        end
    end
    local s,fh = f.args[2]:match('^%s*(%-?%d+)%s*%.%.') or 1,
        f.args[2]:match('%.%.%s*(%S.*)%s*$') or f.args[2] or '';
    fh=tonumber(fh) or fh:match('^%s*(.-)%s*$');
	s=tonumber(s);
    local acr={};
    if not s then error('Начало цикла «'..s..'» — не число') end
    local function dc(order)
        local r=tf:expandTemplate{ title=f.args[1]; args={s,unpack(ac)} }
        if order == 'desc' then
        	s=s-1;
        else
        	s=s+1;
    	end
        if r~='' then table.insert(acr,r); return r end
    end
    if type(fh)=='number' then
    	if fh &gt; s then
        	while s&lt;=fh do dc('asc') end
    	else
        	while s&gt;=fh do dc('desc') end
    	end
    elseif fh~='' then
        while tf:expandTemplate{ title=fh; args={s,unpack(ac)} } do dc('asc') end
    else
        while dc('asc') do end
    end
    return table.concat(acr, sep)
end

return p</text>
      <sha1>mlnnbo1tkt1r5tqoulm2jy3q36pnhp5</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Replace</title>
    <ns>10</ns>
    <id>1912628</id>
    <revision>
      <id>137244959</id>
      <parentid>68916531</parentid>
      <timestamp>2024-04-14T07:24:11Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>обновление аналогично английскому шаблону</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="154" xml:space="preserve">{{safesubst:&lt;noinclude /&gt;#invoke:String|replace|source={{{1}}}|{{{2}}}|{{{3}}}|plain={{{plain|true}}}|count={{{count|}}}}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>dxs0z18i5b6soo8ki5ao0z3glapoa57</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Str left</title>
    <ns>10</ns>
    <id>1888392</id>
    <revision>
      <id>93909431</id>
      <parentid>24684797</parentid>
      <timestamp>2018-07-11T22:39:12Z</timestamp>
      <contributor>
        <username>A particle for world to form</username>
        <id>1086556</id>
      </contributor>
      <minor/>
      <comment>Для возможности использовать подстановку.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="100" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;padleft:|{{{2|1}}}|{{{1|}}}}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>mnmwoo2hlgp212p0gypsqsghn4zwb1o</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Nobr</title>
    <ns>10</ns>
    <id>104999</id>
    <revision>
      <id>82249445</id>
      <parentid>12255715</parentid>
      <timestamp>2016-12-02T13:15:38Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <comment>используем класс nowrap</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="235" xml:space="preserve">&lt;includeonly&gt;&lt;span class="nowrap"&gt;{{{1}}}&lt;/span&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{doc}}
&lt;!-- Пожалуйста, добавляйте категории и интервики на страницу документации! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>htrdd557bdotsmgt3uon6526sqvlh0o</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:If-wikidata</title>
    <ns>10</ns>
    <id>5164640</id>
    <revision>
      <id>103315386</id>
      <parentid>78301820</parentid>
      <timestamp>2019-11-13T23:40:02Z</timestamp>
      <contributor>
        <username>Serhio Magpie</username>
        <id>144541</id>
      </contributor>
      <minor/>
      <comment>+ from</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="231" xml:space="preserve">{{#switch:{{wikidata|{{{1|}}}|{{{2|}}}|plain={{{plain|true}}}|from={{{from|}}}|somevalue={{{somevalue|}}}|novalue={{{novalue|}}}}}|значение отсутствует|={{{4|}}}|#default={{{3}}}}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>jp5qu6tm9v2451viax7iuivto7hh2a3</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Wikidata/media</title>
    <ns>828</ns>
    <id>5159468</id>
    <revision>
      <id>115460374</id>
      <parentid>112054692</parentid>
      <timestamp>2021-07-13T21:52:06Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>alt=Логотип Викисклада</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5840" xml:space="preserve">local p = {}

-- Константы
local contentLanguageCode = mw.getContentLanguage():getCode();

function p.formatCommonsCategory( context, options, value )
    local link = 'commons:Category:' .. value
    local title = value .. ' на Викискладе'
    if ( options['text'] and options['text'] ~= '' ) then
    	title = options['text']
    end

	commons = '[[' .. link .. '|' .. title .. ']]'

	--Commons icon
    if ( not options['icon'] or options['icon'] ~= '-' ) then
    	local icon_size = '15px'
    	if ( options['icon_size'] and options['icon_size'] ~= '' ) then
    		icon_size = options['icon_size']
    	end
    	commons = '[[File:Commons-logo.svg|' .. icon_size .. '|link=' .. link .. '|alt=Логотип Викисклада]] ' .. commons
    end

	--Text before and after link
    if ( options['text_before'] and options['text_before'] ~= '' ) then
    	if ( options['text_before'] ~= '-' ) then
	    	commons = options['text_before'] .. ' ' .. commons
	    end
    end

    if ( options['text_after'] and options['text_after'] ~= '' ) then
    	if ( options['text_after'] ~= '-' ) then
	    	commons =  commons .. ' ' .. options['text_after']
	    end
    end
	
    return commons
end

--[[
	Временный хак, нужно добавить config, getConfig и getCategoryByCode
	в options, чтобы они были доступны в любом месте кода.
]]
local config;
local function getCategoryByCode( code, sortkey )
	if config == nil then
		config = require( 'Module:Wikidata/config' );
	end;

	local value = config[ 'categories' ][ code ];
	if not value or value == '' then
		return '';
	end
	
	return '[[Category:' .. value .. ']]';
end

local function getCaption( context, options )
	local caption = ''
	if options.qualifiers and options.qualifiers.P2096 then
		for i, qualifier in pairs( options.qualifiers.P2096 ) do
			if ( qualifier
					and qualifier.datavalue
					and qualifier.datavalue.type == 'monolingualtext'
					and qualifier.datavalue.value
					and qualifier.datavalue.value.language == contentLanguageCode ) then
				caption = qualifier.datavalue.value.text
				break
			end
		end
	end
	if options['appendTimestamp'] and options.qualifiers and options.qualifiers.P585 and options.qualifiers.P585[1] then
		local moment = context.formatValueDefault( context, options, options.qualifiers.P585[1].datavalue )
		if not caption or caption == ''  then 
			caption = moment
		else
			caption = caption .. ', ' .. moment
		end
	end

	local localValue = '';
	if options[ 'value' ] and options[ 'value' ] ~= '' then
		localValue = options[ 'value' ];
	end
	
	local localCaption = '';
	if options[ 'caption' ] and options[ 'caption' ] ~= '' then
		localCaption = options[ 'caption' ];
	end
	
	if localValue ~= '' then
		caption = localCaption;
	end
	
	local formattedCaption = ''
	if caption ~= '' then
		formattedCaption = context.wrapQualifier( caption, 'P2096', { class = 'media-caption', style = 'display:block' } );
	end

	if localValue == '' and localCaption ~= '' then
		formattedCaption = formattedCaption .. getCategoryByCode( 'media-contains-local-caption' )
		if options.frame:preprocess('{{REVISIONID}}') == '' then
			formattedCaption = formattedCaption .. '&lt;span class="error" style="font-size:94%;"&gt;Локальная подпись не используется, потому что изображение берётся из Викиданных, см. [[Википедия:Шаблоны-карточки#Описание изображения в Викиданных|здесь]]&lt;/span&gt;'
		end
	end

	return caption, formattedCaption
end

function p.formatCommonsMediaValue( context, options, value )
	local image = value;
	local caption, formattedCaption = getCaption( context, options )
	
	if not string.find( value, '[%[%]%{%}]' ) and not string.find( value, 'UNIQ%-%-imagemap' ) then
		-- если в value не содержится викикод или imagemap, то викифицируем имя файла
		-- ищем слово imagemap в строке, потому что вставляется плейсхолдер: [[PHAB:T28213]]
		image = '[[File:' .. value .. '|frameless';
		if options[ 'border' ] and options[ 'border' ] ~= '' then
			image = image .. '|border';
		end

		local size = options[ 'size' ];
		if size and size ~= '' then
			if not string.match( size, 'px$' )
				and not string.match( size, 'пкс$' ) -- TODO: использовать перевод для языка вики
			then
				size = size .. 'px'
			end
			
			-- временно
			if string.match( size, 'pxpx' ) then
				image = '[[Категория:Википедия:Изображение с pxpx в размере]]' .. image
			end
		else
			size = fileDefaultSize;
		end
		image = image .. '|' .. size;

		if options[ 'alt' ] and options[ 'alt' ] ~= '' then
			image = image .. '|alt=' .. options[ 'alt' ];
		end
		
		if caption ~= '' then
			image = image .. '|' .. caption
		end
		image = image .. ']]';

		if formattedCaption ~= '' then
			image = image .. '&lt;br&gt;' .. formattedCaption;
		end
	else
		image = image .. formattedCaption .. getCategoryByCode( 'media-contains-markup' );
	end
	
	if options.entity and options.fixdouble then
		local page = mw.title.getCurrentTitle()
		local txt = page:getContent()
		if txt and txt:match(':' .. value) and mw.title.getCurrentTitle():inNamespace(0) then
			if options.frame:preprocess('{{REVISIONID}}') == '' then
				image = image .. '&lt;span class="error"&gt;Это изображение встречается ниже по тексту статьи; пожалуйста, уберите одну из копий (не потеряв при этом подпись)&lt;/span&gt;'
			end
			image = image .. getCategoryByCode( 'media-contains-local-double' )
		end
	end
	
	return image
end

return p</text>
      <sha1>rlcoty78d475ab6sckmskkruimop1ki</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Join</title>
    <ns>10</ns>
    <id>129247</id>
    <revision>
      <id>93298068</id>
      <parentid>17727276</parentid>
      <timestamp>2018-06-13T14:41:38Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <comment>перевод на модуль</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="246" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:Separated entries|main|separator={{{separator|}}}}}&lt;noinclude&gt;
{{doc}}
&lt;!-- Категории — на подстраницу /doc, интервики — в Викиданные. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>h516ekw9pw40kymelieep4367qx07g0</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Color contrast</title>
    <ns>828</ns>
    <id>6445846</id>
    <revision>
      <id>112704044</id>
      <parentid>106930656</parentid>
      <timestamp>2021-03-01T22:40:23Z</timestamp>
      <contributor>
        <username>Grain of sand</username>
        <id>1731654</id>
      </contributor>
      <comment>local</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5685" xml:space="preserve">--
-- This module implements 
--  {{Color contrast ratio}}
--  {{Greater color contrast ratio}}
--  {{ColorToLum}}
--  {{RGBColorToLum}}
--
local p = {}
local HTMLcolor = mw.loadData( 'Module:Color contrast/colors' )

local function sRGB ( v ) 
	if (v &lt;= 0.03928) then 
		v = v / 12.92
	else
		v = math.pow((v+0.055)/1.055, 2.4)
	end
	return v
end

local function rgbdec2lum( R, G, B )
	if ( 0 &lt;= R and R &lt; 256 and 0 &lt;= G and G &lt; 256 and 0 &lt;= B and B &lt; 256 ) then
		return 0.2126 * sRGB(R/255) + 0.7152 * sRGB(G/255) + 0.0722 * sRGB(B/255)
	else
		return ''
	end
end

local function hsl2lum( h, s, l )
	if ( 0 &lt;= h and h &lt; 360 and 0 &lt;= s and s &lt;= 1 and 0 &lt;= l and l &lt;= 1 ) then
		local c = (1 - math.abs(2*l - 1))*s
		local x = c*(1 - math.abs( math.fmod(h/60, 2) - 1) )
		local m = l - c/2

		local r, g, b = m, m, m
		if( 0 &lt;= h and h &lt; 60 ) then
			r = r + c
			g = g + x
		elseif( 60 &lt;= h and h &lt; 120 ) then
			r = r + x
			g = g + c
		elseif( 120 &lt;= h and h &lt; 180 ) then
			g = g + c
			b = b + x
		elseif( 180 &lt;= h and h &lt; 240 ) then
			g = g + x
			b = b + c
		elseif( 240 &lt;= h and h &lt; 300 ) then
			r = r + x
			b = b + c
		elseif( 300 &lt;= h and h &lt; 360 ) then
			r = r + c
			b = b + x
		end
		return rgbdec2lum(255*r, 255*g, 255*b)
	else
		return ''
	end
end

local function color2lum( c )

	if (c == nil) then
		return ''
	end
	-- whitespace
	c = c:match( '^%s*(.-)[%s;]*$' )

	-- lowercase
	c = c:lower()

	-- first try to look it up
	local L = HTMLcolor[c]
	if (L ~= nil) then
		return L
	end

   	-- convert from hsl
   	if mw.ustring.match(c,'^hsl%([%s]*[0-9][0-9%.]*[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*%)$') then
		local h, s, l = mw.ustring.match(c,'^hsl%([%s]*([0-9][0-9%.]*)[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*%)$')
		return hsl2lum(tonumber(h), tonumber(s)/100, tonumber(l)/100)
   	end

   	-- convert from rgb
   	if mw.ustring.match(c,'^rgb%([%s]*[0-9][0-9]*[%s]*,[%s]*[0-9][0-9]*[%s]*,[%s]*[0-9][0-9]*[%s]*%)$') then
		local R, G, B = mw.ustring.match(c,'^rgb%([%s]*([0-9][0-9]*)[%s]*,[%s]*([0-9][0-9]*)[%s]*,[%s]*([0-9][0-9]*)[%s]*%)$')
		return rgbdec2lum(tonumber(R), tonumber(G), tonumber(B))
   	end

   	-- convert from rgb percent
   	if mw.ustring.match(c,'^rgb%([%s]*[0-9][0-9%.]*%%[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*,[%s]*[0-9][0-9%.]*%%[%s]*%)$') then
		local R, G, B = mw.ustring.match(c,'^rgb%([%s]*([0-9][0-9%.]*)%%[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*,[%s]*([0-9][0-9%.]*)%%[%s]*%)$')
		return rgbdec2lum(255*tonumber(R)/100, 255*tonumber(G)/100, 255*tonumber(B)/100)
   	end

	-- remove leading # (if there is one) and whitespace
	c = mw.ustring.match(c, '^[%s#]*([a-f0-9]*)[%s]*$')

	-- split into rgb
	local cs = mw.text.split(c or '', '')
	if( #cs == 6 ) then
		local R = 16*tonumber('0x' .. cs[1]) + tonumber('0x' .. cs[2])
		local G = 16*tonumber('0x' .. cs[3]) + tonumber('0x' .. cs[4])
		local B = 16*tonumber('0x' .. cs[5]) + tonumber('0x' .. cs[6])

		return rgbdec2lum(R, G, B)
	elseif ( #cs == 3 ) then
		local R = 16*tonumber('0x' .. cs[1]) + tonumber('0x' .. cs[1])
		local G = 16*tonumber('0x' .. cs[2]) + tonumber('0x' .. cs[2])
		local B = 16*tonumber('0x' .. cs[3]) + tonumber('0x' .. cs[3])

		return rgbdec2lum(R, G, B)
	end

	-- failure, return blank
	return ''
end

function p._greatercontrast(args)
	local bias = tonumber(args['bias'] or '0') or 0
	local v1 = color2lum(args[1] or '')
	local c2 = args[2] or '#FFFFFF'
	local v2 = color2lum(c2)
	local c3 = args[3] or '#000000'
	local v3 = color2lum(c3)
	local ratio1 = 0;
	local ratio2 = 0;
	if (type(v1) == 'number' and type(v2) == 'number') then
		ratio1 = (v2 + 0.05)/(v1 + 0.05)
		ratio1 = (ratio1 &lt; 1) and 1/ratio1 or ratio1
	end
	if (type(v1) == 'number' and type(v3) == 'number') then
		ratio2 = (v3 + 0.05)/(v1 + 0.05)
		ratio2 = (ratio2 &lt; 1) and 1/ratio2 or ratio2
	end
	return (ratio1 + bias &gt; ratio2) and c2 or c3
end

function p._ratio(args)
	local v1 = color2lum(mw.text.unstripNoWiki(args[1] or ''))
	local v2 = color2lum(mw.text.unstripNoWiki(args[2] or ''))
	if (type(v1) == 'number' and type(v2) == 'number') then
		-- v1 should be the brighter of the two.
		if v2 &gt; v1 then
			v1, v2 = v2, v1
		end
		return (v1 + 0.05)/(v2 + 0.05)
	else
		return args['error'] or '?'
	end
end

function p._styleratio(args)
	local style = (args[1] or ''):lower()
	local bg, fg = 'white', '#202122'
	local lum_bg, lum_fg = 1, 0.016

	if args[2] then
		local lum = color2lum(args[2])
		if lum ~= '' then bg, lum_bg = args[2], lum end
	end
	if args[3] then
		local lum = color2lum(args[3])
		if lum ~= '' then fg, lum_fg = args[3], lum end
	end

	local slist = mw.text.split(style or '', ';')
	for k = 1, #slist do
		local s = slist[k]
		local k, v = s:match( '^[%s]*([^:]-):([^:]-)[%s;]*$' )
		k = k or ''
		v = v or ''
		if (k:match('^[%s]*(background)[%s]*$') or k:match('^[%s]*(background%-color)[%s]*$')) then
			local lum = color2lum(v)
			if( lum ~= '' ) then bg, lum_bg = v, lum end
		elseif (k:match('^[%s]*(color)[%s]*$')) then
			local lum = color2lum(v)
			if( lum ~= '' ) then bg, lum_fg = v, lum end
		end
	end
	if lum_bg &gt; lum_fg then
		return (lum_bg + 0.05)/(lum_fg + 0.05)
	else
		return (lum_fg + 0.05)/(lum_bg + 0.05)
	end
end

function p.lum(frame)
	return color2lum(frame.args[1] or frame:getParent().args[1])
end

function p.ratio(frame)
	local args = frame.args[1] and frame.args or frame:getParent().args
	return p._ratio(args)
end

function p.styleratio(frame)
	local args = frame.args[1] and frame.args or frame:getParent().args
	return p._styleratio(args)
end

function p.greatercontrast(frame)
	local args = frame.args[1] and frame.args or frame:getParent().args
	return p._greatercontrast(args)
end

return p</text>
      <sha1>nxmptff3q0n8533kh85f0cyo0ypwtr6</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Color contrast/colors</title>
    <ns>828</ns>
    <id>6445847</id>
    <revision>
      <id>79068076</id>
      <parentid>79044891</parentid>
      <timestamp>2016-06-19T09:05:16Z</timestamp>
      <contributor>
        <username>Dima st bk</username>
        <id>731940</id>
      </contributor>
      <minor/>
      <comment>Защищена Модуль:Color contrast/colors: критический шаблон ([Редактирование=только администраторы] (бессрочно) [Переименование=только администрато…</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6119" xml:space="preserve">return {
	aliceblue            = 0.92880068253475,
	antiquewhite         = 0.84646951707754,
	aqua                 = 0.7874,
	aquamarine           = 0.8078549208338,
	azure                = 0.97265264954166,
	beige                = 0.8988459998705,
	bisque               = 0.80732327372979,
	black                = 0,
	blanchedalmond       = 0.85084439608156,
	blue                 = 0.0722,
	blueviolet           = 0.12622014321946,
	brown                = 0.098224287876511,
	burlywood            = 0.51559844533893,
	cadetblue            = 0.29424681085422,
	chartreuse           = 0.76032025902623,
	chocolate            = 0.23898526114557,
	coral                = 0.37017930872924,
	cornflowerblue       = 0.30318641994179,
	cornsilk             = 0.93562110372965,
	crimson              = 0.16042199953026,
	cyan                 = 0.7874,
	darkblue             = 0.018640801980939,
	darkcyan             = 0.20329317839046,
	darkgoldenrod        = 0.27264703559993,
	darkgray             = 0.39675523072563,
	darkgreen            = 0.091143429047575,
	darkgrey             = 0.39675523072563,
	darkkhaki            = 0.45747326349994,
	darkmagenta          = 0.07353047651207,
	darkolivegreen       = 0.12651920884889,
	darkorange           = 0.40016167026524,
	darkorchid           = 0.13413142174857,
	darkred              = 0.054889674531132,
	darksalmon           = 0.40541471563381,
	darkseagreen         = 0.43789249325969,
	darkslateblue        = 0.065792846227988,
	darkslategray        = 0.067608151928044,
	darkslategrey        = 0.067608151928044,
	darkturquoise        = 0.4874606277449,
	darkviolet           = 0.10999048339343,
	deeppink             = 0.23866895828276,
	deepskyblue          = 0.44481603395575,
	dimgray              = 0.14126329114027,
	dimgrey              = 0.14126329114027,
	dodgerblue           = 0.27442536991456,
	firebrick            = 0.10724525535015,
	floralwhite          = 0.95922484825004,
	forestgreen          = 0.18920812076002,
	fuchsia              = 0.2848,
	gainsboro            = 0.71569350050648,
	ghostwhite           = 0.94311261886323,
	gold                 = 0.69860877428159,
	goldenrod            = 0.41919977809569,
	gray                 = 0.2158605001139,
	green                = 0.15438342968146,
	greenyellow          = 0.80609472611453,
	grey                 = 0.2158605001139,
	honeydew             = 0.96336535554782,
	hotpink              = 0.34658438169715,
	indianred            = 0.21406134963884,
	indigo               = 0.03107561486337,
	ivory                = 0.99071270600615,
	khaki                = 0.77012343394121,
	lavender             = 0.80318750514521,
	lavenderblush        = 0.90172748631046,
	lawngreen            = 0.73905893124963,
	lemonchiffon         = 0.94038992245622,
	lightblue            = 0.63709141280807,
	lightcoral           = 0.35522120733135,
	lightcyan            = 0.94587293494829,
	lightgoldenrodyellow = 0.93348351018297,
	lightgray            = 0.65140563741982,
	lightgreen           = 0.69091979956865,
	lightgrey            = 0.65140563741982,
	lightpink            = 0.58566152734898,
	lightsalmon          = 0.4780675225206,
	lightseagreen        = 0.35050145117042,
	lightskyblue         = 0.56195637618331,
	lightslategray       = 0.23830165007287,
	lightslategrey       = 0.23830165007287,
	lightsteelblue       = 0.53983888284666,
	lightyellow          = 0.98161818392882,
	lime                 = 0.7152,
	limegreen            = 0.44571042246098,
	linen                = 0.88357340984379,
	magenta              = 0.2848,
	maroon               = 0.045891942324215,
	mediumaquamarine     = 0.49389703310801,
	mediumblue           = 0.044077780212328,
	mediumorchid         = 0.21639251153773,
	mediumpurple         = 0.22905858091648,
	mediumseagreen       = 0.34393112338131,
	mediumslateblue      = 0.20284629471622,
	mediumspringgreen    = 0.70704308194184,
	mediumturquoise      = 0.5133827926448,
	mediumvioletred      = 0.14371899849357,
	midnightblue         = 0.02071786635086,
	mintcream            = 0.97834604947588,
	mistyrose            = 0.82183047859185,
	moccasin             = 0.80083000991567,
	navajowhite          = 0.76519682342785,
	navy                 = 0.015585128108224,
	oldlace              = 0.91900633405549,
	olive                = 0.20027537200568,
	olivedrab            = 0.22593150951929,
	orange               = 0.4817026703631,
	orangered            = 0.25516243753416,
	orchid               = 0.31348806761439,
	palegoldenrod        = 0.78792647887614,
	palegreen            = 0.77936759006353,
	paleturquoise        = 0.76436077921714,
	palevioletred        = 0.28754994117889,
	papayawhip           = 0.87797100199835,
	peachpuff            = 0.74905589878251,
	peru                 = 0.30113074877936,
	pink                 = 0.63271070702466,
	plum                 = 0.45734221587969,
	powderblue           = 0.68254586500605,
	purple               = 0.061477070432439,
	rebeccapurple        = 0.07492341159447,
	red                  = 0.2126,
	rosybrown            = 0.32319457649407,
	royalblue            = 0.16663210743188,
	saddlebrown          = 0.097922285020521,
	salmon               = 0.36977241527596,
	sandybrown           = 0.46628543696283,
	seagreen             = 0.19734199706275,
	seashell             = 0.92737862206922,
	sienna               = 0.13697631337098,
	silver               = 0.52711512570581,
	skyblue              = 0.55291668518184,
	slateblue            = 0.14784278062136,
	slategray            = 0.20896704076536,
	slategrey            = 0.20896704076536,
	snow                 = 0.96533341834849,
	springgreen          = 0.73052306068529,
	steelblue            = 0.20562642207625,
	tan                  = 0.48237604163921,
	teal                 = 0.16996855778968,
	thistle              = 0.56818401093733,
	tomato               = 0.30638612719415,
	turquoise            = 0.5895536427578,
	violet               = 0.40315452986676,
	wheat                = 0.74909702820482,
	white                = 1,
	whitesmoke           = 0.91309865179342,
	yellow               = 0.9278,
	yellowgreen          = 0.50762957208707,
}</text>
      <sha1>chi69ar1btd4wp6xbk3uez6sfu0vipn</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Yesno-yes</title>
    <ns>10</ns>
    <id>7143885</id>
    <revision>
      <id>137092727</id>
      <parentid>114751470</parentid>
      <timestamp>2024-04-05T13:04:36Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>подстановка</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="161" xml:space="preserve">{{safesubst:&lt;noinclude /&gt;yesno|{{{1}}}|yes={{{yes|yes}}}|no={{{no|no}}}|blank={{{blank|yes}}}|¬={{{¬|yes}}}|def={{{def|yes}}}}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>6hp86em35ieh9b6ir0pt1mg6mmnpgtl</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/оригинал названия</title>
    <ns>10</ns>
    <id>6742439</id>
    <revision>
      <id>131455888</id>
      <parentid>131393753</parentid>
      <timestamp>2023-07-04T10:53:52Z</timestamp>
      <contributor>
        <username>Wikisaurus</username>
        <id>2172652</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="372" xml:space="preserve">{{wikidata|p1705[language!:ru]|{{{1|}}}|separator=&lt;br&gt;|conjunction=&lt;br&gt;|monolingualLangTemplate=lang|from={{{from|}}}}}&lt;!--
--&gt;{{#if:{{NAMESPACE}}||{{#if:{{{1|}}}|{{#ifeq:{{#invoke:String|find|{{{1|}}}|span}}|0|[[Категория:Википедия:Статьи с оригиналом названия без шаблона lang-XX]]}}}}}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>97dcgvzloiqcpstypwvxrrxgcmaq2dk</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Br separated entries</title>
    <ns>10</ns>
    <id>5059441</id>
    <revision>
      <id>101894070</id>
      <parentid>99840482</parentid>
      <timestamp>2019-08-30T23:08:35Z</timestamp>
      <contributor>
        <username>Ле Лой</username>
        <id>80682</id>
      </contributor>
      <minor/>
      <comment>Защитил страницу [[Шаблон:Br separated entries]]: критический шаблон или модуль ([Редактирование=только администраторы] (бессрочно) [Переименование=только администраторы] (бессрочно))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="101" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:Separated entries|br}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>3v3gtv6mrjj0gnp1u3y5dyqwa9obcv3</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/блок с маркерами</title>
    <ns>10</ns>
    <id>8091400</id>
    <revision>
      <id>117420046</id>
      <parentid>103658015</parentid>
      <timestamp>2021-10-24T15:48:39Z</timestamp>
      <contributor>
        <username>Oleg Yunakov</username>
        <id>535519</id>
      </contributor>
      <minor/>
      <comment>Защитил страницу [[Шаблон:Карточка/блок с маркерами]]: критический шаблон или модуль: https://ru.wikipedia.org/w/index.php?title=Википедия:Установка_защиты&amp;oldid=117401039#Шаблоны ([Редактирование=администраторы и инженеры] (бессрочно) [Переименование=администраторы и инженеры] (бессрочно))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="69" xml:space="preserve">{{#invoke:Infobox/bulleted block|main}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>dazmu8uyobm63gt9dcp6ks5pvfuj29k</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/блок</title>
    <ns>10</ns>
    <id>2430268</id>
    <revision>
      <id>109995382</id>
      <parentid>109986721</parentid>
      <timestamp>2020-10-20T13:56:13Z</timestamp>
      <contributor>
        <username>Wikisaurus</username>
        <id>2172652</id>
      </contributor>
      <minor/>
      <comment>Wikisaurus переименовал страницу [[Шаблон:Фрагмент таблицы]] в [[Шаблон:Карточка/блок]]: унификация с другими шаблонами для создания частей карточки</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="88" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Infobox|renderLines}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>lfdolzc3zr0ylfa1ta9t0ckunapcnlx</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Separated entries</title>
    <ns>828</ns>
    <id>6073445</id>
    <revision>
      <id>108022632</id>
      <parentid>96026335</parentid>
      <timestamp>2020-07-05T06:33:20Z</timestamp>
      <contributor>
        <username>Serhio Magpie</username>
        <id>144541</id>
      </contributor>
      <comment>+ newline</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1202" xml:space="preserve">-- This module takes positional parameters as input and concatenates them with
-- an optional separator. The final separator (the "conjunction") can be
-- specified independently, enabling natural-language lists like
-- "foo, bar, baz and qux".

local compressSparseArray = require('Module:TableTools').compressSparseArray
local p = {}

function p._main(args)
	local separator = args.separator
		-- Decode (convert to Unicode) HTML escape sequences, such as "&amp;#32;" for space.
		and mw.text.decode(args.separator) or ''
	local conjunction = args.conjunction and mw.text.decode(args.conjunction) or separator
	-- Discard named parameters.
	local values = compressSparseArray(args)
	return mw.text.listToText(values, separator, conjunction)
end

local function makeInvokeFunction(separator, conjunction)
	return function (frame)
		local args = require('Module:Arguments').getArgs(frame)
		args.separator = separator or args.separator
		args.conjunction = conjunction or args.conjunction
		return p._main(args)
	end
end

p.main = makeInvokeFunction()
p.br = makeInvokeFunction('&lt;br /&gt;')
p.newline = makeInvokeFunction('\n')
p.comma = makeInvokeFunction(mw.message.new('comma-separator'):plain())

return p</text>
      <sha1>6178uezm34f3w60alm911d9r4f04r4o</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Infobox/bulleted block</title>
    <ns>828</ns>
    <id>8111889</id>
    <revision>
      <id>117423613</id>
      <parentid>109995416</parentid>
      <timestamp>2021-10-24T18:17:22Z</timestamp>
      <contributor>
        <username>Oleg Yunakov</username>
        <id>535519</id>
      </contributor>
      <minor/>
      <comment>Защитил страницу [[Модуль:Infobox/bulleted block]]: критический шаблон или модуль: https://ru.wikipedia.org/w/index.php?title=Википедия:Установка_защиты&amp;oldid=117401039#Шаблоны ([Редактирование=администраторы и инженеры] (бессрочно) [Переименование=администраторы и инженеры] (бессрочно))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2728" xml:space="preserve">local p = {}

-- takes strings or nils; returns a string
function makeText(frame, text, wikidata, from)
	if wikidata and wikidata ~= ''then
		return frame:expandTemplate{title='Wikidata', args={wikidata, text or '', from=from or ''}}
	else
		return text or ''
	end
end

-- from [[ru:Модуль:Infobox]]
local function maxNumber ( args )
	local maxNumber = 0
	for argName, _ in pairs(args) do
		local argNumber = mw.ustring.match(argName, '^[^0-9]+([0-9]+)$')
		if argNumber and tonumber(argNumber) &gt; maxNumber then
			maxNumber = tonumber(argNumber)
		end
	end
	return maxNumber
end

function p.main(frame)
	local args = frame:getParent().args
	local maxNumberArgs = maxNumber(args)
	
	local texts = {}
	for i = 1, maxNumberArgs do
		if args['текст' .. i] then
			texts[i] = makeText(frame, args['текст' .. i], args['викиданные' .. i], args['from'])
		end
	end
	
	local textsAreEmpty = true
	for i = 1, maxNumberArgs do
		if texts[i] and texts[i] ~= '' then
			textsAreEmpty = false
		end
	end
	
	local results = {}
	if not textsAreEmpty and args['подзаголовок'] and args['подзаголовок'] ~= '' then
		results['текст1'] = args['подзаголовок']
		results['стиль_текста1'] = 'padding-bottom:0; border-bottom:0; text-align:left; font-weight:bold;'
	end
	
	local mainText = makeText(frame, args['текст'], args['викиданные'], args['from'])
	if mainText == '' and args['метка'] and args['метка'] ~= '' and not textsAreEmpty then
		mainText = '&amp;nbsp;'
	end
	
	if mainText and mainText ~= '' then
		results['метка2'] = args['метка']
		results['стиль_метки2'] = 'padding-bottom:0; border-bottom:0;'
		results['текст2'] = mainText
		results['стиль_текста2'] = 'padding-bottom:0; border-bottom:0;'
	end
	
	for i = 1, maxNumberArgs do
		if texts[i] and texts[i] ~= '' then
			results['метка' .. (i+2)] = '&amp;nbsp;•&amp;nbsp;' .. (args['метка' .. i] or '')
			results['текст' .. (i+2)] = texts[i]
			
			local last = true
			for j = i+1, maxNumberArgs do
				if texts[j] and texts[j] ~= '' then
					last = false
				end
			end
			
			if last then
				results['стиль_метки' .. (i+2)] = 'font-weight:normal; padding-top:0; border-top:0;'
				results['стиль_текста' .. (i+2)] = 'padding-top:0; border-top:0;'
			else
				results['стиль_метки' .. (i+2)] = 'font-weight:normal; padding-bottom:0; border-bottom:0; padding-top:0; border-top:0;'
				results['стиль_текста' .. (i+2)] = 'padding-bottom:0; border-bottom:0; padding-top:0; border-top:0;'
			end
		end
	end

	return frame:expandTemplate{title='Карточка/блок', args=results}
end

return p</text>
      <sha1>fl24og2whr1mr4jr3mbzrxdaptphrby</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Число</title>
    <ns>10</ns>
    <id>7660702</id>
    <revision>
      <id>131170655</id>
      <parentid>131145798</parentid>
      <timestamp>2023-06-20T10:24:09Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>лучше так тогда для лимитов</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="138" xml:space="preserve">{{formatnum: {{replace|{{{1}}}|,|.}} }}{{#if: {{{1|}}} | {{#if: {{{2|}}} | {{nobr|1=&amp;nbsp;{{{2|}}}}} }} }}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>k7fp84kjmm2vjy9akxu69xg86jle3y6</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:T</title>
    <ns>10</ns>
    <id>8060230</id>
    <redirect title="Шаблон:Tl" />
    <revision>
      <id>102837386</id>
      <timestamp>2019-10-20T16:35:32Z</timestamp>
      <contributor>
        <username>Helgo13</username>
        <id>1399880</id>
      </contributor>
      <comment>Helgo13 переименовал страницу [[Шаблон:T]] в [[Шаблон:Tl]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="51" xml:space="preserve">#перенаправление [[Шаблон:Tl]]</text>
      <sha1>mi5d6mqvhdgbthsgy55aqq0tcaq7rul</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Tl</title>
    <ns>10</ns>
    <id>3203247</id>
    <revision>
      <id>102837385</id>
      <parentid>94274419</parentid>
      <timestamp>2019-10-20T16:35:32Z</timestamp>
      <contributor>
        <username>Helgo13</username>
        <id>1399880</id>
      </contributor>
      <minor/>
      <comment>Helgo13 переименовал страницу [[Шаблон:T]] в [[Шаблон:Tl]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="95" xml:space="preserve">{{{{{|safesubst:}}}#invoke: Template call code | withoutParams }}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>bg2y2icgpjam1tfsuwwx257im6s2i53</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Wikidata/count</title>
    <ns>828</ns>
    <id>7928792</id>
    <revision>
      <id>100700347</id>
      <parentid>100638130</parentid>
      <timestamp>2019-06-29T03:57:18Z</timestamp>
      <contributor>
        <username>Dima st bk</username>
        <id>731940</id>
      </contributor>
      <minor/>
      <comment>Изменил уровень защиты [[Модуль:Wikidata/count]]: критический шаблон или модуль ([Редактирование=только администраторы] (бессрочно) [Переименование=только администраторы] (бессрочно))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="735" xml:space="preserve">local p = {}

function p.getCount( context, options )
	if ( not context ) then error( 'context not specified' ); end;
	if ( not options ) then error( 'options not specified' ); end;
	if ( not options.entity ) then error( 'options.entity missing' ); end;

	local claims;
	if options.property then -- TODO: Почему тут может не быть property?
		claims = context.selectClaims( options, options.property );
	end
	if claims == nil then
		return ''; --TODO error?
	end
	
	return table.getn(claims);
end

function p.isMultiple( context, options )
	local count = p.getCount( context, options );
	local multiple = '';
	if( count ~= nil and count ~= '' and count &gt; 1 ) then
		multiple = 1;
	end
	return multiple;
end

return p</text>
      <sha1>gg4ud6ttudpp3a1rl27vsanbczryk44</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Str sub</title>
    <ns>10</ns>
    <id>1888548</id>
    <revision>
      <id>95344739</id>
      <parentid>54717401</parentid>
      <timestamp>2018-09-29T20:45:02Z</timestamp>
      <contributor>
        <username>TenBaseT</username>
        <id>296029</id>
      </contributor>
      <comment>категории в документации</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="140" xml:space="preserve">&lt;includeonly&gt;{{{{{|safesubst:}}}#invoke:String|sublength|s={{{1}}}|i={{{2|0}}}|len={{{3|0}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>5myhlk65mbgt7nxg8501oj9uy5k2zge</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Без начала</title>
    <ns>10</ns>
    <id>2116716</id>
    <revision>
      <id>93909380</id>
      <parentid>86920822</parentid>
      <timestamp>2018-07-11T22:30:39Z</timestamp>
      <contributor>
        <username>A particle for world to form</username>
        <id>1086556</id>
      </contributor>
      <minor/>
      <comment>Для возможности использовать подстановку.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="425" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#ifeq:{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;Str_left|{{{1}}}|{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#expr:{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;str len|{{{2}}}*}}-1}}}}*|{{{2}}}*|{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;Str_right|{{{1}}}|{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#expr:{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;str len|{{{2}}}*}}-1}}}}|{{{1}}}}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>inq4uaotxq9x1gwjvnhr2q54yiej76f</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Str len</title>
    <ns>10</ns>
    <id>1836117</id>
    <revision>
      <id>53532746</id>
      <parentid>53504298</parentid>
      <timestamp>2013-03-14T14:34:59Z</timestamp>
      <contributor>
        <username>DR</username>
        <id>10758</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="153" xml:space="preserve">{{{{{|safesubst:}}}#invoke:String|len|s={{{1|}}}}}&lt;noinclude&gt;
{{doc}}

&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>hij81rzmkd4sn65qq73stt2lykqps5o</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Str rightc</title>
    <ns>10</ns>
    <id>2305802</id>
    <revision>
      <id>93909397</id>
      <parentid>89214622</parentid>
      <timestamp>2018-07-11T22:33:58Z</timestamp>
      <contributor>
        <username>A particle for world to form</username>
        <id>1086556</id>
      </contributor>
      <minor/>
      <comment>Для возможности использовать подстановку.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="206" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;Str sub|{{{1}}}|{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#expr:{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;Str len|{{{1}}}}}-{{{2}}}}}|{{{2}}}}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>0gumrm487z85cldaq3bh1yj6q5vlsww</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Hash</title>
    <ns>828</ns>
    <id>7178369</id>
    <revision>
      <id>112226329</id>
      <parentid>88771530</parentid>
      <timestamp>2021-02-07T10:01:11Z</timestamp>
      <contributor>
        <username>Grain of sand</username>
        <id>1731654</id>
      </contributor>
      <comment>+ list() для вывода списка доступных алгоритмов</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1452" xml:space="preserve">local getArgs = require('Module:Arguments').getArgs
local p = {}

local function inTable(table, value)
	for k, v in pairs(table) do
		if v == value then
			return true
		end
	end
	return false
end

function p.list(frame)
	return table.concat(mw.hash.listAlgorithms(), '; ')
end

function p.main(frame)
	local args = getArgs(frame, { frameOnly = true })
	local algorithm
	
	if not args[1] then
		return '&lt;span class="error"&gt;Не указана строка для хеширования.&lt;/span&gt;'
	end
	if args[2] then
		if not inTable(mw.hash.listAlgorithms(), args[2]) then
			return '&lt;span class="error"&gt;Алгоритм хеширования ' .. args[2] .. ' не поддерживается, или вы неточно указали его имя. Используйте функцию &lt;kbd&gt;mw.hash.listAlgorithms()&lt;/kbd&gt; для получения списка доступных алгоритмов.&lt;/span&gt;'
		end
		algorithm = args[2]
	else
		-- Алгоритм выбран из соображений быстродействия (см. [[:en:Fowler–Noll–Vo hash function]]),
		-- 64-битная функция используется для уменьшения вероятности коллизий до пренебрежимо малой
		-- величины. Возможно, есть лучшая опция — проверяйте.
		algorithm = 'fnv164'
	end
	
	return mw.hash.hashValue(algorithm, args[1])
end

return p</text>
      <sha1>avhe826vcfw3pw6hzbcq498ta7m1xws</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/официальное название</title>
    <ns>10</ns>
    <id>7921988</id>
    <revision>
      <id>105399951</id>
      <parentid>103927427</parentid>
      <timestamp>2020-02-29T12:06:43Z</timestamp>
      <contributor>
        <username>Helgo13</username>
        <id>1399880</id>
      </contributor>
      <minor/>
      <comment>Защитил страницу [[Шаблон:Карточка/официальное название]]: критический шаблон или модуль ([Редактирование=только администраторы] (бессрочно) [Переименование=только администраторы] (бессрочно))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="149" xml:space="preserve">{{wikidata|p1448[language!:ru]|{{{1|}}}|separator=&lt;br&gt;|conjunction=&lt;br&gt;|monolingualLangTemplate=lang|from={{{from|}}}}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>d598lgphnhxszyvjzr6zi5bgr0eyn1u</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Карточка/флаг и герб</title>
    <ns>10</ns>
    <id>7479195</id>
    <revision>
      <id>125791805</id>
      <parentid>115439592</parentid>
      <timestamp>2022-09-30T21:14:25Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>+ поддержка поля from</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1313" xml:space="preserve">{{#if:{{if-wikidata|p41|{{{флаг|}}}|1|from={{{from|}}}}}{{if-wikidata|p94|{{{герб|}}}|1|from={{{from|}}}}}|&lt;table role="presentation" style="background:inherit; border-collapse:collapse; width:100%; display:table; text-align:center;"&gt;
&lt;tr&gt;
{{if-wikidata|p41|{{{флаг|}}}|&lt;td style&lt;nowiki&gt;=&lt;/nowiki&gt;"vertical-align: middle"&gt;{{wikidata|p41|{{{флаг|}}}|from={{{from|}}}|border=true|size={{#if:{{{флаг ширина|}}}|{{{флаг ширина|}}}|160x160px}}|alt={{#if:{{{флаг подпись|}}} | {{{флаг подпись}}} | Флаг }} }}&lt;/td&gt;}}
{{if-wikidata|p94|{{{герб|}}}|&lt;td style&lt;nowiki&gt;=&lt;/nowiki&gt;"vertical-align: middle"&gt;{{wikidata|p94|{{{герб|}}}|from={{{from|}}}|size={{#if:{{{герб ширина|}}}|{{{герб ширина|}}}|90x160px}}|alt={{#if:{{{герб подпись|}}} | {{{герб подпись}}} | Герб }} }}&lt;/td&gt;}}
&lt;/tr&gt;
{{#if:{{if-wikidata|p41|{{{флаг|}}}|1|from={{{from|}}}}}{{if-wikidata|p94|{{{герб|}}}|1|from={{{from|}}}}}|&lt;tr&gt;
{{if-wikidata|p41|{{{флаг|}}}|&lt;td&gt;{{#if:{{{флаг подпись|}}} | {{{флаг подпись}}} | Флаг }}&lt;/td&gt;}}
{{if-wikidata|p94|{{{герб|}}}|&lt;td&gt;{{#if:{{{герб подпись|}}} | {{{герб подпись}}} | Герб }}&lt;/td&gt;}}
&lt;/tr&gt;}}&lt;/table&gt;
}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>cqeklqvyvparstm53rks7n8ge5nv2m5</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Doc</title>
    <ns>10</ns>
    <id>375802</id>
    <revision>
      <id>117408158</id>
      <parentid>116757342</parentid>
      <timestamp>2021-10-24T00:40:31Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <minor/>
      <comment>оформление кода при помощи [[u:JWBTH/CP|скрипта]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="533" xml:space="preserve">&lt;includeonly&gt;{{doc/begin|{{SUBJECTSPACE}}:{{PAGENAME:{{{1|{{SUBJECTPAGENAME}}/doc}}}}}}}
{{#if: {{{1|}}}
| {{#ifexist: {{{1}}}
  | {{{{{1}}}|{{{2|}}}|{{{3|}}}|{{{4|}}}|{{{5|}}}}}
  | {{#ifexist: {{SUBJECTSPACE}}:{{{1}}}
    | {{{{{1}}}|{{{2|}}}|{{{3|}}}|{{{4|}}}|{{{5|}}}}}
    | {{Документировать|{{{1}}}}}
    }}
  }}
| {{#ifexist: {{SUBJECTPAGENAME}}/doc
  | {{{{SUBJECTPAGENAME}}/doc}}
  | {{Документировать|{{SUBJECTPAGENAME}}/doc}}
  }}
}}
{{doc/end}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>6o5xayidmdfqbubyomw2kwcmqx6r88h</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Doc/begin</title>
    <ns>10</ns>
    <id>572138</id>
    <revision>
      <id>131975531</id>
      <parentid>116164374</parentid>
      <timestamp>2023-07-27T12:11:19Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>упрощение кода: clear можно перенести в стили, якори можно указать прямо</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="359" xml:space="preserve">&lt;includeonly&gt;&lt;templatestyles src="Шаблон:Doc/styles.css" /&gt;
&lt;div class="ts-doc-doc" id="doc"&gt;
&lt;div class="ts-doc-header" id="Документация"&gt;
&lt;div class="ts-doc-heading"&gt;Документация&lt;/div&gt;
{{#if: {{{inline|}}} || {{tlinks|lc={{{1}}}|nowatch=yes}} }}
&lt;/div&gt;
&lt;div class="ts-doc-content"&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>kh28d3zbe5qq623ua06py90t1rj3cds</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Doc/styles.css</title>
    <ns>10</ns>
    <id>7498033</id>
    <revision>
      <id>131975523</id>
      <parentid>130204070</parentid>
      <timestamp>2023-07-27T12:10:47Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>перенос из шаблона</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1647" xml:space="preserve">.ts-doc-doc {
	background-color: #eaf3ff;
	border: 1px solid #a3caff;
	clear: both;
	margin-top: 1em;
}

/* Ctrl+F ":target" in [[MediaWiki:Common.css]] */
.ts-doc-doc sup.reference:target,
.ts-doc-doc ol.references li:target,
.ts-doc-doc .highlight-target:target,
.ts-doc-doc cite:target,
.ts-doc-doc span.citation:target {
	background: #c2dcff;
}

.ts-doc-header {
	background-color: #c2dcff;
	padding: .642857em 1em .5em;
	overflow: hidden;
}

.ts-doc-header .ts-tlinks-tlinks {
	line-height: 24px;
}

.ts-doc-header .ts-tlinks-tlinks a.external {
	color: #0645ad;
}

.ts-doc-header .ts-tlinks-tlinks a.external:visited {
	color: #0b0080;
}

.ts-doc-header .ts-tlinks-tlinks a.external:active {
	color: #faa700;
}

.ts-doc-content {
	padding: .214286em 1em;
}

.ts-doc-content:after {
	content: '';
	clear: both;
	display: block;
}

.ts-doc-heading {
	display: inline-block;
	padding-left: 30px;
	background: url(//upload.wikimedia.org/wikipedia/commons/c/ca/OOjs_UI_icon_info.svg) center left/24px 24px no-repeat;
	height: 24px;
	line-height: 24px;
	font-size: 13px;
	font-weight: 600;
	letter-spacing: 1px;
	text-transform: uppercase;
}

.ts-doc-content &gt; *:first-child,
.ts-doc-footer &gt; *:first-child {
	margin-top: .5em;
}

.ts-doc-content &gt; *:last-child,
.ts-doc-footer &gt; *:last-child {
	margin-bottom: .5em;
}

.ts-doc-footer {
	background-color: #eaf3ff;
	border: 1px solid #a3caff;
	padding: .214286em 1em;
	margin-top: .214286em;
	margin-bottom: .214286em;
	font-style: italic;
}

@media (max-width: 719px) {
	.ts-doc-header .ts-tlinks-tlinks {
		float: none;
	}
}
/* [[Категория:Шаблоны:Подстраницы CSS]] */</text>
      <sha1>h4fw1yaa9ka0oz7kkjpmih719l1igrv</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Tlinks</title>
    <ns>10</ns>
    <id>7990428</id>
    <redirect title="Шаблон:Действия для страницы" />
    <revision>
      <id>101625640</id>
      <timestamp>2019-08-15T18:37:09Z</timestamp>
      <contributor>
        <username>Jack who built the house</username>
        <id>60281</id>
      </contributor>
      <comment>Jack who built the house переименовал страницу [[Шаблон:Tlinks]] в [[Шаблон:Действия для страницы]]: русификация</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="89" xml:space="preserve">#перенаправление [[Шаблон:Действия для страницы]]</text>
      <sha1>gio5zjd0an2wn5ocboosr6cnx6do0z9</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Действия для страницы</title>
    <ns>10</ns>
    <id>1647829</id>
    <revision>
      <id>136988036</id>
      <parentid>136927519</parentid>
      <timestamp>2024-03-31T11:50:39Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>не требуется</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1245" xml:space="preserve">&lt;templatestyles src="Шаблон:Действия для страницы/styles.css" /&gt;&lt;div style="{{#ifeq: {{yesno-yes|{{{right|}}}}} | yes || float:none; }} {{#if: {{{fontsize|}}} | font-size:{{{fontsize|}}}px; }}" class="ts-tlinks-tlinks plainlinks"&gt;&lt;span class="mw-editsection-bracket"&gt;[&lt;/span&gt;&lt;!--
--&gt;{{join|separator=&lt;span class="mw-editsection-divider"&gt; &amp;amp;#124; &lt;/span&gt;
|1={{#ifexist: {{#rel2abs: {{{lc|}}} }}
  | {{#ifeq: {{{dislooklink|{{{noview|}}}}}} | yes || [[{{{lc}}}|просмотр]] }}
  }}
|2={{#ifexist: {{#rel2abs: {{{lc|}}} }}
  | [[Special:EditPage/{{#rel2abs: {{{lc}}} }}|править]]
  }}
|3={{#ifexist: {{#rel2abs: {{{lc|}}} }}
  | {{#ifeq: {{{dishistlink|{{{nohistory|}}}}}} | yes || [[Special:PageHistory/{{#rel2abs: {{{lc}}} }}|история]] }}
  }}
|4={{#ifexist: {{#rel2abs: {{{lc|}}} }}
  |
  | [{{fullurl:{{#rel2abs: {{{lc}}} }}|action=edit&amp;redlink=1}} создать]
  }}
|5={{#ifeq: {{{diswatchlink|{{{nowatch|}}}}}} | yes || [{{fullurl:{{#rel2abs: {{{lc}}} }}|action=watch}} следить] }}
|6={{#ifeq: {{{disupdlink|{{{noupdate|}}}}}} | yes || {{очистить кэш|обновить|nocat=1}}&lt;/span&gt; }}
}}&lt;span class="mw-editsection-bracket"&gt;]&lt;/span&gt;&lt;/div&gt;&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>nz7wobixxx49cuwpx44457zsmt3q5s6</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Действия для страницы/styles.css</title>
    <ns>10</ns>
    <id>7498000</id>
    <revision>
      <id>113288064</id>
      <parentid>104610269</parentid>
      <timestamp>2021-03-30T05:56:55Z</timestamp>
      <contributor>
        <username>WindEwriX</username>
        <id>163434</id>
      </contributor>
      <comment>категоризация</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="212" xml:space="preserve">.ts-tlinks-tlinks {
	font-weight: normal;
	float: right;
	font-size: 13px;
}

.ts-tlinks-tlinks .mw-editsection-divider {
	display: inline;
}
/* [[Категория:Шаблоны:Подстраницы CSS]] */</text>
      <sha1>j2fw648orx9sqa87a6afki3zl9cbid3</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Doc/end</title>
    <ns>10</ns>
    <id>572074</id>
    <revision>
      <id>112384529</id>
      <parentid>110204645</parentid>
      <timestamp>2021-02-14T18:18:13Z</timestamp>
      <contributor>
        <username>Putnik</username>
        <id>19501</id>
      </contributor>
      <comment>для модулей предзагрузка нормально не работает</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2138" xml:space="preserve">&lt;includeonly&gt;&lt;/div&gt;
&lt;/div&gt;&lt;templatestyles src="Шаблон:Doc/styles.css" /&gt;{{#ifexpr: {{NAMESPACENUMBER}} mod 2 = 1  &lt;!-- Например, [[Обсуждение MediaWiki:Robots.txt]] --&gt;
| {{^|1em}}
| &lt;div class="ts-doc-footer plainlinks"&gt;
{{#ifeq: {{str left|{{PAGENAME}}|9}}
  | Песочница 
  | 
  | {{#ifeq: {{str rightc|{{PAGENAME}}|10}}
    | /песочница
    | 
    | Во избежание поломок страниц, использующих этот {{#ifeq: {{NAMESPACE}}
      | Модуль
      | модуль
      | шаблон
      }}, экспериментируйте в [[Википедия:Правка и тестирование шаблонов в песочнице|песочнице]] &lt;small style="font-style:normal;"&gt;({{#ifexist: {{FULLPAGENAME}}/песочница
      | [{{fullurl:{{FULLPAGENAME}}/песочница|action=edit}} редактировать] {{!}} [{{fullurl:Special:ComparePages|page1={{FULLPAGENAMEE}}&amp;page2={{FULLPAGENAMEE}}/песочница}} разница] {{#ifexist: {{FULLPAGENAME}}/тесты | {{!}} [[{{FULLPAGENAME}}/тесты|тесты]] }}
      | {{#ifeq: {{NAMESPACE}} | Модуль | [{{fullurl:{{FULLPAGENAME}}/песочница|action=edit}} создать] | [{{fullurl:{{FULLPAGENAME}}/песочница|action=edit&amp;preload=Шаблон:Doc/предзагрузка-песочница}} создать] {{!}} [{{fullurl:{{FULLPAGENAME}}/песочница|action=edit&amp;preload=Шаблон:Doc/зеркало}} зеркало] }}
      }})&lt;/small&gt; или {{#ifeq: {{NAMESPACE}}
      | Модуль
      | [[Модуль:Песочница|песочнице для модулей]]
      | своём [[ВП:ЛП|личном пространстве]]
      }}.&lt;br&gt;
    }}
  }}{{#ifexist: {{FULLPAGENAME}}/doc | Пожалуйста, добавляйте категории на подстраницу [[/doc]].&amp;#32;}}[[Special:PrefixIndex/{{FULLPAGENAME}}/|Подстраницы этого {{#ifeq: {{NAMESPACE}}
  | Модуль
  | модуля
  | шаблона
  }}]].
&lt;/div&gt;
}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>dq9x4crax1uvqb8e20lgz6a30md6zda</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Lang-sv</title>
    <ns>10</ns>
    <id>40814</id>
    <revision>
      <id>89566426</id>
      <parentid>71609826</parentid>
      <timestamp>2017-12-10T06:47:12Z</timestamp>
      <contributor>
        <username>Dima st bk</username>
        <id>731940</id>
      </contributor>
      <comment>langi</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="100" xml:space="preserve">[[шведский язык|швед.]] {{langi|sv|{{{1}}}}}&lt;noinclude&gt;{{doc|Lang/doc}}
&lt;/noinclude&gt;</text>
      <sha1>mz7h2c62cf0jutpmtcjfada6fmntijj</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Docpage</title>
    <ns>10</ns>
    <id>376268</id>
    <revision>
      <id>126918335</id>
      <parentid>116009488</parentid>
      <timestamp>2022-11-27T17:16:59Z</timestamp>
      <contributor>
        <username>Dima st bk</username>
        <id>731940</id>
      </contributor>
      <comment>возврат параметров шаблонов, пока неполноценных</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1108" xml:space="preserve">&lt;includeonly&gt;{{#ifeq: {{SUBPAGENAME}} | doc
| {{fmbox
  | class = hlist nowraplinks
  | style = margin-bottom:1em; background:#eaf3ff; border:1px solid #a3caff;
  | image = [[Файл:OOjs UI icon info.svg|24px|link=|alt=]]
  | text  = &lt;div&gt;
* [[:{{#titleparts: {{SUBJECTPAGENAME}} | -1 }}]]
* [[:{{SUBJECTPAGENAME}}|Документация]]
* [[{{#titleparts: {{TALKPAGENAME}} | -1 }}|Обсуждение]]
* [[Служебная:Whatlinkshere/{{#titleparts: {{SUBJECTPAGENAME}} | -1 }}|Где используется]] {{#ifeq: {{NAMESPACE}} | {{ns:Template}} |
** {{Параметры шаблона|{{#titleparts: {{PAGENAME}} | -1 }}}}
}}&lt;/div&gt;&lt;!--
--&gt;{{#if: {{{nocat|}}} || {{#ifexist: {{NAMESPACE}}:{{BASEPAGENAME}} || [[Категория:Шаблоны:Документация несуществующих шаблонов]] }} }}
  }}{{#if: {{{nocat|}}} || {{#ifeq: {{NAMESPACE}}
    | Модуль
    | [[Категория:Модули:Документация]]
    | [[Категория:Шаблоны:Документация]]
    }}
  }}
}}&lt;/includeonly&gt;&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>1l3dqsx17zqoaw59emtznrgfjzkhu9a</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Очистить кэш</title>
    <ns>10</ns>
    <id>151226</id>
    <revision>
      <id>136918569</id>
      <parentid>136905174</parentid>
      <timestamp>2024-03-27T11:58:48Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>не помещать на все страницы ежедневную очистку кэша</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="609" xml:space="preserve">&lt;!-- Класс purgelink и атрибут data-pagename используются в [[MediaWiki:Common.js]], чтобы очищать кэш без перехода на отдельную страницу --&gt;&lt;span class="noprint purgelink" {{#if: {{{2|}}} | data-pagename="{{{2}}}" }}&gt;{{выполнить скрипт|purgeLink}}[[Special:Purge/{{#if: {{{2|}}} | {{{2}}} | {{FULLPAGENAME}} }}|{{#if: {{{1|}}} | {{{1}}} | Очистить кэш }}]]&lt;/span&gt;{{#ifeq: {{NAMESPACE}}{{{nocat|}}}
| {{ns:10}} &lt;!-- Шаблон --&gt;
| {{очищать кэш|ежедневно}}
}}&lt;noinclude&gt;{{doc}}&lt;/noinclude&gt;</text>
      <sha1>m8o8ougss1olgp8c3o8lqvmc02ekm0r</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Население государства</title>
    <ns>10</ns>
    <id>2525215</id>
    <revision>
      <id>80254393</id>
      <parentid>63481230</parentid>
      <timestamp>2016-08-16T20:27:21Z</timestamp>
      <contributor>
        <username>SandBot</username>
        <id>1829068</id>
      </contributor>
      <minor/>
      <comment>/* top */удаление устаревшего ключа сортировки</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="276" xml:space="preserve">&lt;includeonly&gt;{{#switch: {{{1}}}
 | Республика Южная Осетия = Население Южной Осетии{{!}}Население
 | Население
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{doc}}
[[Категория:Шаблоны по странам]]
&lt;/noinclude&gt;</text>
      <sha1>q7dwj48roic4673ps12eeawcpwa3dy7</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Lang-fi</title>
    <ns>10</ns>
    <id>28909</id>
    <revision>
      <id>71609798</id>
      <parentid>67783309</parentid>
      <timestamp>2015-06-22T08:43:43Z</timestamp>
      <contributor>
        <username>DimaABot</username>
        <id>1588734</id>
      </contributor>
      <minor/>
      <comment>Бот: удаление категории по запросу на [[ВП:РДБ]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="96" xml:space="preserve">[[финский язык|фин.]] {{langi|fi|{{{1}}}}}&lt;noinclude&gt;{{doc|Lang/doc}}
&lt;/noinclude&gt;</text>
      <sha1>2ncki69v6ry528e1imsgkcegr2gehi4</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Выполнить скрипт</title>
    <ns>10</ns>
    <id>3407248</id>
    <revision>
      <id>137129784</id>
      <parentid>136939309</parentid>
      <timestamp>2024-04-07T13:34:28Z</timestamp>
      <contributor>
        <username>Stjn</username>
        <id>691231</id>
      </contributor>
      <comment>отключение старой схемы</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="441" xml:space="preserve">{{#switch: {{{1|}}}
| =
| mainPage = [[Категория:Википедия:Заглавная страница|{{NAMESPACENUMBER}}]]
| #default = {{#ifexist: Категория:Википедия:Страницы с гаджетом по требованию {{{1}}} | [[Категория:Википедия:Страницы с гаджетом по требованию {{{1}}}|{{NAMESPACENUMBER}}]] }}
}}&lt;noinclude&gt;
{{doc}}
&lt;/noinclude&gt;</text>
      <sha1>cbjr8muvp23jk7t0jo1qhkgo4oe5ieb</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Demo</title>
    <ns>10</ns>
    <id>6933623</id>
    <revision>
      <id>99423147</id>
      <parentid>85527670</parentid>
      <timestamp>2019-04-25T13:40:59Z</timestamp>
      <contributor>
        <username>QBA-bot</username>
        <id>1687411</id>
      </contributor>
      <minor/>
      <comment>Защитил страницу [[Шаблон:Demo]]: критический шаблон или модуль (каскадная защита) ([Редактирование=только автоподтверждённые] (бессрочно) [Переименование=только автоподтверждённые] (бессрочно))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="61" xml:space="preserve">{{#invoke:Demo|main}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>qo8uxqtbhlvri8ihi5293by4l1j4soc</sha1>
    </revision>
  </page>
  <page>
    <title>Модуль:Demo</title>
    <ns>828</ns>
    <id>6933621</id>
    <revision>
      <id>99423151</id>
      <parentid>97546521</parentid>
      <timestamp>2019-04-25T13:41:01Z</timestamp>
      <contributor>
        <username>QBA-bot</username>
        <id>1687411</id>
      </contributor>
      <minor/>
      <comment>Защитил страницу [[Модуль:Demo]]: критический шаблон или модуль (каскадная защита) ([Редактирование=только автоподтверждённые] (бессрочно) [Переименование=только автоподтверждённые] (бессрочно))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4882" xml:space="preserve">local p = {}

--creates a frame object that cannot access any of the parent's args
--unless a table containing a list keys of not to inherit is provided
function disinherit(frame, onlyTheseKeys)
	local parent = frame:getParent() or frame
	local orphan = parent:newChild{}
	orphan.getParent = parent.getParent --returns nil
	orphan.args = {}
	if onlyTheseKeys then
		local family = {parent, frame}
		for f = 1, 2 do
			for k, v in pairs(family[f] and family[f].args or {}) do
				orphan.args[k] = orphan.args[k] or v
			end
		end
		parent.args = mw.clone(orphan.args)
		setmetatable(orphan.args, nil)
		for _, k in ipairs(onlyTheseKeys) do
			rawset(orphan.args, k, nil)
		end
	end
	return orphan, parent
end

function p.get(frame, arg, passArgs)
	local orphan, frame = disinherit(frame, passArgs and {arg or 1})
	local code, noWiki, preserve = frame.args[arg or 1] or ''
	local kill_categories = not frame.args.save_categories
	local tag, sep
	if code:match'nowiki' then
		local placeholder, preserve = ('6'):char(), {}
		-- We replace "&amp;#125;%-" and "%-&amp;#123;" because of some server bug probably connected to
		-- [[mw:Parsoid/MediaWiki DOM spec/Language conversion blocks]] and leading to
		-- =mw.text.unstripNoWiki(mw.getCurrentFrame():preprocess('&lt;nowiki&gt;}-&lt;/nowiki&gt;'))
		-- outputting '&amp;#125;-' instead of "}-", while it's ok with "&lt;nowiki&gt;} -&lt;/nowiki&gt;"
		code = mw.text.unstripNoWiki(code)
			:gsub('&amp;lt;', '&lt;')
			:gsub('&amp;gt;', '&gt;')
			:gsub('&amp;#125;%-', '}-')
			:gsub('%-&amp;#123;', '-{')
		if (mw.text.trim(code):match'\n') then
			tag = 'pre'
			sep = ''
		end
		noWiki = code:gsub('%%', placeholder)
		for k in noWiki:gmatch('&amp;.-;') do
			table.insert(preserve, (k:gsub('&amp;', '&amp;amp;')))
			noWiki = noWiki:gsub('(&amp;.-;)', '%%%s')
		end
		noWiki = mw.text.nowiki(noWiki):format(unpack(preserve)):gsub(placeholder, '%%')
	end
	return {
		source = noWiki or code,
		output = orphan:preprocess(code)
			:gsub(kill_categories and '%[%[Категория:.-%]%]' or '', '')
			:gsub(kill_categories and '%[%[К:.-%]%]' or '', '')
			:gsub(kill_categories and '%[%[Category:.-%]%]' or '', ''),
		frame = frame,
		tag = tag,
		sep = sep
	}
end

function p.main(frame, demoTable)
	local show = demoTable or p.get(frame)
	local args = show.frame.args
	local yesno = require('Module:Yesno')
	args.reverse = yesno(args.reverse, false)
    args.tag = args.tag or show.tag or "code"
    args.sep = args.sep or args.br or show.sep
	args.sep = tonumber(args.sep) and ('&lt;br&gt;'):rep(args.sep or 0) or args.sep or (args.tag == 'pre' and '' or ' → ')
	if show[args.result_arg] then
		return show[args.result_arg]
	end
	return args.reverse
		and string.format('%s%s&lt;%s%s&gt;%s&lt;/%s&gt;', show.output, args.sep, args.tag, args.style and string.format(" style='%s'", args.style) or '', show.source, args.tag)
		or string.format('&lt;%s%s&gt;%s&lt;/%s&gt;%s%s', args.tag, args.style and string.format(" style='%s'", args.style) or '', show.source, args.tag, args.sep, show.output)
end

--passing of args into other module without preprocessing
function p.module(frame)
	local orphan, frame = disinherit(frame, {
		'demo_template',
		'demo_module',
		'demo_module_func',
		'demo_main',
		'demo_br',
		'demo_result_arg',
		'demo_save_categories'
	})
	local template = frame.args.demo_template and 'Template:'..frame.args.demo_template
	local demoFunc = frame.args.demo_module_func or 'main\n'
	local demoModule = require('Module:' .. frame.args.demo_module)[demoFunc:match('^%s*(.-)%s*$')]
	frame.args.br, frame.args.result_arg = frame.args.demo_br or frame.args.demo_sep, frame.args.demo_result_arg
	local kill_categories = not save_categories
	if demoModule then
		local named = {insert = function(self, ...) table.insert(self, ...) return self end}
		local source = {insert = named.insert, '{{', frame.args.demo_template or frame.args.demo_module, '\n'}
		if not template then
			source:insert(2, '#invoke:'):insert(4, '|'):insert(5, demoFunc)
		end
		local insertNamed = #source + 1
		for k, v in pairs(orphan.args) do
			local nan, insert = type(k) ~= 'number', {v}
			local target = nan and named or source
			target:insert'|'
			if nan then
				target:insert(k):insert'=':insert'\n'
				table.insert(insert, 1, #target)
			end
			target:insert(unpack(insert))
			local nowiki = v:match('nowiki')
			if nowiki or v:match('{{.-}}') then
				orphan.args[k] = frame:preprocess(nowiki and mw.text.unstripNoWiki(v) or v)
			end
		end
		source:insert'}}'
		table.insert(source, insertNamed, table.concat(named))
		return p.main(orphan, {
			source = mw.text.encode(table.concat(source), "&lt;&gt;'|=~"),
			output = tostring(demoModule(orphan)):gsub(kill_categories and '%[%[Категория:.-%]%]' or '', ''):gsub(kill_categories and '%[%[К:.-%]%]' or '', ''):gsub(kill_categories and '%[%[Category:.-%]%]' or '', ''),
			frame = frame
		})
	else
		return "ERROR: Invalid module function: "..demoFunc
	end
end

return p</text>
      <sha1>ql3d68z7r4mdoxmpxpqdueof72wn0x2</sha1>
    </revision>
  </page>
  <page>
    <title>Шаблон:Государство/doc</title>
    <ns>10</ns>
    <id>937338</id>
    <revision>
      <id>133542635</id>
      <parentid>133542540</parentid>
      <timestamp>2023-10-11T16:26:29Z</timestamp>
      <contributor>
        <username>CyberNik01</username>
        <id>2352023</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="19221" xml:space="preserve">{{docpage}}
Этот [[Википедия:Шаблоны-карточки|шаблон-карточка]] используется для вставки карточки в статьи о современных государствах;

* для исторических государств используйте {{t|историческое государство}}.
* для составных частей государств используйте {{t|Административная единица}}.

== Образец для копирования ==
&lt;pre&gt;
{{Государство
 |Статус                   = &lt;!-- виртуальное / непризнанное / частично признанное / регион; для признанных государств не заполнять --&gt;
 |Русское название         = 
 |Оригинальное название    = 
 |Родительный падеж        = 
 |Герб                     = 
 |Вместо герба             = 
 |Девиз                    = {{lang-??2|}}&lt;!-- на оф. языке / языках гос-ва --&gt;
 |Перевод девиза           = 
 |Название гимна           = 
 |Перевод названия гимна   =
 |Аудио                    = 
 |Форма правления          = 
 |Государственный строй    = 
 |Государственная религия  = 
 |На карте                 = 
  |подпись к карте         = 
 |На карте2                = 
 |Язык/Языки               = 
 |Основано/Основана        = 
 |Дата/Даты независимости  = 
 |Независимость от         = 
 |Столица                  = 
 |Крупнейшие города        = 
 |Должность руководителя 1 = 
 |Руководитель 1           = 
 |Должность руководителя 2 = 
 |Руководитель 2           = 
 |Должность руководителя 3 = 
 |Руководитель 3           = 
 |Должность руководителя 4 = 
 |Руководитель 4           = 
 |Должность руководителя 5 = 
 |Руководитель 5           = 
 |Место по территории      = 
 |Территория               = 
 |Процент воды             = 
 |Этнохороним              = 
  |Место по населению      = 
  |Население               = 
  |Год оценки              = 
  |Население по переписи   = 
  |Год переписи            = 
  |Плотность населения     = 
  |Место по плотности      = 
 |ВВП (ППС)                = 
 |Год расчёта ВВП (ППС)    = 
 |Место по ВВП (ППС)       = 
 |ВВП (ППС) на душу населения = 
 |Место по ВВП (ППС) на душу населения = 
 |ВВП (номинал)             = 
 |Год расчёта ВВП (номинал) = 
 |Место по ВВП (номинал)    = 
 |ВВП (номинал) на душу населения = 
 |Место по ВВП (номинал) на душу населения = 
 |ИРЧП                     = 
 |Год расчёта ИРЧП         = 
 |Место по ИРЧП            = 
 |Уровень ИРЧП             = 
 |Валюта                   = 
 |Домен/Домены             = 
 |Телефонный код           = 
 |Часовой пояс             = 
 |Автомобильное движение   = 
 |Примечания               = 
&lt;!-- |Без флага и герба=* --&gt;
&lt;!-- |Без гимна=* --&gt;
}}
&lt;/pre&gt;

== Описание параметров ==
Некоторые параметры могут быть заданы в разных формах (например, в единственном либо множественном числе). После копирования образца в статью заполните только строку с более подходящей формой. Например, в статье [[Албания]]&amp;nbsp;—
&lt;pre&gt; |Язык                    = [[Албанский язык|албанский]]&lt;/pre&gt;
а в статье [[Канада]]&amp;nbsp;—
&lt;pre&gt; |Языки                   = [[Английский язык|английский]] и [[Французский язык|французский]]&lt;/pre&gt;

Для статей о регионах с нечётким правовым статусом используйте параметр &lt;code&gt;Спорный статус = да&lt;/code&gt; и параметры «Основано», «Дата образования», «Провозглашение независимости» и «Дипломатическое признание» вместо «Дата независимости» и «Основано»:
&lt;pre&gt;
 |Спорный статус               = да
 |Основано                     = 
 |Основана                     = 
 |Дата образования             = 
 |Провозглашение независимости = 
 |Дипломатическое признание    = 
 |Независимость от             = 
&lt;/pre&gt;

Для статей о [[Непризнанные и частично признанные государства|непризнанных государствах]] или [[Автономный регион|автономных регионах]], не являющихся самостоятельными государствами, используйте параметр &lt;code&gt;Статус&amp;nbsp;=&amp;nbsp;непризнанное&lt;/code&gt; или &lt;code&gt;Статус = регион&lt;/code&gt;, это отключит автоматическое добавление категории [[:Категория:Государства по алфавиту|Государства по алфавиту]], а в первом случае также добавит категорию [[:Категория:Непризнанные государства|Непризнанные государства]]. Для статей о [[Виртуальное государство|виртуальных государствах]] используйте параметр &lt;code&gt;Статус = виртуальное&lt;/code&gt;, это добавит категорию [[:Категория:Виртуальные государства|Виртуальные государства]].

== Пример использования ==
{{demo|reverse=1|br=|&lt;nowiki&gt;{{Государство
 |Русское название        = Финляндская Республика
 |Оригинальное название   = {{lang-fi|Suomen Tasavalta}}&lt;br&gt;{{lang-sv|Republiken Finland}}
 |Родительный падеж       = Финляндии
 |Герб                    = Coat of arms of Finland.svg
 |Флаг                    = Flag of Finland.svg&lt;!-- иначе используется конструкция {{флаг|{{FULLPAGENAME}}|размер=135px}} --&gt;
 |Вместо герба            = 
 |Девиз                   = 
 |Перевод девиза          = 
 |Название гимна          = Maamme
 |Перевод названия гимна  = Наш край
 |Аудио                   = 
 |Форма правления         = [[президентская республика]]
 |Государственный строй   = [[унитарное государство]]
 |Государственная религия = 
 |На карте                = EU-Finland.svg
  |подпись к карте        = Расположение '''Финляндии''' (тёмно-зелёный):&lt;br&gt;— в [[Европа|Европе]] (светло-зелёный и тёмно-серый)&lt;br&gt;— в [[Европейский союз|Европейском союзе]] (светло-зелёный)
 |На карте2               = 
 |Языки                   = [[финский язык|финский]], [[шведский язык|шведский]]
 |Основано/Основана       =
 |Дата независимости      = [[6 декабря]] [[1917]]
 |Независимость от        = [[Россия|России]]
 |Столица                 = [[Хельсинки]]
 |Крупнейший город        = Хельсинки
 |Должность руководителя 1 = [[Президент Финляндии|Президент]]
 |Руководитель 1           = [[Халонен, Тарья Каарина|Тарья Халонен]]
 |Должность руководителя 2 = [[Премьер-министр Финляндии|Премьер-министр]]
 |Руководитель 2           = [[Ванханен, Матти Танели|Матти Ванханен]]
 |Место по территории     = 63
 |Территория              = 338 145
 |Процент воды            = 9,96
 |Этнохороним             = финляндец, финляндка
  |Место по населению     = 106
  |Население              = 5 219 732
  |Год оценки             = 2003
  |Население по переписи  = 
  |Год переписи           = 
  |Плотность населения    = 15,4
  |Место по плотности     = 
 |ВВП                     = 
 |Год расчёта ВВП         = 
 |Место по ВВП            = 
 |ВВП на душу населения   = 
 |Место по ВВП на душу населения =
 |ИРЧП                    = 
 |Год расчёта ИРЧП        = 
 |Место по ИРЧП           = 
 |Уровень ИРЧП            = 
 |Валюта                  = [[евро]]&lt;ref name="money"&gt;до 2002 — [[финская марка]]&lt;/ref&gt;
 |Домены                  = [[.fi]], [[.ax]] (для [[Аландские острова|Аландских островов]])
 |Телефонный код          = 358
 |Часовой пояс            = +2
 |Автомобильное движение  = 
 |Примечания              = &lt;references/&gt;
}}&lt;/nowiki&gt;}}

== TemplateData ==
&lt;templatedata&gt;
{
	"params": {
		"Спорный статус": {},
		"Статус": {},
		"Русское название": {},
		"Оригинальное название": {},
		"Флаг": {
			"type": "wiki-file-name"
		},
		"Ссылка на флаг": {},
		"Родительный падеж": {},
		"Герб": {
			"type": "wiki-file-name"
		},
		"Отображаемая подпись герба": {},
		"Вместо герба": {},
		"Девиз": {},
		"Перевод девиза": {},
		"Без гимна": {},
		"Название гимна": {},
        "Перевод названия гимна": {},
		"Аудио": {},
		"На карте": {},
		"На карте2": {},
		"Дата1": {},
		"Дата2": {},
		"Дата3": {},
		"Дата4": {},
		"Дата5": {},
		"Дата6": {},
		"Дата7": {},
		"Дата8": {},
		"Дата9": {},
		"Дата10": {},
		"Дата11": {},
		"Дата12": {},
		"sovereignty_type": {},
		"Этап1": {},
		"Этап2": {},
		"Этап3": {},
		"Этап4": {},
		"Этап5": {},
		"Этап6": {},
		"Этап7": {},
		"Этап8": {},
		"Этап9": {},
		"Этап10": {},
		"Этап11": {},
		"Этап12": {},
		"Основана": {},
		"Основано": {},
		"Дата образования": {},
		"Провозглашение независимости": {},
		"Независимость от": {},
		"Дипломатическое признание": {},
		"Отображаемый тип независимости": {},
		"Даты независимости": {},
		"Дата независимости": {},
		"Язык": {},
		"Языки": {},
		"Столица": {},
		"Крупнейший город": {},
		"Крупнейшие города": {},
		"Форма правления": {},
		"Должность руководителя 1": {},
		"Должности руководителей": {},
		"Руководитель 1": {},
		"Руководители": {},
		"Должность руководителя 2": {},
		"Руководитель 2": {},
		"Должность руководителя 3": {},
		"Руководитель 3": {},
		"Должность руководителя 4": {},
		"Руководитель 4": {},
		"Должность руководителя 5": {},
		"Руководитель 5": {},
		"Государственная религия": {},
		"Место по территории": {},
		"Территория": {},
		"Процент воды": {},
		"Территория2": {},
		"Население": {},
		"Год оценки": {},
		"Год переписи": {},
		"Население2": {},
		"Место по населению": {},
		"Население по переписи": {},
		"Плотность населения": {},
		"Место по плотности": {},
		"ВВП": {},
		"Год расчёта ВВП": {},
		"Место по ВВП": {},
		"ВВП на душу населения": {},
		"Место по ВВП на душу населения": {},
		"ВВП (ППС)": {},
		"Год расчёта ВВП (ППС)": {},
		"Место по ВВП (ППС)": {},
		"ВВП (ППС) на душу населения": {},
		"Место по ВВП (ППС) на душу населения": {},
		"ВВП (номинал)": {},
		"Год расчёта ВВП (номинал)": {},
		"Место по ВВП (номинал)": {},
		"ВВП (номинал) на душу населения": {},
		"Место по ВВП (номинал) на душу населения": {},
		"Год расчёта ИРЧП": {},
		"ИРЧП": {},
		"Уровень ИРЧП": {},
		"Место по ИРЧП": {},
		"Этнохороним": {},
		"Валюта": {},
		"Домены": {},
		"Домен": {},
		"Телефонный код": {},
		"Часовые пояса": {},
		"Часовой пояс": {},
		"Примечания": {},
		"nocat": {
			"type": "boolean"
		},
		"lat_deg": {},
		"lat_min": {},
		"lat_sec": {},
		"lat_dir": {},
		"lon_deg": {},
		"lon_min": {},
		"lon_sec": {},
		"lon_dir": {},
		"region": {},
		"CoordScale": {},
		"Размер герба": {
			"aliases": [
				"размер герба"
			],
			"type": "number"
		},
		"Размер флага": {
			"aliases": [
				"размер флага"
			],
			"type": "number"
		},
		"Размер карты": {
			"aliases": [
				"размер карты"
			]
		},
		"Подпись к карте": {
			"aliases": [
				"подпись к карте"
			]
		},
		"Размер карты2": {
			"aliases": [
				"размер карты2"
			]
		},
		"Государственный строй": {},
		"Автомобильное движение": {}
	},
	"paramOrder": [
		"Статус",
		"Спорный статус",
		"Русское название",
		"Оригинальное название",
		"Флаг",
		"Размер флага",
		"Ссылка на флаг",
		"Родительный падеж",
		"Герб",
		"Размер герба",
		"Отображаемая подпись герба",
		"Вместо герба",
		"Девиз",
		"Перевод девиза",
		"Без гимна",
		"Название гимна",
        "Перевод названия гимна",
		"Аудио",
		"На карте",
		"Размер карты",
		"Подпись к карте",
		"На карте2",
		"Размер карты2",
		"Дата1",
		"Дата2",
		"Дата3",
		"Дата4",
		"Дата5",
		"Дата6",
		"Дата7",
		"Дата8",
		"Дата9",
		"Дата10",
		"Дата11",
		"Дата12",
		"sovereignty_type",
		"Этап1",
		"Этап2",
		"Этап3",
		"Этап4",
		"Этап5",
		"Этап6",
		"Этап7",
		"Этап8",
		"Этап9",
		"Этап10",
		"Этап11",
		"Этап12",
		"Основана",
		"Основано",
		"Дата образования",
		"Провозглашение независимости",
		"Независимость от",
		"Дипломатическое признание",
		"Отображаемый тип независимости",
		"Даты независимости",
		"Дата независимости",
		"Язык",
		"Языки",
		"Столица",
		"Крупнейший город",
		"Крупнейшие города",
		"Форма правления",
		"Государственный строй",
		"Должность руководителя 1",
		"Должности руководителей",
		"Руководитель 1",
		"Руководители",
		"Должность руководителя 2",
		"Руководитель 2",
		"Должность руководителя 3",
		"Руководитель 3",
		"Должность руководителя 4",
		"Руководитель 4",
		"Должность руководителя 5",
		"Руководитель 5",
		"Государственная религия",
		"Место по территории",
		"Территория",
		"Процент воды",
		"Территория2",
		"Население",
		"Год оценки",
		"Год переписи",
		"Население2",
		"Место по населению",
		"Население по переписи",
		"Плотность населения",
		"Место по плотности",
		"ВВП",
		"Год расчёта ВВП",
		"Место по ВВП",
		"ВВП на душу населения",
		"Место по ВВП на душу населения",
		"ВВП (ППС)",
		"Год расчёта ВВП (ППС)",
		"Место по ВВП (ППС)",
		"ВВП (ППС) на душу населения",
		"Место по ВВП (ППС) на душу населения",
		"ВВП (номинал)",
		"Год расчёта ВВП (номинал)",
		"Место по ВВП (номинал)",
		"ВВП (номинал) на душу населения",
		"Место по ВВП (номинал) на душу населения",
		"Год расчёта ИРЧП",
		"ИРЧП",
		"Уровень ИРЧП",
		"Место по ИРЧП",
		"Этнохороним",
		"Валюта",
		"Домены",
		"Домен",
		"Телефонный код",
		"Часовые пояса",
		"Часовой пояс",
		"Автомобильное движение",
		"Примечания",
		"lat_deg",
		"lat_min",
		"lat_sec",
		"lat_dir",
		"lon_deg",
		"lon_min",
		"lon_sec",
		"lon_dir",
		"region",
		"CoordScale",
		"nocat"
	],
	"format": "block"
}
&lt;/templatedata&gt;

== См. также ==
* {{tl|Историческое государство}}

&lt;includeonly&gt;
[[Категория:Шаблоны-карточки:Географические объекты]]
&lt;/includeonly&gt;</text>
      <sha1>ks1lln2ximeokojm2hruvwzaq0clwku</sha1>
    </revision>
  </page>
</mediawiki>
